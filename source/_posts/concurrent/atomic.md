---
title: JDK8新增原子操作类LongAdder
date: 2019-01-09 21:46:00
tags:
 - 并发包
 - 面试
categories: 
 - 并发包
---

### 介绍

使用AtomicLong时，在高并发下大量线程会同时去竞争更新同一个原子变量，但是由于同时只有一个线程的CAS操作会成功，这就造成了大量线程竞争失败后通过无限循环不断进行自旋尝试CAS的操作，这会浪费CPU资源。

~~~java
public final long incrementAndGet() {
    for (;;) {
        long current = get();
        long next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}
~~~

因此JDK8新增了一个原子性递增或者递减类LongAdder用来克服在高并发下使用AtomicLong的缺点。

<!-- more -->

### LongAdder原理

把一个变量分解为多个变量，让同样多的线程去竞争多个资源那么性能问题不就解决了，LongAdder就是这个思路。如图AtomicLong是多个线程同时竞争同一个变量：

![](atomic\aa01.png)

如图LongAdder则是内部维护多个变量，每个变量初始化都0，在同等并发量的情况下，争夺单个变量的线程量会减少这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后获取当前值时候是把所有Cell变量的值累加后再加上base返回的。

![](atomic\aa02.png)

LongAdder维护了一个延迟初始化的原子性更新数组（默认情况下Cell数组是null）和一个基值变量base。由于Cells占用内存是相对比较大的，所以一开始并不创建，而是在需要时候在创建，也就是惰性加载。

当一开始判断Cell数组是null并且并发线程比较少时，所有的累加操作都是对base变量进行的。保持Cell数组的大小是2的N次方，在初始化时Cell数组中的Cell元素个数为2，数组的下标使用每个线程的hashcode值的掩码表示，数组里面的变量实体是Cell类型，Cell类型是AtomicLong的一个改进，用来减少缓存的争用，也就是解决伪共享问题。

对于大多数原子操作字节填充是浪费的，因为原子性操作都是无规律的分散在内存中进行的（多个原子性变量的内存地址是不连续的），多个原子变量被放入到同一个缓存行的可能性很小。但是原子性数组元素的内存地址是连续的，所以数组内的多个元素能经常共享缓存行，因此这里使用`@sun.misc.Contended`注解对Cell类进行字节填充，这防止了数组中多个元素共享同一个缓存行，在性能上是一个提升。

自旋锁cellsBusy用来初始化和扩容数组表使用，这里没有必要用阻塞锁，当一次线程发现当前下标的元素获取锁失败后，会尝试获取其他下表的元素的锁。

### LongAdder源码分析

### LongAccumulator类原理探究

### 参考文档

