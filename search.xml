<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot（十五）：NoSql数据库mongodb]]></title>
    <url>%2F2018%2F09%2F02%2FSpringBoot%2Fmongodb%2F</url>
    <content type="text"><![CDATA[介绍]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（十四）：NoSql数据库redis]]></title>
    <url>%2F2018%2F09%2F02%2FSpringBoot%2Fredis%2F</url>
    <content type="text"><![CDATA[介绍]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（十三）：事务处理]]></title>
    <url>%2F2018%2F09%2F02%2FSpringBoot%2Ftransactional%2F</url>
    <content type="text"><![CDATA[介绍关系型数据库实物处理通过注解@Transactional来实现。 事务的四个特性 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成， 要么完全不起作用。 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状 态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来， 防止数据损坏。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从 任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 传播行为当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运 行，也可能开启一个新事务，并在自己的事务中运行。 Spring 定义了七种传播行为： PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运 行。否则，会启动一个新的事务， Spring 默认使用 PROPAGATION_SUPPORTS 表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会 在这个事务中运行 PROPAGATION_MANDATORY表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常 PROPAGATION_REQUIRED_NEW 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果 存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用 JTATransactionManager 的话，则需要 访问 TransactionManager PROPAGATION_NOT_SUPPORTED 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期 间，当前事务将被挂起。如果使用 JTATransactionManager 的话，则需要访问 TransactionManager PROPAGATION_NEVER 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛 出异常 PROPAGATION_NESTED 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务 可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与 PROPAGATION_REQUIRED一样 隔离级别隔离级别定义了一个事务可能受其他并发事务影响的程度。 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别， Spring 默认使用， mysql 默认的隔离级别为： Repeatable Read(可重复读)，mysql 为例， 存储引擎不能使用 MyISAM，应该使用 InnoDB ISOLATION_READ_UNCOMMITTED 读未提交， 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致 脏读、幻读或不可重复读 ISOLATION_READ_COMMITTED 读已提交， 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读 或不可重复读仍有可能发生 ISOLATION_REPEATABLE_READ 可重复读， 对同一字段的多次读取结果都是一致的，除非数据是被本身事 务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生 ISOLATION_SERIALIZABLE 可串行化， 最高的隔离级别，完全服从 ACID 的隔离级别，确保阻止脏读、不可 重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的 脏读（Dirty reads） ——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写再 稍后被回滚了，那么第一个事务获取的数据就是无效的。 不可重复读（Nonrepeatable read） ——不可重复读发生在一个事务执行相同的查询两次或两次以上，但 是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。 幻读（Phantom read） ——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一 个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在 的记录 属性说明@Transactional isolation：用于指定事务的隔离级别。默认为底层事务的隔离级别。 noRollbackFor：指定遇到指定异常时强制不回滚事务。 noRollbackForClassName：指定遇到指定多个异常时强制不回滚事务。该属性可以指定多个异常类 名。 propagation:指定事务的传播属性。 readOnly：指定事务是否只读。 表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优 化事务。若真的是一个只读取的数据库应设置 readOnly=true rollbackFor：指定遇到指定异常时强制回滚事务。 rollbackForClassName：指定遇到指定多个异常时强制回滚事务。该属性可以指定多个异常类名。 timeout：指定事务的超时时长。 示例事务类： 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class UserService &#123; @Autowired private SbUserDao sbUserDao; @Autowired private JpaUserDao jpaUserDao; /** * 用户注册 */ @Transactional public String register(String name, String ip) &#123; // 1.添加用户 SbUser sbUser = new SbUser(); sbUser.setName(name); sbUser.setCreateTime(new Date()); sbUserDao.insert(sbUser); // 测试使用 boolean flag = true; if (flag) &#123; throw new RuntimeException(); &#125; // 2.添加注册日志 JpaUser jpaUser = new JpaUser(); jpaUser.setUserName(name); jpaUser.setUserIp(ip); jpaUser.setCreateTime(new Date()); jpaUserDao.save(jpaUser); return "success"; &#125;&#125; 测试类： 1234567@Autowiredprivate UserService userService;@Testpublic void register() &#123; String result = userService.register("dodd3", "192.168.1.1"); System.out.println(result);&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（十二）：关系型数据库之spring-data-jpa]]></title>
    <url>%2F2018%2F09%2F02%2FSpringBoot%2Fjpa%2F</url>
    <content type="text"><![CDATA[介绍pom引入： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; JPA配置： 1234# JPA自动更新检查，没有表则会新增spring.jpa.hibernate.ddl-auto= update# 显示sql语句spring.jpa.show-sql=true 默认方法实体类： 12345678910111213@Entitypublic class JpaUser &#123; @Id @GeneratedValue private Integer id; @Column private Date createTime; @Column private String userName; @Column private String userIp; // 省略setter/getter&#125; 接口： 123public interface JpaUserDao extends JpaRepository&lt;JpaUser, Integer&gt; &#123; // 先不用自定义，JpaRepository有很多默认方法使用&#125; 测试类： 1234567891011121314151617181920212223242526272829@Autowired private JpaUserDao jpaUserDao; @Test public void insert() &#123; JpaUser entity = new JpaUser(); entity.setUserName("dodd"); entity.setUserIp("192.168.0.1"); entity.setCreateTime(new Date()); jpaUserDao.save(entity); &#125; @Test public void delete() &#123; jpaUserDao.delete(1); &#125; @Test public void update() &#123; JpaUser entity = new JpaUser(); entity.setId(2); entity.setUserName("dodd 2"); entity.setUserIp("192.168.0.1"); entity.setCreateTime(new Date()); jpaUserDao.save(entity); &#125; @Test public void select() &#123; JpaUser result = jpaUserDao.findOne(2); System.out.println(result); &#125; 自定义方法 使用内置的关键词查询 https://docs.spring.io/spring-data/jpa/docs/1.10.2.RELEASE/reference/html/ 使用自定义语句查询 https://docs.spring.io/spring-data/jpa/docs/1.10.2.RELEASE/reference/html/ @Query 注解 例：@Query(value = &quot;select u from JpaUser u where u.userName=?1&quot;) 接口： 12345678910111213141516171819202122232425262728public interface JpaUserDao extends JpaRepository&lt;JpaUser, Integer&gt; &#123; /** * 内置关键字匹配 * 通过实体类属性名称匹配 */ List&lt;JpaUser&gt; findByUserName(String userName); /** * 自定义扩展方法 * 通过实体类属性名称匹配 * 多个属性使用And连接 */ List&lt;JpaUser&gt; findByUserNameAndUserIp(String string, String string2); /** * 自定义扩展方法 * 不匹配时使用@Query * 注解的优先级高 */ @Query(value = "select u from JpaUser u where u.userName=?1") List&lt;JpaUser&gt; findByName(String userName); /** * 分页 */ Page&lt;JpaUser&gt; findByUserName(String userName, Pageable pageable);&#125; 测试类： 12345678910111213141516171819202122232425@Testpublic void select1() &#123; List&lt;JpaUser&gt; result = jpaUserDao.findByUserName("dodd 2"); System.out.println(result);&#125;@Testpublic void select2() &#123; List&lt;JpaUser&gt; result = jpaUserDao.findByName("dodd 2"); System.out.println(result);&#125;@Testpublic void select3() &#123; List&lt;JpaUser&gt; result = jpaUserDao.findByUserNameAndUserIp("dodd 2", "192.168.0.1"); System.out.println(result);&#125;// 分页@Testpublic void queryForPage() &#123; Pageable pageable = new PageRequest(0, 20, new Sort(new Sort.Order(Sort.Direction.DESC, "id"))); Page&lt;JpaUser&gt; result = jpaUserDao.findByUserName("dodd 2", pageable); System.out.println(result.getContent());&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（十一）：关系型数据库之jdbcTemplate]]></title>
    <url>%2F2018%2F09%2F02%2FSpringBoot%2FjdbcTemplate%2F</url>
    <content type="text"><![CDATA[介绍pom文件引入： 12345678910&lt;!-- jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 可以不指定 driver-class-name， spring boot 会自动识别 url 数据连接池默认使用 tomcat-jdbc 连接池的配置： spring.datasource.tomcat.* 实体类： 123456public class SbUser &#123; private int id; private String name; private Date createTime; // 省略getter/setter&#125; 接口： 1234567891011public interface SbUserDao &#123; int insert(SbUser sbUser); int deleteById(int id); int updateById(SbUser sbUser); SbUser selectById(int id); Page&lt;SbUser&gt; queryForPage(int pageCurrent, int pageSize, String name);&#125; 实现类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Autowired private JdbcTemplate jdbcTemplate; @Override public int insert(SbUser sbUser) &#123; String sql = "insert into sb_user (name, create_time) values (?, ?)"; return jdbcTemplate.update(sql, sbUser.getName(), sbUser.getCreateTime()); &#125; @Override public int deleteById(int id) &#123; String sql = "delete from sb_user where id=?"; return jdbcTemplate.update(sql, id); &#125; @Override public int updateById(SbUser sbUser) &#123; String sql = "update sb_user set name=?, create_time=? where id=?"; return jdbcTemplate.update(sql, sbUser.getName(), sbUser.getCreateTime(), sbUser.getId()); &#125; @Override public SbUser selectById(int id) &#123; String sql = "select * from sb_user where id=?"; return jdbcTemplate.queryForObject(sql, new RowMapper&lt;SbUser&gt;() &#123; @Override public SbUser mapRow(ResultSet rs, int rowNum) throws SQLException &#123; SbUser sbUser = new SbUser(); sbUser.setId(rs.getInt("id")); sbUser.setName(rs.getString("name")); sbUser.setCreateTime(rs.getDate("create_time")); return sbUser; &#125; &#125;, id); &#125; @Override public Page&lt;SbUser&gt; queryForPage(int pageCurrent, int pageSize, String name) &#123; // 若要like查询，如下 StringBuffer sql = new StringBuffer("select * from sb_user where 1"); if(name != null)&#123; // Sql.checkSql 的作用是防止sql注入 sql.append(" and name like '%").append(Sql.checkSql(name)).append("%' "); &#125; return queryForPage(sql.toString(), pageCurrent, pageSize, SbUser.class); &#125; 分页： 123456789101112131415161718/** * 分页， jdbcTemplate 不支持 like 是定义，只能拼装 */public &lt;T&gt; Page&lt;T&gt; queryForPage(String sql, int pageCurrent, int pageSize, Class&lt;T&gt; clazz, Object... args) &#123; Assert.hasText(sql, "sql 语句不能为空"); Assert.isTrue(pageCurrent &gt;= 1, "pageNo 必须大于等于 1"); Assert.isTrue(clazz != null, "clazz 不能为空"); String sqlCount = Sql.countSql(sql); int count = jdbcTemplate.queryForObject(sqlCount, Integer.class, args); pageCurrent = Sql.checkPageCurrent(count, pageSize, pageCurrent); pageSize = Sql.checkPageSize(pageSize); int totalPage = Sql.countTotalPage(count, pageSize); String sqlList = sql + Sql.limitSql(count, pageCurrent, pageSize); List&lt;T&gt; list = jdbcTemplate.query(sqlList, new BeanPropertyRowMapper&lt;T&gt;(clazz), args); return new Page&lt;T&gt;(count, totalPage, pageCurrent, pageSize, list);&#125; 分页工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Page&lt;T&gt; &#123; private static final long serialVersionUID = -5764853545343945831L; /** * 默认每页记录数(20) */ public static final int DEFAULT_PAGE_SIZE = 20; /** * 最大每页记录数(1000) */ public static final int MAX_PAGE_SIZE = 1000; /** * 当前分页的数据集 */ private List list; /** * 总记录数 */ private int totalCount; /** * 总页数 */ private int totalPage; /** * 当前页 */ private int pageCurrent; /** * 每页记录数 */ private int pageSize; /** * 排序字段 */ private String orderField; /** * 排序方式：asc or desc */ private String orderDirection; /** * 构造函数 * * @param totalCount * 总记录数 * @param totalPage * 总页数 * @param pageCurrent * @param pageSize * @param list */ public Page(int totalCount, int totalPage, int pageCurrent, int pageSize, List&lt;T&gt; list) &#123; this.totalCount = totalCount; this.totalPage = totalPage; this.pageCurrent = pageCurrent; this.pageSize = pageSize; this.list = list; &#125; // 省略getter/setter&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public class Sql &#123; private Sql() &#123; &#125; /** * 检测sql，防止sql注入 * @param sql * @return 正常返回sql；异常返回"" */ public static String checkSql(String sql) &#123; String inj_str = "'|and|exec|insert|select|delete|update|count|*|%|chr|mid|master|truncate|char|declare|;|or|-|+|,"; String inj_stra[] = inj_str.split("\\|"); for (int i = 0; i &lt; inj_stra.length; i++) &#123; if (sql.indexOf(inj_stra[i]) &gt;= 0) &#123; return ""; &#125; &#125; return sql; &#125; /** * 计算总页数 * @param totalCount 总记录数. * @param pageSize 每页记录数. * @return totalPage 总页数. */ public static int countTotalPage(final int totalCount, final int pageSize) &#123; if (totalCount % pageSize == 0) &#123; return totalCount / pageSize; // 刚好整除 &#125; else &#123; return totalCount / pageSize + 1; // 不能整除则总页数为：商 + 1 &#125; &#125; /** * 校验当前页数pageCurrent&lt;br/&gt; * 1、先根据总记录数totalCount和每页记录数pageSize，计算出总页数totalPage&lt;br/&gt; * 2、判断页面提交过来的当前页数pageCurrent是否大于总页数totalPage，大于则返回totalPage&lt;br/&gt; * 3、判断pageCurrent是否小于1，小于则返回1&lt;br/&gt; * 4、其它则直接返回pageCurrent * * @param totalCount 要分页的总记录数 * @param pageSize 每页记录数大小 * @param pageCurrent 输入的当前页数 * @return pageCurrent */ public static int checkPageCurrent(int totalCount, int pageSize, int pageCurrent) &#123; int totalPage = countTotalPage(totalCount, pageSize); // 最大页数 if (pageCurrent &gt; totalPage) &#123; // 如果页面提交过来的页数大于总页数，则将当前页设为总页数 // 此时要求totalPage要大于获等于1 if (totalPage &lt; 1) &#123; return 1; &#125; return totalPage; &#125; else if (pageCurrent &lt; 1) &#123; return 1; // 当前页不能小于1（避免页面输入不正确值） &#125; else &#123; return pageCurrent; &#125; &#125; /** * 校验页面输入的每页记录数pageSize是否合法&lt;br/&gt; * 1、当页面输入的每页记录数pageSize大于允许的最大每页记录数MAX_PAGE_SIZE时，返回MAX_PAGE_SIZE * 2、如果pageSize小于1，则返回默认的每页记录数DEFAULT_PAGE_SIZE * @param pageSize 页面输入的每页记录数 * @return checkPageSize */ public static int checkPageSize(int pageSize) &#123; if (pageSize &gt; Page.MAX_PAGE_SIZE) &#123; return Page.MAX_PAGE_SIZE; &#125; else if (pageSize &lt; 1) &#123; return Page.DEFAULT_PAGE_SIZE; &#125; else &#123; return pageSize; &#125; &#125; /** * 计算当前分页的开始记录的索引 * @param pageCurrent 当前第几页 * @param pageSize 每页记录数 * @return 当前页开始记录号 */ public static int countOffset(final int pageCurrent, final int pageSize) &#123; return (pageCurrent - 1) * pageSize; &#125; /** * 根据总记录数，对页面传来的分页参数进行校验，并返分页的SQL语句 * @param pageCurrent 当前页 * @param pageSize 每页记录数 * @param totalCount DWZ分页查询参数 * @return limitSql */ public static String limitSql(int totalCount, int pageCurrent, int pageSize) &#123; // 校验当前页数 pageCurrent = checkPageCurrent(totalCount, pageSize, pageCurrent); pageSize = checkPageSize(pageSize); // 校验每页记录数 return " limit " + countOffset(pageCurrent, pageSize) + "," + pageSize; &#125; /** * 根据分页查询的SQL语句，获取统计总记录数的语句 * @param sql 分页查询的SQL * @return countSql */ public static String countSql(String sql) &#123; // 去除第一个from前的内容 String countSql = sql.substring(sql.toLowerCase().indexOf("from")); return "select count(*) " + removeOrderBy(countSql); &#125; /** * 移除SQL语句中的的order by子句（用于分页前获取总记录数，不需要排序） * @param sql 原始SQL * @return 去除order by子句后的内容 */ private static String removeOrderBy(String sql) &#123; Pattern pat = Pattern.compile("order\\s*by[\\w|\\W|\\s|\\S]*", Pattern.CASE_INSENSITIVE); Matcher mc = pat.matcher(sql); StringBuffer strBuf = new StringBuffer(); while (mc.find()) &#123; mc.appendReplacement(strBuf, ""); &#125; mc.appendTail(strBuf); return strBuf.toString(); &#125;&#125; 测试类： 123456789101112131415161718192021222324252627282930313233343536@Autowiredprivate SbUserDao sbUserDao;@Testpublic void insert() &#123; SbUser sbUser = new SbUser(); sbUser.setName("测试"); sbUser.setCreateTime(new Date()); int result = sbUserDao.insert(sbUser); System.out.println(result);&#125;@Testpublic void delete() &#123; int result = sbUserDao.deleteById(1); System.out.println(result);&#125;@Testpublic void update() &#123; SbUser sbUser = new SbUser(); sbUser.setId(2); sbUser.setName("测试 2"); sbUser.setCreateTime(new Date()); int result = sbUserDao.updateById(sbUser); System.out.println(result);&#125;@Testpublic void select() &#123; SbUser result = sbUserDao.selectById(2); System.out.println(result);&#125;// 分页测试@Testpublic void queryForPage()&#123; Page&lt;SbUser&gt; result = sbUserDao.queryForPage(1, 20, "测试"); System.out.println(result.getList());&#125; ###]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（十）：文件上传]]></title>
    <url>%2F2018%2F09%2F01%2FSpringBoot%2Fupload%2F</url>
    <content type="text"><![CDATA[介绍]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（九）：CORS支持]]></title>
    <url>%2F2018%2F08%2F31%2FSpringBoot%2Fcros%2F</url>
    <content type="text"><![CDATA[介绍Web 开发经常会遇到跨域问题，解决方案有： jsonp， iframe，CORS 等。 CORS 与 JSONP 相比 ： JSONP 只能实现 GET 请求，而 CORS 支持所有类型的 HTTP 请求。 使用 CORS，开发者可以使用普通的 XMLHttpRequest 发起请求和获得数据，比起 JSONP 有更好的 错误处理。 JSONP 主要被老的浏览器支持，它们往往不支持 CORS，而绝大多数现代浏览器都已经支持了 CORS 。 CORS 的实现可以通过全局配置或是全局设置。 全局配置12 全局设置12 测试方法12]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（八）：Servlets、Filters、listeners]]></title>
    <url>%2F2018%2F08%2F31%2FSpringBoot%2Fservletfliterlistener%2F</url>
    <content type="text"><![CDATA[介绍Web 开发使用 Controller 基本上可以完成大部分需求， 但是我们还可能会用到 Servlet、 Filter、 Listener 等，并且在 spring boot 中的三种实现方式 。 方法一：注册Bean自定义 servlet 123456789101112131415public class CustomServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("servlet get method"); doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("servlet post method"); response.getWriter().write("hello world"); &#125;&#125; 自定义 filter 123456789101112131415public class CustomFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("init filter"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)throws IOException, ServletException &#123; System.out.println("do filter"); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println("destroy filter"); &#125;&#125; 自定义 listener 1234567891011public class CustomListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println("contextInitialized"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println("contextDestroyed"); &#125;&#125; 注册 bean 1234567891011121314151617181920212223@SpringBootApplicationpublic class SpringbootApplication &#123; private static Logger logger = LoggerFactory.getLogger(SpringbootApplication.class); @Bean public ServletRegistrationBean servletRegistrationBean() &#123; return new ServletRegistrationBean(new CustomServlet(), "/dodd"); &#125; @Bean public FilterRegistrationBean filterRegistrationBean() &#123; // servletRegistrationBean 配置的拦截的路径 return new FilterRegistrationBean(new CustomFilter(), servletRegistrationBean()); &#125; @Bean public ServletListenerRegistrationBean&lt;CustomListener&gt; servletListenerRegistrationBean() &#123; return new ServletListenerRegistrationBean&lt;CustomListener&gt;(new CustomListener()); &#125; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); logger.info("SpringbootApplication start successed&gt;&gt;&gt;"); &#125;&#125; 方法二：通过实现 ServletContextInitializer 接口直接注册1234567891011121314151617@SpringBootApplicationpublic class SpringbootApplication implements ServletContextInitializer &#123; private static Logger logger = LoggerFactory.getLogger(SpringbootApplication.class); @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; servletContext.addServlet("customServlet", new CustomServlet()).addMapping("/dodd"); servletContext.addFilter("customFilter", new CustomFilter()) .addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST), true, "customServlet"); servletContext.addListener(new CustomListener()); &#125; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); logger.info("SpringbootApplication start successed&gt;&gt;&gt;"); &#125;&#125; 方法三：注解方式在 SpringBootApplication 上使用@ServletComponentScan注解后，直接通过@WebServlet、 @WebFilter、 @WebListener注解自动注册 @ServletComponentScan 12345678910@ServletComponentScan@SpringBootApplicationpublic class SpringbootApplication &#123; private static Logger logger = LoggerFactory.getLogger(SpringbootApplication.class); public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); logger.info("SpringbootApplication start successed&gt;&gt;&gt;"); &#125;&#125; @WebServlet 123456789101112131415161718@WebServlet(name = "customServlet", urlPatterns = "/dodd")public class CustomServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("servlet get method"); doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("servlet post method"); response.getWriter().write("hello world"); &#125;&#125; @WebFilter 12345678910111213141516171819@WebFilter(filterName = "customFilter", urlPatterns = "/*")public class CustomFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("init filter"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("do filter"); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println("destroy filter"); &#125;&#125; @WebListener 123456789101112@WebListenerpublic class CustomListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println("contextInitialized"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println("contextDestroyed"); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（七）：web开发之模板引擎]]></title>
    <url>%2F2018%2F08%2F30%2FSpringBoot%2Fspringboot-web%2F</url>
    <content type="text"><![CDATA[介绍目前开发大都前后端分离，这里学习模板引擎只做了解。模板引擎的选择可以有：FreeMarker、Thymeleaf、Groovy、Mustache等。增加的css、js、等文件的目录结构： FreeMarker pom引用 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; FreeMarkerController 123456789@Controller@RequestMapping(value = "/web")public class FreeMarkerController &#123; @RequestMapping(value = "index") public String index(ModelMap map) &#123;//ModelMap选择可以有很多种，不做了解 map.put("title", "freemarker hello world"); return "index"; // 开头不要加上/，linux下面会出错 &#125;&#125; index.ftl 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;title&gt;Spring Boot Demo - FreeMarker&lt;/title&gt; &lt;link href="/css/index.css" rel="stylesheet" /&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;img src="/images/lele.jpg" /&gt; &lt;h1 id="title"&gt;$&#123;title&#125;&lt;/h1&gt; &lt;/center&gt; &lt;script type="text/javascript" src="/webjars/jquery/2.1.4/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(function()&#123; $('#title').click(function()&#123; alert('点击了'); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; thymeleaf pom引用 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;title&gt;Spring Boot Demo - thymeleaf&lt;/title&gt; &lt;link href="/css/index.css" rel="stylesheet" /&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;img src="/images/lele.jpg" /&gt; &lt;h1 id="title" th:text="$&#123;title&#125;"&gt;&lt;/h1&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; jspspringboot不建议使用： jsp只能打包为：war格式，不支持jar格式，只能在标准的容器里面跑（tomcat，jetty都可以） 内嵌的Jetty目前不支持JSPs Undertow不支持jsps jsp自定义错误页面不能覆盖spring boot 默认的错误页面 pom引用 123456789&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt; application.properties 12spring.mvc.view.prefix: /WEB-INF/templates/spring.mvc.view.suffix: .jsp index.jsp 123456789101112131415161718&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;title&gt;Spring Boot Demo - FreeMarker&lt;/title&gt; &lt;link href="/static/css/index.css" rel="stylesheet" /&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="/static/images/lele.jpg" alt="logo"/&gt; &lt;h1 id="title"&gt;$&#123;title&#125;&lt;/h1&gt; &lt;c:url value="http://www.baidu.com" var="url"/&gt; &lt;spring:url value="http://www.baidu.com" htmlEscape="true" var="springUrl"/&gt; Spring URL: $&#123;springUrl&#125; &lt;br&gt; JSTL URL: $&#123;url&#125; &lt;/body&gt;&lt;/html&gt; ServletInitializer.java 123456789101112import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.support.SpringBootServletInitializer;/** * 在Servlet容器中部署WAR的时候，不能依赖于Application的main函数而是要以类似于web.xml文件配置的方式来启动Spring应用上下文&lt;br/&gt; * 所以此时需要声明这样一个类或者将应用的主类改为继承SpringBootServletInitializer也可以 */public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(SpringBootDemo81Application.class); &#125;&#125; 错误处理增加错误处理页面 ErrorController BaseErrorController 1234567891011121314@Controller@RequestMapping(value = "error")public class BaseErrorController implements ErrorController &#123; private static final Logger logger = LoggerFactory.getLogger(BaseErrorController.class); @Override public String getErrorPath() &#123; logger.info("出错啦！进入自定义错误控制器"); return "error/error"; &#125; @RequestMapping public String error() &#123; return getErrorPath(); &#125;&#125; error.ftl 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;title&gt;Spring Boot Demo - error&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;error-系统出错，请联系后台管理员&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 自定义错误页面 html静态页面：在resources/public/error/ 下定义，如添加404页面： resources/public/error/404.html页面，中文注意页面编码 模板引擎页面：在templates/error/下定义，如添加5xx页面： templates/error/5xx.ftl 注：templates/error/ 这个的优先级比较 resources/public/error/高 WebController 123456789@Controller@RequestMapping(value = "/web")public class WebController &#123; private org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(WebController.class); @RequestMapping(value = "error") public String error(ModelMap map) &#123; throw new RuntimeException("测试异常"); &#125;&#125; @ControllerAdvice WebController同上 BizException 1234567891011121314151617181920212223242526272829@ControllerAdvicepublic class BizException &#123; private static final Logger logger = LoggerFactory.getLogger(BizException.class); /** * 统一异常处理 */ @ExceptionHandler(&#123; RuntimeException.class &#125;) @ResponseStatus(HttpStatus.OK) public ModelAndView processException(RuntimeException exception) &#123; logger.info("自定义异常处理-RuntimeException"); ModelAndView m = new ModelAndView(); m.addObject("demoException", exception.getMessage()); m.setViewName("error/500"); return m; &#125; /** * 统一异常处理 */ @ExceptionHandler(&#123; Exception.class &#125;) @ResponseStatus(HttpStatus.OK) public ModelAndView processException(Exception exception) &#123; logger.info("自定义异常处理-Exception"); ModelAndView m = new ModelAndView(); m.addObject("demoException", exception.getMessage()); m.setViewName("error/500"); return m; &#125;&#125; 500.ftl 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;title&gt;Spring Boot Demo - exception&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;500-系统错误&lt;/h1&gt;&lt;h1&gt;$&#123;demoException&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（六）：多环境配置]]></title>
    <url>%2F2018%2F08%2F30%2FSpringBoot%2Fenvironment%2F</url>
    <content type="text"><![CDATA[介绍在开发应用时，常用部署的应用是多个的，比如：开发、测试、联调、生产等不同的应用环境，这些应用环境都对应不同的配置项，比如swagger一般上在生产时是关闭的；不同环境数据库地址、端口号等都是不尽相同的，要是没有多环境的自由切换，部署起来是很繁琐也容易出错的。 maven多环境配置maven配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;pom.port&gt;8080&lt;/pom.port&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;pom.port&gt;8888&lt;/pom.port&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;!-- 加入此属性，才会进行过滤 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;!-- 需要加入，因为maven默认的是$&#123;&#125;,而springbooot 默认会把此替换成@&#123;&#125; --&gt; &lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 然后编译时，加入-Ptest，则会替换test环境下的参数值。 完整参数： 1mvn clean install -DskipTests -Ptest application.properties： 1server.port=$&#123;pom.port&#125; 利用maven实现多环境配置，比较麻烦的就是每次部署新环境时，都需要再次指定环境编译打包一次。 springboot多环境配置Profile是Spring针对不同环境不同配置的支持。需要满足application-{profile}.properties，{profile}对应你的环境标识。如： application-dev.properties：开发环境 application-test.properties：测试环境 而指定执行哪份配置文件，只需要在application.properties配置spring.profiles.active为对应${profile}的值。 12# 指定环境为devspring.profiles.active=dev 还可以在命令行方式激活不同环境配置，如： 1java -jar xxx.jar --spring.profiles.active=test 在不同环境下，可能加载不同的bean时，可利用@Profile注解来动态激活： 12345678910@Profile("dev")//支持数组:@Profile(&#123;"dev","test"&#125;)@Configuration@Slf4jpublic class ProfileBean &#123; @PostConstruct public void init() &#123; log.info("dev环境下激活"); &#125; &#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（五）：常用注解介绍]]></title>
    <url>%2F2018%2F08%2F29%2FSpringBoot%2Fproperty%2F</url>
    <content type="text"><![CDATA[介绍SpringBoot本身是基于Spring和SpringMvc等各类spring家族的一个解决方案，可快速进行集合。故相关知识点其实大部分都是基于spring或者springmvc既有的知识点的。这里主要讲解的是关于web开发及springboot独有的一些常用注解进行说明。 常见注解1. @SpringBootApplication此注解是个组合注解，包括了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan注解： @SpringBootConfiguration 继承至@Configuration，此标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名 @EnableAutoConfiguration这个注解就是springboot能自动进行配置的魔法所在了。主要是通过此注解，能所有符合自动配置条件的bean的定义加载到spring容器中，比如根据spring-boot-starter-web ，来判断你的项目是否需要添加了webmvc和tomcat，就会自动的帮你配置web项目中所需要的默认配置。但比如需要排除一些无需自动配置的类时，可利用exclude进行排除 @ComponentScan 会扫描当前包及其子包下被@Component，@Controller，@Service，@Repository等注解标记的类并纳入到spring容器中进行管理 2. @Controller 和 @RestController@RestController 是Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。而@Controller是用来创建处理http请求的对象，一般结合@RequestMapping使用 3. @RequestMapping一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。常用属性： value： 指定请求的实际地址，指定的地址可以是URI Template 模式； method： 指定请求的method类型， GET、POST、PUT、DELETE等； consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html； produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params： 指定request中必须包含某些参数值是，才让该方法处理； headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求； 4. @RequestBody和@ResponseBody @RequestBody注解允许request的参数在reqeust体中，常常结合前端POST请求，进行前后端交互。 @ResponseBody注解支持将的参数在reqeust体中，通常返回json格式给前端。 5. @RequestParam@RequestParam用来接收URL中的参数,如/get?name=dodd,可接收dodd作为参数: 12345678//http://localhost:8080/index/get?name=dodd@RequestMapping("/get")public Map&lt;String,String&gt; get(@RequestParam String name)&#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("name",name); map.put("value","hello world!"); return map;&#125; 6. @PathVariable@PathVariable用来接收参数，动态获取URL参数： 123456789//http://localhost:8080/index/find/1/dodd@RequestMapping("/find/&#123;id&#125;/&#123;name&#125;")public User get(@PathVariable int id, @PathVariable String name)&#123; User u = new User(); u.setId(id); u.setName(name); u.setDate(new Date()); return u;&#125; 7. @RequestAttribute@RequestAttribute用于访问由过滤器或拦截器创建的、预先存在的请求属性，效果等同与request.getAttrbute(): 1234@GetMapping("/req/attr")public String reqAttr(@RequestAttribute("id") String id)&#123; return "id:" + id;&#125; 8. @Component、@Service、@Repository这三者都是申明一个单例的bean类并纳入spring容器中，后两者其实都是继承于@Component： @Component最普通的组件，可以被注入到spring容器进行管理 @Repository作用于持久层 @Service作用于业务逻辑层 通常一些类无法确定是使用@Service还是@Component时，注解使用@Component，比如redis的配置类等 9. @ModelAttribute主要是绑定请求参数到指定对象上。此注解可被用于方法、参数上: 运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用； 运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中； 由于现在都采用前后端分离开发，故此注解相对用的较少了，但对于一些在每次请求前需要进行一些额外操作时。使用此注解依然是个选择，比如进行统一的业务校验等，但使用此注解实现类似功能时需要注意，使用异步调用时，比如callable或者DeferredResult时，被此注解的方法会执行两次，因为异步请求时，是挂起另一个线程去重新执行，对于配置了拦截器而已，它们的执行顺序为: 1preHandle---&gt;afterConcurrentHandlingStarted---&gt;Controller---&gt;preHandle---&gt;postHandler---&gt;afterCompletion 解决方案的话可简单根据DispatcherType类型进行判断，异步时对应类型为：ASYNC，第一次请求正常为：REQUEST。 10. @autowired、@resource、@Qualifier @Autowire 默认按照类型装配，默认情况下它要求依赖对象必须存在如果允许为null，可以设置它required属性为false，如果我们想使用按照名称装配，可 以结合@Qualifier注解一起使用； @Resource默认按照名称装配，当找不到与名称匹配的bean才会按照类型装配，可以通过name属性指定，如果没有指定name属 性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找 依赖对象，但一旦指定了name属性，就只能按照名称 装配了； @Qualifier 则按照名称经行来查找转配的]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（四）：启动原理]]></title>
    <url>%2F2018%2F08%2F26%2FSpringBoot%2Fstart%2F</url>
    <content type="text"><![CDATA[介绍123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 学习springboot启动原理，我们从@SpringBootApplication和SpringApplication.run开始。 @SpringBootApplication123456789101112@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;...&#125; 虽然定义使用了多个Annotation进行了原信息标注，但实际上重要的只有三个Annotation： @Configuration（@SpringBootConfiguration点开查看发现里面还是应用了@Configuration） @EnableAutoConfiguration @ComponentScan 所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等： 12345678@Configuration@EnableAutoConfiguration@ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 接下来分别介绍这3个Annotation: 1. @Configuration@Configuration就是JavaConfig形式的Spring Ioc容器的配置类使用的那个@Configuration，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。举几个简单例子回顾下，XML跟config配置方式的区别： 表达形式层面 基于XML的配置形式： 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd" default-lazy-init="true"&gt; &lt;!--bean定义--&gt;&lt;/beans&gt; 基于JavaConfig的配置形式： 1234@Configurationpublic class DoddConfiguration&#123; //bean定义&#125; 任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。 注册bean定义层面 基于XML的配置形式： 123&lt;bean id="doddService" class="..DoddServiceImpl"&gt; //...&lt;/bean&gt; 基于JavaConfig的配置形式： 1234567@Configurationpublic class DoddConfiguration&#123; @Bean public MockService mockService()&#123; return new MockServiceImpl(); &#125;&#125; 任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。 表达依赖注入关系层面 表达bean与bean之间的依赖关系，在XML中的形式： 12345&lt;bean id="doddService" class="..DoddServiceImpl"&gt; &lt;propery name ="dependencyService" ref="dependencyService" /&gt;&lt;/bean&gt;&lt;bean id="dependencyService" class="DependencyServiceImpl"&gt;&lt;/bean&gt; 基于JavaConfig的配置形式 123456789101112@Configurationpublic class DoddConfiguration&#123; @Bean public DoddService doddService()&#123; return new DoddServiceImpl(dependencyService()); &#125; @Bean public DependencyService dependencyService()&#123; return new DependencyServiceImpl(); &#125;&#125; 如果一个bean的定义依赖其他bean，则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。 2. @EnableAutoConfigurationSpring框架提供的各种名字为@Enable开头的Annotation定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport等，@EnableAutoConfiguration的理念和做事方式其实一脉相承，简单概括一下就是，借助@Import的支持，收集和注册特定场景相关的bean定义。 @EnableScheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。 @EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。 @EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器。其自身定义关键信息如下： 12345678910@SuppressWarnings("deprecation")@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; //...&#125; 其中，最关键的要属@Import借助·EnableAutoConfigurationImportSelector·，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。就像一只“八爪鱼”一样，借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！ SpringFactoriesLoader详解SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置: 12345678910public abstract class SpringFactoriesLoader &#123; //... public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123; //... &#125; public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; //.... &#125;&#125; 配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key,获取对应的一组@Configuration类 上图就是从SpringBoot的autoconfigure依赖包中的META-INF/spring.factories配置文件中摘录的一段内容，可以很好地说明问题。所以，@EnableAutoConfiguration自动配置原理：从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。 3. @ComponentScan@ComponentScan这个注解在Spring中很重要，它对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。 我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。 注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。 SpringApplication执行流程SpringApplication的run方法的主要流程如下： 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情： 根据classpath里面是否存在某个特征类org.springframework.web.context.ConfigurableWebApplicationContext来决定是否应该创建一个为Web应用使用的ApplicationContext类型 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener 推断并设置main方法的定义类 SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。 如果SpringApplication的showBanner属性被设置为true，则打印banner。 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。 ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理） 去除事件通知点后，整个流程如下： 总结SpringBoot的核心组件完成了基本的解析，综合来看，大部分都是Spring框架背后的一些概念和实践方式，SpringBoot只是在这些概念和实践上对特定的场景事先进行了固化和升华。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（三）：日志配置详解]]></title>
    <url>%2F2018%2F08%2F25%2FSpringBoot%2Flogback%2F</url>
    <content type="text"><![CDATA[介绍Spring Boot在所有内部日志中使用Commons Logging，但是默认配置也提供了对常用日志的支持，如：Java Util Logging，Log4J, Log4J2和Logback。每种Logger都可以通过配置使用控制台或者文件输出日志内容。 日志格式如下： 从上图可以看到，日志输出内容元素具体如下： 时间日期 — 精确到毫秒 日志级别 — ERROR, WARN, INFO, DEBUG or TRACE 进程ID 分隔符 — --- 标识实际日志的开始 线程名 — 方括号括起来（可能会截断控制台输出） Logger名 — 通常使用源代码的类名 日志内容 日志系统分类 SLF4J:Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的，它提供了各类日志框架的binding。 Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。 默认情况下，spring boot默认会加载classpath:logback-spring.xml或者classpath:logback-spring.groovy，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。 默认配置logback 添加日志依赖 spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback，所以我们不需要直接添加该依赖 。 控制台输出 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL ，Spring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台。 以下两种方式开启调试模式： 在运行命令后加入--debug标志，如：$ java -jar springTest.jar --debug。 在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。 文件输出 如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性： logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log 如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。 如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log ，二者不能同时使用，如若同时使用，则只有logging.file生效 级别控制 所有支持的日志记录系统都可以在Spring环境中设置记录级别（例如在application.properties中） 格式为：logging.level.* = LEVEL： logging.level：日志级别控制前缀，*为包名或Logger名 LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF 自定义日志配置根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载： Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy Log4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml Log4j2：log4j2-spring.xml, log4j2.xml JDK (Java Util Logging)：logging.properties Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项。上面是默认的命名规则，并且放在src/main/resources下面即可。自定义日志文件名，可以在application.properties配置文件里面通过logging.config属性指定自定义的名字： 1logging.config=classpath:logging-config.xml ####logback-spring.xml 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;include resource="org/springframework/boot/logging/logback/base.xml"/&gt; &lt;!-- 定义项目名称及日志文件的存储地址 注意: 此处需要定义项目名 --&gt; &lt;property name="APP_NAME" value="demo"/&gt; &lt;!-- 项目日志路径固定为以下路径 --&gt; &lt;property name="LOG_HOME" value="/dodd/logs"/&gt; &lt;!--输出到控制台--&gt; &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt;--&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%+22thread] %-5level %+30logger&#123;5&#125; %n--&gt; %msg%n%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志文件输出的文件名 --&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;APP_NAME&#125;/$&#123;APP_NAME&#125;.%d&#123;yyyy-MM-dd&#125;.log.zip&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数 --&gt; &lt;MaxHistory&gt;15&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%+22thread] %-5level %+30logger&#123;5&#125; %n--&gt; %msg%n%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name="SQL" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志文件输出的文件名 --&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;APP_NAME&#125;/$&#123;APP_NAME&#125;.%d&#123;yyyy-MM-dd&#125;.sql.zip&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数 --&gt; &lt;MaxHistory&gt;15&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%+22thread] %-5level %+30logger&#123;5&#125; %n--&gt; %msg%n%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--项目代码打印INFO级别日志 注意: 此处需要自定义包名--&gt; &lt;logger name="com.dodd.demo" additivity="false"&gt; &lt;level value="INFO"/&gt; &lt;appender-ref ref="FILE"/&gt; &lt;appender-ref ref="SQL"/&gt; &lt;appender-ref ref="CONSOLE"/&gt; &lt;/logger&gt; &lt;!--其它代码打印WARN级别日志--&gt; &lt;root level="WARN"&gt; &lt;appender-ref ref="FILE"/&gt; &lt;appender-ref ref="CONSOLE"/&gt; &lt;/root&gt;&lt;/configuration&gt; 根节点configuration scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟 debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false 属性一：设置上下文名称&lt;contextName&gt; 每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改,可以通过%contextName来打印日志上下文名称 属性二：设置变量&lt;property&gt; 用来定义变量值的标签， 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量 子节点一：appenderappender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。 &lt;encoder&gt;表示对日志进行编码： %d{HH: mm:ss.SSS}——日志输出时间 %thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用 %-5level——日志级别，并且使用5个字符靠左对齐 %logger{36}——日志输出者的名字 %msg——日志消息 %n——平台的换行符 ThresholdFilter为系统定义的拦截器，例如我们用ThresholdFilter来过滤掉ERROR级别以下的日志不输出到文件中。如果不用记得注释掉，不然你控制台会发现没日志~ 子节点二：rootroot节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性，用来设置打印级别，大小写无关TRACE, DEBUG, INFO, WARN, ERROR, ALL 和OFF，不能设置为INHERITED或者同义词NULL。 默认是DEBUG 子节点三：logger&lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，一个可选的level和一个可选的addtivity属性: name:用来指定受此logger约束的某一个包或者具体的某一个类 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前logger将会继承上级的级别 addtivity:是否向上级logger传递打印信息。默认是true。 打印sql语句使用mybatis的时候，sql语句是debug下才会打印，所以想要查看sql语句的话，有以下两种操作： 第一种把&lt;root level=&quot;info&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql 第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别： 123&lt;logger name="com.dodd.dao" level="DEBUG" additivity="false"&gt; &lt;appender-ref ref="console" /&gt;&lt;/logger&gt; 多环境日志输出logback-spring.xml（想使用spring扩展profile支持，要以logback-spring.xml命名 ），方法如下： 12345678&lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;&lt;springProfile name="test,dev"&gt; &lt;logger name="com.dodd.controller" level="info" /&gt;&lt;/springProfile&gt;&lt;!-- 生产环境. --&gt;&lt;springProfile name="prod"&gt; &lt;logger name="com.dodd.controller" level="ERROR" /&gt;&lt;/springProfile&gt; 根据不同环境（prod:生产环境，test:测试环境，dev:开发环境）来定义不同的日志输出：使用方法如下： application.properties 123#配置文件环境配置spring.profiles.active = dev#配置成dev则会去找&lt;springProfile name="dev"&gt;的环境日志配置 logback多环境配置示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!-- 文件输出格式 --&gt; &lt;property name="PATTERN" value="%-12(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;) |-%-5level [%thread] %c [%L] -| %msg%n" /&gt; &lt;!-- test文件路径 --&gt; &lt;property name="TEST_FILE_PATH" value="d:/dodd/springboot/test/logs" /&gt; &lt;!-- pro文件路径 --&gt; &lt;property name="PRO_FILE_PATH" value="/dodd/springboot/pro/logs" /&gt; &lt;!-- 开发环境 --&gt; &lt;springProfile name="dev"&gt; &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name="springbootdemo.springboot" level="debug"/&gt; &lt;root level="info"&gt; &lt;appender-ref ref="CONSOLE" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!-- 测试环境 --&gt; &lt;springProfile name="test"&gt; &lt;!-- 每天产生一个文件 --&gt; &lt;appender name="TEST-FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 文件路径 --&gt; &lt;file&gt;$&#123;TEST_FILE_PATH&#125;&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 文件名称 --&gt; &lt;fileNamePattern&gt;$&#123;TEST_FILE_PATH&#125;/info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 文件最大保存历史数量 --&gt; &lt;MaxHistory&gt;100&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;$&#123;PATTERN&#125;&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="TEST-FILE" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!-- 生产环境 --&gt; &lt;springProfile name="prod"&gt; &lt;appender name="PROD_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;PRO_FILE_PATH&#125;&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;PRO_FILE_PATH&#125;/warn.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;MaxHistory&gt;100&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;$&#123;PATTERN&#125;&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root level="warn"&gt; &lt;appender-ref ref="PROD_FILE" /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; log4j2pom引用：1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 去除logback的依赖包 --&gt;&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; 在classpath添加log4j2.xml或者log4j2-spring.xml（spring boot 默认加载）。 log4j2多环境配置：可以结合多环境配置的配置文件，利用logging.config=classpath:log4j2-dev.xml，结构如下： application.properties 12#配置文件环境配置spring.profiles.active = dev application-dev.properties 1logging.config=classpath:log4j2-dev.xml log4j2-dev.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;configuration&gt; &lt;properties&gt; &lt;!-- 文件输出格式 --&gt; &lt;property name="PATTERN"&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; |-%-5level [%thread] %c [%L] -| %msg%n&lt;/property&gt; &lt;/properties&gt; &lt;appenders&gt; &lt;Console name="CONSOLE" target="system_out"&gt; &lt;PatternLayout pattern="$&#123;PATTERN&#125;" /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name="com.dodd.demo" level="debug" /&gt; &lt;root level="info"&gt; &lt;appenderref ref="CONSOLE" /&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 总结性能比较：Log4J2 和 Logback 都优于 log4j（不推荐使用） 配置方式：Logback最简洁，spring boot默认，推荐使用]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（二）：配置文件详解]]></title>
    <url>%2F2018%2F08%2F19%2FSpringBoot%2Fproperties%2F</url>
    <content type="text"><![CDATA[介绍Spring Boot使用了一个全局的配置文件application.properties，放在src/main/resources目录下或者类路径的/config下。Sping Boot的全局配置文件的作用是对一些默认配置的配置值进行修改。比如自定义应用端口号(比较在机器比较少的情况下，一台机器还是需要部署多个应用的，当然利用docker的话，是可避免的，这是后话了)、mq的服务地址、缓存服务的服务地址、数据库的配置等，都或多或少的需要一些外部的配置项等。 springboot默认的全局配置文件名为application.properties或者application.yml（spring官方推荐使用的格式是.yml格式），除此之外还有一个bootstrap的全局文件，它的加载顺序在application配置文件之前，主要是用于在应用程序上下文的引导阶段，springCloudCofnig主要是利用此特性，进行配置文件的动态修改。 自定义配置application.properties提供自定义属性的支持，这样我们就可以把一些常量配置在这里： 123server.port = 8989com.dodd.name = "dodd"com.dodd.want = "learn spring boot!" 然后直接在要使用的地方通过注解@Value(value=&quot;${config.name}&quot;)就可以绑定到你想要的属性上面： 12345678910111213@RestControllerpublic class UserController &#123; @Value("$&#123;com.dodd.name&#125;") private String name; @Value("$&#123;com.dodd.want&#125;") private String want; @RequestMapping("/") public String hexo()&#123; return name+","+want; &#125;&#125; 有时候属性太多了，一个个绑定到属性字段上太累，官方提倡绑定一个对象的bean，这里我们建一个ConfigBean.java类，顶部需要使用注解@ConfigurationProperties(prefix = &quot;com.dodd&quot;)来指明使用哪个： 12345678//前缀.属性 com.dodd是properties属性com.dodd.name的前缀@ConfigurationProperties(prefix = "com.dodd")public class ConfigBean &#123; private String name; private String want; // 省略getter和setter&#125; 这里配置完还需要在spring Boot入口类加上@EnableConfigurationProperties并指明要加载哪个bean，如果不写ConfigBean.class，在bean类那边添加：bean类这里可直接加入@Component使其在启动时被自动扫描到，或者使用@EnableConfigurationProperties注解注册此实体bean. 12345678@SpringBootApplication@EnableConfigurationProperties(&#123;ConfigBean.class&#125;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 最后在Controller中引入ConfigBean使用即可，如下： 12345678910@RestControllerpublic class UserController &#123; @Autowired ConfigBean configBean; @RequestMapping("/") public String hexo()&#123; return configBean.getName()+configBean.getWant(); &#125;&#125; 这里需要注意，由于springboot在读取properties文件时，使用的是PropertiesPropertySourceLoader类进行读取，默认读取的编码是ISO 8859-1，故在默认的配置文件中使用中文时，会出现乱码，此时可以将中文转成Unicode编码或者使用yml配置格式（默认就支持utf-8），再不济可以将作为配置写入到一个自定义配置文件，利用@PropertySource注解的encoding属性指定编码。下面是中文乱码的一种解决方法： 添加配置 1234567#设置spring-boot 编码格式banner.charset=UTF-8server.tomcat.uri-encoding=UTF-8spring.http.encoding.charset=UTF-8spring.http.encoding.enabled=truespring.http.encoding.force=truespring.messages.encoding=UTF-8 设置文件类型 将application.properites的文件类型修改为UTF-8的编码类型。 通过以上方法测试获取出来的值还是乱码。 解决方法 IDEA：依次点击 File -&gt; Settings -&gt; Editor -&gt; File Encodings 将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。 参数间调用在application.properties中的各个参数之间也可以直接引用来使用，就像下面的设置： 123com.dodd.name="dodd"com.dodd.want="learn spring boot!"com.dodd.message=$&#123;com.dodd.name&#125;want$&#123;com.dodd.want&#125; 自定义配置文件定义一个名为test.properties，路径跟也放在src/main/resources下面： 12com.dodd.name = "dodd"com.dodd.want = "learn spring boot!" 新建一个bean类，如下： 12345678@Configuration@ConfigurationProperties(prefix = "com.dodd") @PropertySource("classpath:test.properties")public class ConfigTestBean &#123; private String name; private String want; // 省略getter和setter&#125; 或者在主类手动引入： 1234567@SpringBootApplication@PropertySource(value="classpath:test.properties",encoding="utf-8")public class Chapter3Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Chapter3Application.class, args); &#125;&#125; 利用@PropertySource注解既可以引入配置文件，需要引入多个时，可使用@PropertySources设置数组，引入多个文件。 这里要注意有一个问题，如果你使用的是1.5以前的版本，那么可以通过locations指定properties文件的位置，这样： 1@ConfigurationProperties(prefix = "com.dodd",locations="classpath:test.properties") 但是1.5版本后就没有这个属性了，添加@Configuration和@PropertySource(&quot;classpath:test.properties&quot;)后才可以读取。 随机值配置配置文件中${random} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串： 1234567#随机字符串dodd.secret=$&#123;random.value&#125;dodd.number=$&#123;random.int&#125;dodd.bignumber=$&#123;random.long&#125;dodd.uuid=$&#123;random.uuid&#125;dodd.number.less.than.ten=$&#123;random.int(10)&#125;dodd.number.in.range=$&#123;random.int[1024,65536]&#125; 数组形式配置文件： 123dodd.name="dodd"dodd.hobby[0]="看电影"dodd.hobby[1]="桌游" 实体类： 123456789@Component//@EnableConfigurationProperties(value= &#123;DoddConfig.class&#125;) 注解注册此实体bean@ConfigurationProperties(prefix="dodd")@Datapublic class DoddConfig &#123; String name; List&lt;String&gt; hobby; // 省略getter和setter&#125; 测试类： 123456789101112@RestControllerpublic class DemoController &#123; @Autowired DoddConfig doddConfig; @RequestMapping("/hobby") public String hobby()&#123; return doddConfig.getName() + " 爱好是：" + doddConfig.getHobby(); &#125;&#125;// dodd 爱好是：[看电影, 桌游] 时间格式化1234# 日期格式化spring.jackson.date-format=yyyy-MM-dd HH:mm:ss# 时区spring.jackson.time-zone=Asia/Chongqing 外部配置Spring Boot是基于jar包运行的，打成jar包的程序可以直接通过下面命令运行： 1234java -jar xx.jar//可以以下命令修改tomcat端口号：java -jar xx.jar --server.port=9090//命令行中连续的两个减号--就是对application.properties中的属性值进行赋值的标识 实际上，Spring Boot应用程序有多种设置途径，Spring Boot能从多重属性源获得属性，包括如下几种： 根目录下的开发工具全局设置属性（当开发工具激活时为~/.spring-boot-devtools.properties） 测试中的@TestPropertySource注解 测试中的@SpringBootTest#properties注解特性 命令行参数 SPRING_APPLICATION_JSON中的属性（环境变量或系统属性中的内联JSON嵌入） ServletConfig初始化参数 ServletContext初始化参数 java:comp/env里的JNDI属性 JVM系统属性 操作系统环境变量 随机生成的带random.* 前缀的属性（在设置其他属性时，可以应用他们，比如${random.long}） 应用程序以外的application.properties或者appliaction.yml文件 打包在应用程序内的application.properties或者appliaction.yml文件 通过@PropertySource标注的属性源 默认属性（通过SpringApplication.setDefaultProperties指定） 这里列表按组优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性，例如我们上面提到的命令行属性就覆盖了application.properties的属性。 配置文件优先级application.properties和application.yml文件可以放在以下四个位置： 外置，在相对于应用程序运行目录的/congfig子目录里。 外置，在应用程序运行的目录里 内置，在config包内 内置，在Classpath根目录 以上按照优先级排序，也就是说，src/main/resources/config下application.properties覆盖src/main/resources下application.properties中相同的属性，如图： 此外，如果你在相同优先级位置同时有application.properties和application.yml，那么application.properties里的属性里面的属性就会覆盖application.yml。 多环境配置在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如： application-dev.properties：开发环境 application-prod.properties：生产环境 想要使用对应的环境，只需要在application.properties中使用spring.profiles.active属性来设置，值对应上面提到的{profile}，这里就是指dev、prod这2个。当然你也可以用命令行启动的时候带上参数： 1java -jar xxx.jar --spring.profiles.active=dev 除了可以用profile的配置文件来分区配置我们的环境变量，在代码里，我们还可以直接用@Profile注解来进行配置，例如数据库配置，这里我们先定义一个接口： 123public interface DBConnector &#123; void configure(); &#125; 分别定义俩个实现类来实现它： 12345678910111213141516171819202122/** * 测试数据库 */@Component@Profile("testdb")public class TestDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("testdb"); &#125;&#125;/** * 生产数据库 */@Component@Profile("devdb")public class DevDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("devdb"); &#125;&#125; 通过在配置文件激活具体使用哪个实现类： 1spring.profiles.active=testdb 然后就可以这么用了： 12345678910111213@RestController@RequestMapping("/task")public class TaskController &#123; @Autowired DBConnector connector ; @RequestMapping(value = &#123;"/",""&#125;) public String hellTask()&#123; connector.configure(); //最终打印testdb return "hello task !! myage is " + myage; &#125;&#125; 除了spring.profiles.active来激活一个或者多个profile之外，还可以用spring.profiles.include来叠加profile： 12spring.profiles.active: testdb spring.profiles.include: proddb,testdb 参考springboot常用属性汇总]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（一）：优雅的入门]]></title>
    <url>%2F2018%2F08%2F12%2FSpringBoot%2Fspringboot01%2F</url>
    <content type="text"><![CDATA[介绍从本质上来说，Spring Boot就是Spring，它做了那些没有它你也会去做的Spring Bean配置。它使用习惯优于配置（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。使用Spring Boot很容易创建一个独立运行（运行jar，内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。 Spring Boot的核心功能 独立运行的Spring项目 Spring Boot可以以jar包的形式独立运行，运行一个Spring Boot项目只需要通过java -jar xx.jar。 内置Servlet容器 Spring Boot可选择内嵌Tomcat、Jetty或者Undertow，这样无须以war包形式部署。 提供starter简化maven配置 Spring提供了一系列的starter pom来简化maven依赖加载，例如：当你使用了spring-boot-starter-web时，会自动加入相关依赖，无需你手动一个一个的添加坐标依赖。 自动配置Spring Spring Boot会根据在类路径中的jar包、类，为jar包里的类自动配置Bean，这样会极大地减少我们要使用的配置。当然，Spring Boot只是考虑了大多数的开发场景，并不是所有场景，若在实际开发中，我们需要自动配置bean，而Spring Boot没有提供支持，则可以自定义自动配置。 无代码生成和xml配置 Spring Boot的神奇的不是借助于代码生成来实现的，而是通过条件注解来实现的，这是Spring 4.x提供的新特性，Spring 4.x提倡使用java配置和注解配置相结合，而Spring Boot不需要任何xml配置即可实现Sping Boot的所有配置。 项目搭建 利用Spring Initializr进行快速创建项目 选择file–&gt;new–&gt;project，打开创建面板，这里url建议选择默认(默认是http方式) 填写项目信息 maven相关命名说明: Group：一般为逆向域名格式，如com.dodd开头。 Artifact：唯一标识，一般为项目名称。 选择依赖包和版本 springBoot版本建议选择非最新版本，太新的版本在搭建springcloud项目时可能会出现问题。 项目结构 pom依赖 由于使用了Spring Initializr直接创建项目，相关依赖自动添加好了。pom解析： Spring Boot父级依赖 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.11.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 有了这个，当前的项目就是Spring Boot项目了，spring-boot-starter-parent是一个特殊的starter,它用来提供相关的Maven默认依赖，使用它之后，常用的包依赖可以省去version标签。 如果你不想使用某个依赖默认的版本，可以通过覆盖自己的项目中的属性来覆盖各个依赖项，例如，要升级到另一个Spring Data版本系列，可以将以下内容添加到pom.xml中： 123&lt;properties&gt;&lt;!-- 原来版本是Fowler-SR1 --&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 如果你不想使用spring-boot-starter-parent，可以通过使用scope = import依赖关系来保持依赖关系管理： 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.11.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 说明：该设置不允许使用如上所述的属性(properties)覆盖各个依赖项，要实现相同的结果，需要在spring-boot-dependencies项之前的项目的dependencyManagement中添加一个配置，例如： 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.11.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 起步依赖 spring-boot-starter-xx Spring Boot提供了很多开箱即用 的依赖模块，都是以spring-boot-starter-xx作为命名的。自动给你封装好了你想要实现的功能的依赖。就比如要实现web功能，引入了spring-boot-starter-web这个起步依赖。Spring Boot通过提供众多起步依赖降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM ），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或者某类功能。 Spring Boot Maven插件 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; Spring Boot Maven插件提供了许多方便的功能： 把项目打包成一个可执行的超级JAR（uber-JAR）,包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行应用程序。 搜索public static void main()方法来标记为可运行类。 项目运行 主入口 123456789101112/** * 启动类 * @author dodd */@SpringBootApplication@MapperScan("com.dodd.demo.mapper")public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; @SpringBootApplication 是Sprnig Boot项目的核心注解，主要目的是开启自动配置。 main方法这是一个标准的Java应用的main的方法，主要作用是作为项目启动的入口。 controller Controller类主要与前台交互，返回json数据 12345678910111213141516@RestControllerpublic class DemoController &#123; private Logger logger = LoggerFactory.getLogger(DemoController.class); @Autowired private DemoService demoService; @RequestMapping("/hello") public DemoResponse hello() &#123; logger.info("输出Hello World!"); String message = demoService.getMessage(); // String message = "Hello World!"; DemoResponse response = DemoResponse.sussess(message); logger.info("输出Hello World!, 返回结果: &#123;&#125;", JacksonUtil.toJSONString(response)); return response; &#125;&#125; @RestController 注解等价于@Controller +@ResponseBody 的结合，使用这个注解的类里面的方法都以json 格式输出。 service Service类主要实现业务逻辑 12345678@Servicepublic class DemoService &#123; @Autowired private DemoMapper demoMapper; public String getMessage() &#123; return demoMapper.getMessage(); &#125; mapper Mapper类定义相关接口 123456789@Repositorypublic interface DemoMapper &#123; //mapper的insert不能使用前端VO，要使用实体类 //注解当时需要在类上加@Mapper注解 @Insert("insert into dodd(MESSAGE, STATUS) values(#&#123;message&#125;,#&#123;status&#125;)") void insertDodd(Dodd dodd); String getMessage(DoddRequest doddRequest);&#125; mapper.xml springBoot使用mybatis的两种方式：一种是注解方式，使用与简单的sql；还有一种是xml方式，xml方式比较强大，使用更多灵活性。 123456789101112131415&lt;mapper namespace="com.dodd.demo.DemoMapper"&gt; &lt;resultMap id="dodd" type="com.dodd.demo.entity.Dodd"&gt; &lt;result column="ID" property="id"/&gt; &lt;result column="MESSAGE" property="message"/&gt; &lt;result column="STATUS" property="status"/&gt; &lt;/resultMap&gt; &lt;select id="dodd" parameterType="com.dodd.demo.entity.request.DoddRequest" resultMap="dodd"&gt; select * from dodd where 1 = 1 &lt;if test="status != null"&gt; AND STATUS = #&#123;status&#125; &lt;/if&gt; ORDER BY status; &lt;/select&gt;&lt;/mapper&gt; application.properties 一个空的properties文件，你可以根据需要添加配置属性。 123456789101112#服务信息spring.application.name=dodd-pcserver.port=8080#关闭安全限制，可以通过actuator提供的接口看到更多信息management.security.enabled=false#数据源相关配置spring.datasource.url=jdbc:mysql://127.0.0.1:3306/dodd?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsespring.datasource.username=***spring.datasource.password=***spring.datasource.driver-class-name=com.mysql.jdbc.Driver 注意：数据源相关配置同上，是以spring.datasource开头，而不是jdbc开头，踩过的坑之一，项目启动失败，找到原因是数据源这里配置是以jdbc开头导致。 项目启动 方式一：Application的main方法： Run ‘Application’ 或 Debug ‘Application’ 方式二：使用命令 mvn spring-boot:run”在命令行启动该应用，IDEA中该命令在如下位置： 方式三：运行“mvn package”进行打包时，会打包成一个可以直接运行的 JAR 文件，使用“java -jar”命令就可以直接运行： 打开浏览器访问http://localhost:8080, 就能看到页面显示Hello World!，一个简单的spring boot项目创建成功。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github多地备份]]></title>
    <url>%2F2018%2F07%2F29%2Fblogs%2Fhexobackup%2F</url>
    <content type="text"><![CDATA[Hexo+Github个人博客多地备份个人博客家里和公司各有一份环境，随时编辑更新，之前是这么做的，最近在新公司电脑上配置hexo环境的时候，发现还是遇到了很多坑，很多细节操作忘记了，现在趁热做下笔记 一、环境安装 node.js git hexo: Hexo 验证环境安装： 二、操作步骤 拉backup分支到本地并做一备份（共两份文件），如图： 新建文件夹初始化hexo; hexo init npm install hexo -p 5000 server 本地测试hexo 初始化完成后如图： 将初始化完成的hexo文件内容覆盖到backup中； 注意：node_modules在从hexo拷贝到backup的过程中因为文件名太长导致失败，需要使用命令拷贝 切换到需要拷贝得文件得根目录：cp -a hexo/node_modules/ duanguangguang.github.io/ 将backup备份内容除了node_modules文件覆盖到backup中 这么做的原因是需要更新本地的hexo jar包，因为node_modules文件在.gitgnore忽略掉了，可以看到最终backup分支比刚备份下来得多了node_modules文件，如下图： 三、插件安装 将hexo与git关联起来 npm install hexo-deployer-git –save 可能会遇到图片无法显示的问题 npm install https://github.com/CodeFalling/hexo-asset-image –save 四、ssh配置将生成的公有密钥添加到github上即可 五、github分支管理策略 master分支 master分支存储的是博客生成的可以直接在浏览器上显示的静态文件 hexo generate 生成静态文件（） hexo deploy 将生成的静态文件部署到master上 我们在_config.yml配置了hexo关联的master分支，hexo deploy 命令会自动将生成的静态文件推送到master分支，除此之外master分支切勿自己提交内容，切记！！！ master分支内容就是backup分支中的public文件内容 正确的master分支内容如下图： backup分支 backup分支是对我们的博客文件包括主题配置等做的一个远程备份 git add --all 将修改的文件添加到git git commit -m &quot;description&quot; 文件提交 git push origin backup 文件推送到远程backup分支 正确的backup分支内容如下图： ​]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程池的使用]]></title>
    <url>%2F2018%2F03%2F17%2FjavaAdvance%2Fuserthreadpool%2F</url>
    <content type="text"><![CDATA[前言合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。 线程池使用线程池创建我们可以通过ThreadPoolExecutor来创建一个线程池： 12new ThreadPoolExecutor(corePoolSize, maximumPoolSize,keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler); 线程池提交任务通过ThreadPoolExecutor.execute(Runnable command)方法即可向线程池内添加一个任务。 我们可以使用execute提交的任务，但是execute方法没有返回值，所以无法判断任务知否被线程池执行成功。通过以下代码可知execute方法输入的任务是一个Runnable类的实例。 123456threadsPool.execute(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub &#125;&#125;); 我们也可以使用submit 方法来提交任务，它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。 12345678910try &#123; Object s = future.get();&#125; catch (InterruptedException e) &#123; // 处理中断异常&#125; catch (ExecutionException e) &#123; // 处理无法执行任务异常&#125; finally &#123; // 关闭线程池 executor.shutdown();&#125; 线程池关闭我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，但是它们的实现原理不同，shutdown的原理是只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。 只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。 线程池分析参考：JDK API 1.6 流程分析**：线程池的主要工作流程如下图： 从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下： 首先线程池判断基本线程池是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。 其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。 最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。 线程池状态在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态： 12345volatile int runState;static final int RUNNING = 0;static final int SHUTDOWN = 1;static final int STOP = 2;static final int TERMINATED = 3; unState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性； 下面的几个static final变量表示runState可能的几个取值。 当创建线程池后，初始时，线程池处于RUNNING状态； 如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕； 如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务； 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。 任务的执行在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量： 12345678910111213141516171819private final BlockingQueue&lt;Runnable&gt; workQueue; //任务缓存队列，用来存放等待执行的任务private final ReentrantLock mainLock = new ReentrantLock(); //线程池的主要状态锁，对线程池状态（比如线程池大小 //、runState等）的改变都要使用这个锁private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); //用来存放工作集 private volatile long keepAliveTime; //线程存活时间 private volatile boolean allowCoreThreadTimeOut; //是否允许为核心线程设置存活时间private volatile int corePoolSize; //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）private volatile int maximumPoolSize; //线程池最大能容忍的线程数 private volatile int poolSize; //线程池中当前的线程数 private volatile RejectedExecutionHandler handler; //任务拒绝策略 private volatile ThreadFactory threadFactory; //线程工厂，用来创建线程 private int largestPoolSize; //用来记录线程池中曾经出现过的最大线程数 private long completedTaskCount; //用来记录已经执行完毕的任务个数 largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。 下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。 在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可： 123456789101112public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); &#125; else if (!addIfUnderMaximumPoolSize(command)) reject(command); // is shutdown or saturated &#125;&#125; 上面的代码可能看起来不是那么容易理解，下面我们一句一句解释： 首先，判断提交的任务command是否为null，若是null，则抛出空指针异常； 接着是这句，这句要好好理解一下： 1if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) 由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。 如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行： 1addIfUnderCorePoolSize(command) 如果执行完addIfUnderCorePoolSize这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。 如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断： 1if (runState == RUNNING &amp;&amp; workQueue.offer(command)) 如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行： 1addIfUnderMaximumPoolSize(command) 如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。 回到前面： 1if (runState == RUNNING &amp;&amp; workQueue.offer(command)) 这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断： 1if (runState != RUNNING || poolSize == 0) 这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行： 1ensureQueuedTaskHandled(command) 进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。 我们接着看2个关键方法的实现：addIfUnderCorePoolSize和addIfUnderMaximumPoolSize： 123456789101112131415private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123; Thread t = null; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING) t = addThread(firstTask); //创建线程去执行firstTask任务 &#125; finally &#123; mainLock.unlock(); &#125; if (t == null) return false; t.start(); return true;&#125; 这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。然后就是执行: 1t = addThread(firstTask); 这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。 我们来看一下addThread方法的实现： 123456789101112private Thread addThread(Runnable firstTask) &#123; Worker w = new Worker(firstTask); Thread t = threadFactory.newThread(w); //创建一个线程，执行任务 if (t != null) &#123; w.thread = t; //将创建的线程的引用赋值为w的成员变量 workers.add(w); int nt = ++poolSize; //当前线程数加1 if (nt &gt; largestPoolSize) largestPoolSize = nt; &#125; return t;&#125; 在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。 下面我们看一下Worker类的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private final class Worker implements Runnable &#123; private final ReentrantLock runLock = new ReentrantLock(); private Runnable firstTask; volatile long completedTasks; Thread thread; Worker(Runnable firstTask) &#123; this.firstTask = firstTask; &#125; boolean isActive() &#123; return runLock.isLocked(); &#125; void interruptIfIdle() &#123; final ReentrantLock runLock = this.runLock; if (runLock.tryLock()) &#123; try &#123; if (thread != Thread.currentThread()) thread.interrupt(); &#125; finally &#123; runLock.unlock(); &#125; &#125; &#125; void interruptNow() &#123; thread.interrupt(); &#125; private void runTask(Runnable task) &#123; final ReentrantLock runLock = this.runLock; runLock.lock(); try &#123; if (runState &lt; STOP &amp;&amp; Thread.interrupted() &amp;&amp; runState &gt;= STOP) boolean ran = false; beforeExecute(thread, task); //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据 //自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等 try &#123; task.run(); ran = true; afterExecute(task, null); ++completedTasks; &#125; catch (RuntimeException ex) &#123; if (!ran) afterExecute(task, ex); throw ex; &#125; &#125; finally &#123; runLock.unlock(); &#125; &#125; public void run() &#123; try &#123; Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; workerDone(this); //当任务队列中没有任务时，进行清理工作 &#125; &#125;&#125; 它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样： 1Thread t = new Thread(w); 相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。 既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了： 123456789101112public void run() &#123; try &#123; Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; workerDone(this); &#125;&#125; 从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现： 123456789101112131415161718192021222324252627Runnable getTask() &#123; for (;;) &#123; try &#123; int state = runState; if (state &gt; SHUTDOWN) return null; Runnable r; if (state == SHUTDOWN) // Help drain queue r = workQueue.poll(); else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间， //则通过poll取任务，若等待一定的时间取不到任务，则返回null r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS); else r = workQueue.take(); if (r != null) return r; if (workerCanExit()) &#123; //如果没取到任务，即r为null，则判断当前的worker是否可以退出 if (runState &gt;= SHUTDOWN) // Wake up others interruptIdleWorkers(); //中断处于空闲状态的worker return null; &#125; // Else retry &#125; catch (InterruptedException ie) &#123; // On interruption, re-check runState &#125; &#125;&#125; 在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null。 如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。 如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。 然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现： 12345678910111213141516private boolean workerCanExit() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); boolean canExit; //如果runState大于等于STOP，或者任务缓存队列为空了 //或者 允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1 try &#123; canExit = runState &gt;= STOP || workQueue.isEmpty() || (allowCoreThreadTimeOut &amp;&amp; poolSize &gt; Math.max(1, corePoolSize)); &#125; finally &#123; mainLock.unlock(); &#125; return canExit;&#125; 也就是说如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现： 12345678910void interruptIdleWorkers() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; for (Worker w : workers) //实际上调用的是worker的interruptIfIdle()方法 w.interruptIfIdle(); &#125; finally &#123; mainLock.unlock(); &#125;&#125; 从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中： 123456789101112void interruptIfIdle() &#123; final ReentrantLock runLock = this.runLock; if (runLock.tryLock()) &#123; //注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的 //如果成功获取了锁，说明当前worker处于空闲状态 try &#123; if (thread != Thread.currentThread()) thread.interrupt(); &#125; finally &#123; runLock.unlock(); &#125; &#125;&#125; 这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。 我们再看addIfUnderMaximumPoolSize方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的： 123456789101112131415private boolean addIfUnderMaximumPoolSize(Runnable firstTask) &#123; Thread t = null; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING) t = addThread(firstTask); &#125; finally &#123; mainLock.unlock(); &#125; if (t == null) return false; t.start(); return true;&#125; 看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &lt; maximumPoolSize不同而已。 到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下： 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务； 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务； 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理； 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。 线程池中的线程初始化默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。 在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到： prestartCoreThread()：初始化一个核心线程； prestartAllCoreThreads()：初始化所有核心线程 下面是这2个方法的实现： 12345678910public boolean prestartCoreThread() &#123; return addIfUnderCorePoolSize(null); //注意传进去的参数是null&#125; public int prestartAllCoreThreads() &#123; int n = 0; while (addIfUnderCorePoolSize(null))//注意传进去的参数是null ++n; return n;&#125; 注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的。 1r = workQueue.take(); 即等待任务队列中有任务。 任务缓存队列及排队策略在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。 workQueue的类型为BlockingQueue，通常可以取下面三种类型： ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小； LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE； synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。 任务拒绝策略当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略： 1234ThreadPoolExecutor.AbortPolicy;//丢弃任务并抛出RejectedExecutionException异常。ThreadPoolExecutor.DiscardPolicy;//也是丢弃任务，但是不抛出异常。ThreadPoolExecutor.DiscardOldestPolicy;//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy;//由调用线程处理该任务 线程池的关闭ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中： shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务 线程池容量的动态调整ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize() setCorePoolSize：设置核心池大小 setMaximumPoolSize：设置线程池最大能创建的线程数目大小 当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。 合理配置线程池要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析： 任务的性质：CPU密集型任务，IO密集型任务和混合型任务。 任务的优先级：高，中和低。 任务的执行时间：长，中和短。 任务的依赖性：是否依赖其他系统资源，如数据库连接。 任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。 执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。 依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。 建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。 线程池监控通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用 taskCount：线程池需要执行的任务数量。 completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。 largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。 getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。 getActiveCount：获取活动的线程数。 通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如： 1&lt;b&gt;protected&lt;/b&gt; &lt;b&gt;void&lt;/b&gt; beforeExecute(Thread t, Runnable r) &#123; &#125; 使用示例12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); for(int i=0;i&lt;15;i++)&#123; MyTask myTask = new MyTask(i); executor.execute(myTask); System.out.println("线程池中线程数目："+executor.getPoolSize()+"，队列中等待执行的任务数目："+ executor.getQueue().size()+"，已执行玩别的任务数目："+executor.getCompletedTaskCount()); &#125; executor.shutdown(); &#125;&#125; class MyTask implements Runnable &#123; private int taskNum; public MyTask(int num) &#123; this.taskNum = num; &#125; @Override public void run() &#123; System.out.println("正在执行task "+taskNum); try &#123; Thread.currentThread().sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("task "+taskNum+"执行完毕"); &#125;&#125; 执行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445正在执行task 0线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 1线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 2线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 3线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 4线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 10线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 11线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 12线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 13线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 14task 3执行完毕task 0执行完毕task 2执行完毕task 1执行完毕正在执行task 8正在执行task 7正在执行task 6正在执行task 5task 4执行完毕task 10执行完毕task 11执行完毕task 13执行完毕task 12执行完毕正在执行task 9task 14执行完毕task 8执行完毕task 5执行完毕task 7执行完毕task 6执行完毕task 9执行完毕 从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。 不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池： 123Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUEExecutors.newSingleThreadExecutor(); //创建容量为1的缓冲池Executors.newFixedThreadPool(int); //创建固定容量大小的缓冲池 从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。 newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue； newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue； newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。 实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。 另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。]]></content>
      <categories>
        <category>JAVA</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池的运行原理]]></title>
    <url>%2F2018%2F03%2F17%2FjavaAdvance%2Fthreadpoolworker%2F</url>
    <content type="text"><![CDATA[线程池的运行原理本文基于JDK1.8源码进行分析。 线程池是维护了一批线程来处理用户提交的任务，达到线程复用的目的，线程池维护的这批线程被封装成了Worker。当我们向线程池提交任务时，通常使用execute方法，接下来就先从该方法开始分析。execute方法： 1234567891011121314151617181920212223242526272829303132public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //JDK8的源码中，线程池本身的状态跟worker数量使用同一个变量ctl来维护 int c = ctl.get(); //通过位运算得出当然线程池中的worker数量与构造参数corePoolSize进行比较 if (workerCountOf(c) &lt; corePoolSize) &#123; //如果小于corePoolSize，则直接新增一个worker，并把当然用户提交的任务command作为参数，如果成功则返回。 if (addWorker(command, true)) return; //如果失败，则获取最新的线程池数据 c = ctl.get(); &#125; //如果线程池仍在运行，则把任务放到阻塞队列中等待执行。 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //这里的recheck思路是为了处理并发问题 int recheck = ctl.get(); //当任务成功放入队列时，如果recheck发现线程池已经不再运行了则从队列中把任务删除 if (! isRunning(recheck) &amp;&amp; remove(command)) //删除成功以后，会调用构造参数传入的拒绝策略。 reject(command); //如果worker的数量为0（此时队列中可能有任务没有执行），则新建一个worker（由于此时新建woker的目的是执行队列中堆积的任务， //因此入参没有执行任务，详细逻辑后面会详细分析addWorker方法）。 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //如果前面的新增woker，放入队列都失败，则会继续新增worker，此时线程池的状态是woker数量达到corePoolSize，阻塞队列任务已满 //只能基于maximumPoolSize参数新建woker else if (!addWorker(command, false)) //如果基于maximumPoolSize新建woker失败，此时是线程池中线程数已达到上限，队列已满，则调用构造参数中传入的拒绝策略 reject(command);&#125; 总结一下用户向线程池提交任务以后，线程池的执行逻辑： 如果当前woker数量小于corePoolSize，则新建一个woker并把当前任务分配给该woker线程，成功则返回。 如果第一步失败，则尝试把任务放入阻塞队列，如果成功则返回。 如果第二步失败，则判断如果当前woker数量小于maximumPoolSize，则新建一个woker并把当前任务分配给该woker线程，成功则返回。 如果第三步失败，则调用拒绝策略处理该任务。 从execute的源码可以看出addWorker方法是重中之重，马上来看下它的实现。addWorker方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private boolean addWorker(Runnable firstTask, boolean core) &#123; //这里有一段基于CAS+死循环实现的关于线程池状态，线程数量的校验与更新逻辑就先忽略了，重点看主流程。 //... boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; //把指定任务作为参数新建一个worker线程 w = new Worker(firstTask); //这里是重点，咋一看，一定以为w.thread就是我们传入的firstTask //其实是通过线程池构造函数参数threadFactory生成的woker对象 //也就是说这个变量t就是代表woker线程。绝对不是用户提交的线程任务firstTask！！！ final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //加锁之后仍旧是判断线程池状态等一些校验逻辑。 int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) throw new IllegalThreadStateException(); //把新建的woker线程放入集合保存，这里使用的是HashSet workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; //然后启动woker线程 //这里再强调一遍上面说的逻辑，该变量t代表woker线程，也就是会调用woker的run方法 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) //如果woker启动失败，则进行一些善后工作，比如说修改当前woker数量等等 addWorkerFailed(w); &#125; return workerStarted;&#125; addWorker方法主要做的工作就是新建一个Woker线程，加入到woker集合中，然后启动该线程，那么接下来的重点就是Woker类的run方法了。worker执行方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Woker类实现了Runnable接口public void run() &#123; runWorker(this);&#125;//最终woker执行逻辑走到了这里final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); //task就是Woker构造函数入参指定的任务，即用户提交的任务 Runnable task = w.firstTask; w.firstTask = null; w.unlock(); boolean completedAbruptly = true; try &#123; //一般情况下，task都不会为空（特殊情况上面注释中也说明了），因此会直接进入循环体中 //这里getTask方法是要重点说明的，它的实现跟我们构造参数设置存活时间有关 //我们都知道构造参数设置的时间代表了线程池中的线程，即woker线程的存活时间，如果到期则回收woker线程，这个逻辑的实现就在getTask中。 //来不及执行的任务，线程池会放入一个阻塞队列，getTask方法就是去阻塞队列中取任务，用户设置的存活时间，就是 //从这个阻塞队列中取任务等待的最大时间，如果getTask返回null，意思就是woker等待了指定时间仍然没有 //取到任务，此时就会跳过循环体，进入woker线程的销毁逻辑。 while (task != null || (task = getTask()) != null) &#123; w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; //该方法是个空的实现，如果有需要用户可以自己继承该类进行实现 beforeExecute(wt, task); Throwable thrown = null; try &#123; //真正的任务执行逻辑 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; //该方法是个空的实现，如果有需要用户可以自己继承该类进行实现 afterExecute(task, thrown); &#125; &#125; finally &#123; //这里设为null，也就是循环体再执行的时候会调用getTask方法 task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; //当指定任务执行完成，阻塞队列中也取不到可执行任务时，会进入这里，做一些善后工作，比如在corePoolSize跟maximumPoolSize之间的woker会进行回收 processWorkerExit(w, completedAbruptly); &#125;&#125; woker线程的执行流程就是首先执行初始化时分配给的任务，执行完成以后会尝试从阻塞队列中获取可执行的任务，如果指定时间内仍然没有任务可以执行，则进入销毁逻辑。注：这里只会回收corePoolSize与maximumPoolSize直接的那部分woker 初始化线程池时线程数的选择 如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。 如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。 上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。 线程池任务执行流程 当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。 当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行 当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务 当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理 当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程 当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭 阻塞队列选择的区别一般如果线程池任务队列采用LinkedBlockingQueue队列的话，那么不会拒绝任何任务（因为队列大小没有限制），这种情况下，ThreadPoolExecutor最多仅会按照最小线程数来创建线程，也就是说线程池大小被忽略了。 如果线程池任务队列采用ArrayBlockingQueue队列的话，那么ThreadPoolExecutor将会采取一个非常负责的算法，比如假定线程池的最小线程数为4，最大为8所用的ArrayBlockingQueue最大为10。随着任务到达并被放到队列中，线程池中最多运行4个线程（即最小线程数）。即使队列完全填满，也就是说有10个处于等待状态的任务，ThreadPoolExecutor也只会利用4个线程。如果队列已满，而又有新任务进来，此时才会启动一个新线程，这里不会因为队列已满而拒接该任务，相反会启动一个新线程。新线程会运行队列中的第一个任务，为新来的任务腾出空间。 这个算法背后的理念是：该池大部分时间仅使用核心线程（4个），即使有适量的任务在队列中等待运行。这时线程池就可以用作节流阀。如果挤压的请求变得非常多，这时该池就会尝试运行更多的线程来清理；这时第二个节流阀—最大线程数就起作用了。]]></content>
      <categories>
        <category>JAVA</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池]]></title>
    <url>%2F2018%2F03%2F17%2FjavaAdvance%2Fjava-ThreadPool%2F</url>
    <content type="text"><![CDATA[java线程池简介我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。Jdk1.5之后加入了java.util.concurrent包，这个包中主要介绍java中线程以及线程池的使用。 线程池是维护了一批线程来处理用户提交的任务，达到线程复用的目的。 线程池的作用线程池作用就是限制系统中执行线程的数量。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。 为什么使用线程池 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 线程池接口Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 比较重要的几个类： ExecutorService 真正的线程池接口。 ScheduledExecutorService 能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。 ThreadPoolExecutor ExecutorService的默认实现。 ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。 线程池有关类之间的关系： 首先：是ThreadPoolExecutor继承AbstractExecutorService，并且有四个构造方法。 123public class ThreadPoolExecutor extends AbstractExecutorService &#123; //...&#125; 再是AbstractExecutorService实现ExecutorService： 123public abstract class AbstractExecutorService implements ExecutorService &#123; //...&#125; 接着看ExecutorService接口的实现： 123456public interface ExecutorService extends Executor &#123; void shutdown(); boolean isShutdown(); boolean isTerminated(); //...&#125; 最后是Executor接口： 123public interface Executor &#123; void execute(Runnable command);&#125; Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的； 然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等； 抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法； 然后ThreadPoolExecutor继承了类AbstractExecutorService。 在ThreadPoolExecutor类中有几个非常重要的方法： 12345//execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。//submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。//shutdown()和shutdownNow()是用来关闭线程池的。 四种常见线程池Java通过Executors提供了四种线程池，这四种线程池都是直接或间接配置ThreadPoolExecutor的参数实现的，在Executors类里面提供了一些静态工厂，生成一些常用的线程池。 newSingleThreadExecutor创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 有且仅有一个工作线程执行任务 所有任务按照指定顺序执行，即遵循队列的入队出队规则 适用：一个任务一个任务执行的场景 创建方法： 1ExecutorService singleThreadPool = Executors.newSingleThreadPool(); 源码： 12345678public static ExecutorService newSingleThreadExecutor() &#123; //线程池中只有一个线程进行任务执行，其他的都放入阻塞队列 //外面包装的FinalizableDelegatedExecutorService类实现了finalize方法，在JVM垃圾回收的时候会关闭线程池 return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 示例： 1234567891011public class MyTask implements Runnable&#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在执行。。。"); &#125;&#125; 1234567891011121314151617181920public class TestSingleThreadExecutor &#123; public static void main(String[] args) &#123; //创建一个可重用固定线程数的线程池 ExecutorService pool = Executors. newSingleThreadExecutor(); //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Runnable t1 = new MyTask(); Runnable t2 = new MyTask(); Runnable t3 = new MyTask(); Runnable t4 = new MyTask(); Runnable t5 = new MyTask(); //将线程放入池中进行执行 pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); //关闭线程池 pool.shutdown(); &#125;&#125; 输出结果： 12345pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。 newFixedThreadPool创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大数量。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 可控制线程最大并发数（同时执行的线程数） 超出的线程会在队列中等待 适用：执行长期的任务，性能好很多 创建方法： 12345//nThreads =&gt; 最大线程数即maximumPoolSizeExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads);//threadFactory =&gt; 创建线程的方法ExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads, ThreadFactory threadFactory); 源码： 1234567public static ExecutorService newFixedThreadPool(int nThreads) &#123; //corePoolSize跟maximumPoolSize值一样，同时传入一个无界阻塞队列 //根据上面分析的woker回收逻辑，该线程池的线程会维持在指定线程数，不会进行回收 return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 示例： 1234567891011121314151617181920public class TestFixedThreadPool &#123; public static void main(String[] args) &#123; //创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Runnable t1 = new MyTask(); Runnable t2 = new MyTask(); Runnable t3 = new MyTask(); Runnable t4 = new MyTask(); Runnable t5 = new MyTask(); //将线程放入池中进行执行 pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); //关闭线程池 pool.shutdown(); &#125;&#125; 输出结果： 12345pool-1-thread-1正在执行。。。pool-1-thread-2正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-2正在执行。。。pool-1-thread-1正在执行。。。 newCachedThreadPool创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程数量做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程数量。 线程数无限制 有空闲线程则复用空闲线程，若无空闲线程则新建线程 一定程序减少频繁创建/销毁线程，减少系统开销 适用：执行很多短期异步的小程序或者负载较轻的服务器 创建方法： 1ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); 源码： 123456public static ExecutorService newCachedThreadPool() &#123; //这个线程池corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE，意思也就是说来一个任务就创建一个woker，回收时间是60s return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 示例： 1234567891011121314151617181920public class TestCachedThreadPool &#123; public static void main(String[] args) &#123; //创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newCachedThreadPool(); //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Runnable t1 = new MyTask(); Runnable t2 = new MyTask(); Runnable t3 = new MyTask(); Runnable t4 = new MyTask(); Runnable t5 = new MyTask(); //将线程放入池中进行执行 pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); //关闭线程池 pool.shutdown(); &#125;&#125; 输出结果： 12345pool-1-thread-2正在执行。。。pool-1-thread-4正在执行。。。pool-1-thread-3正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-5正在执行。。。 newScheduledThreadPool定长线程池。此线程池支持定时以及周期性执行任务的需求。 适用：周期性执行任务的场景 创建方法： 12//nThreads =&gt; 最大线程数即maximumPoolSizeExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(int corePoolSize); 源码： 12345678910public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;//ScheduledThreadPoolExecutor():public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 示例： 12345678910111213141516171819public class TestScheduledThreadPoolExecutor &#123; public static void main(String[] args) &#123; ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor(1); exec.scheduleAtFixedRate(new Runnable() &#123;//每隔一段时间就触发异常 @Override public void run() &#123; //throw new RuntimeException(); System.out.println("================"); &#125; &#125;, 1000, 5000, TimeUnit.MILLISECONDS); exec.scheduleAtFixedRate(new Runnable() &#123;//每隔一段时间打印系统时间，证明两者是互不影响的 @Override public void run() &#123; System.out.println(System.nanoTime()); &#125; &#125;, 1000, 2000, TimeUnit.MILLISECONDS); &#125;&#125; 输出结果： 12345678================45908502635044592850370330================459485048196845968505608854598850893874================ ThreadPoolExecutor详解ThreadPoolExecutor提供了四个构造函数：12345678910111213141516171819202122232425262728293031//五个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)//六个参数的构造函数-1public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)//六个参数的构造函数-2public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)//七个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) int corePoolSize =&gt; 该线程池中核心线程数最大值 线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程 核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。 如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉。 很好理解吧，正常情况下你不干活我也养你，因为我总有用到你的时候，但有时候特殊情况(比如我自己都养不起了)，那你不干活我就要把你干掉了。 int maximumPoolSize =&gt; 该线程池中线程总数最大值 线程总数 = 核心线程数 + 非核心线程数。 long keepAliveTime =&gt; 该线程池中非核心线程闲置超时时长 一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉。如果设置allowCoreThreadTimeOut = true，则会作用于核心线程。 jdk中的解释是：当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。什么意思？接着上面的解释，后来向老板派来的工人始终是借来的，俗话说有借就有还，但这里的问题就是什么时候还了，如果借来的工人刚完成一个任务就还回去，后来发现任务还有，那岂不是又要去借？这一来一往，老板肯定头也大死了。 合理的策略：既然借了，那就多借一会儿。直到某一段时间后，发现再也用不到这些工人时，便可以还回去了。这里的某一段时间便是keepAliveTime的含义，TimeUnit为keepAliveTime值的度量。 TimeUnit unit =&gt; keepAliveTime的单位 TimeUnit是一个枚举类型，其包括： NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天 BlockingQueue workQueue =&gt; 该线程池中的任务队列：维护着等待执行的Runnable对象 当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务。 常用的workQueue类型： SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大。 LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize。 ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误。 DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。 PriorityBlockingQueue：优先级阻塞队列，该实现类需要自己实现一个继承了 Comparator 接口的类， 在插入资源时会按照自定义的排序规则来对资源数组进行排序。 其中值大的排在数组后面 ，取值时从数组头开始取。 排队有三种通用策略： 直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 有界队列。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 BlockingQueue的选择： 例子一：使用直接提交策略，也即SynchronousQueue。首先SynchronousQueue是无界的，也就是说他存数任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加。在这里不是核心线程便是新创建的线程，但是我们试想一样下，下面的场景。我们使用一下参数构造ThreadPoolExecutor： 1234567891011new ThreadPoolExecutor( 2, 3, 30, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new RecorderThreadFactory("CookieRecorderPool"), new ThreadPoolExecutor.CallerRunsPolicy()); new ThreadPoolExecutor( 2, 3, 30, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new RecorderThreadFactory("CookieRecorderPool"), new ThreadPoolExecutor.CallerRunsPolicy()); 当核心线程已经有2个正在运行。 此时继续来了一个任务（A），根据前面介绍的如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。所以A被添加到queue中。 又来了一个任务（B），且核心2个线程还没有忙完，接下来首先尝试1中描述，但是由于使用的SynchronousQueue，所以一定无法加入进去。 此时便满足了上面提到的如果无法将请求加入队列，则创建新的线程，除非创建此线程超出maximumPoolSize，在这种情况下，任务将被拒绝。所以必然会新建一个线程来运行这个任务。 暂时还可以，但是如果这三个任务都还没完成，连续来了两个任务，第一个添加入queue中，后一个呢？queue中无法插入，而线程数达到了maximumPoolSize，所以只好执行异常策略了。 所以在使用SynchronousQueue通常要求maximumPoolSize是无界的，这样就可以避免上述情况发生（如果希望限制就直接使用有界队列）。对于使用SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。意思就是，如果你的任务A1，A2有内部关联，A1需要先运行，那么先提交A1，再提交A2，当使用SynchronousQueue我们可以保证，A1必定先被执行，在A1没有被执行前，A2不可能添加入queue中。 例子二：使用无界队列策略，即LinkedBlockingQueue 这个就拿newFixedThreadPool来说，根据前文提到的规则： 如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。那么当任务继续增加，会发生什么呢？ 如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。OK，此时任务变加入队列之中了，那什么时候才会添加新线程呢？ 如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。这里就很有意思了，可能会出现无法加入队列吗？不像SynchronousQueue那样有其自身的特点，对于无界队列来说，总是可以加入的（资源耗尽，当然另当别论）。换句说，永远也不会触发产生新的线程！corePoolSize大小的线程数会一直运行，忙完当前的，就从队列中拿任务开始运行。所以要防止任务疯长，比如任务运行的时间比较长，而添加任务的速度远远超过处理任务的时间，而且还不断增加，不一会儿就爆了。 例子三：有界队列，使用ArrayBlockingQueue。 这个是最为复杂的使用，所以JDK不推荐使用也有些道理。与上面的相比，最大的特点便是可以防止资源耗尽的情况发生。 举例来说，请看如下构造方法： 1234567891011new ThreadPoolExecutor( 2, 4, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), new RecorderThreadFactory("CookieRecorderPool"), new ThreadPoolExecutor.CallerRunsPolicy()); new ThreadPoolExecutor( 2, 4, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), new RecorderThreadFactory("CookieRecorderPool"), new ThreadPoolExecutor.CallerRunsPolicy()); 假设，所有的任务都永远无法执行完。对于首先来的A，B来说直接运行，接下来，如果来了C，D，他们会被放到queue中，如果接下来再来E，F，则增加线程运行E，F。但是如果再来任务，队列无法再接受了，线程数也到达最大的限制了，所以就会使用拒绝策略来处理。 ThreadFactory threadFactory =&gt; 创建线程的方式 这是一个接口，你new他的时候需要实现他的Thread newThread(Runnable r)方法，一般用不上。 应该知道AsyncTask是对线程池的封装，这里直接放一个AsyncTask新建线程池的threadFactory参数源码： 1234567new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread new Thread(Runnable r) &#123; return new Thread(r,"AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;//就给线程起了个名 RejectedExecutionHandler handler =&gt; 抛出异常专用 另一种情况便是，即使向老板借了工人，但是任务还是继续过来，还是忙不过来，这时整个队伍只好拒绝接受了。 RejectedExecutionHandler接口提供了对于拒绝任务的处理的自定方法的机会。在ThreadPoolExecutor中已经默认包含了4中策略，因为源码非常简单，这里直接贴出来。 CallerRunsPolicy 线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 1234567891011public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125;&#125; 这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行。 AbortPolicy 处理程序遭到拒绝将抛出运行时RejectedExecutionException，丢弃任务。 1234567public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(); &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException();&#125; DiscardPolicy 不能执行的任务将被删除。 1234567public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;&#125; 这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不抛出异常。 DiscardOldestPolicy 如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。 12345678910111213public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125;&#125; 该策略就稍微复杂一些，在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。这个策略需要适当小心。设想：如果其他线程都还在运行，那么新来任务踢掉旧任务，缓存在queue中，再来一个任务又会踢掉queue中最老任务。 向ThreadPoolExecutor添加任务：通过ThreadPoolExecutor.execute(Runnable command)方法即可向线程池内添加一个任务。 ThreadPoolExecutor的策略当一个任务被添加进线程池时： 线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务 线程数量达到了corePools，则将任务移入队列等待 队列已满，新建线程(非核心线程)执行任务 队列已满，总线程数又达到了maximumPoolSize，就会由上面那位星期天(RejectedExecutionHandler)抛出异常 总结keepAliveTime和maximumPoolSize及BlockingQueue的类型均有关系。如果BlockingQueue是无界的，那么永远不会触发maximumPoolSize，自然keepAliveTime也就没有了意义。 反之，如果核心数较小，有界BlockingQueue数值又较小，同时keepAliveTime又设的很小，如果任务频繁，那么系统就会频繁的申请回收线程。]]></content>
      <categories>
        <category>JAVA</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java值传递和引用传递]]></title>
    <url>%2F2018%2F03%2F16%2FjavaAdvance%2Fjava-transmit%2F</url>
    <content type="text"><![CDATA[前言关于Java传参时是引用传递还是值传递，一直是一个讨论比较多的话题，下面总结一下这个问题。Java中数据类型分为两大类，基本类型和对象类型。相应的，变量也有两种类型：基本类型和引用类型。 基本类型的变量保存原始值，即它代表的值就是数值本身； 而引用类型的变量保存引用值，引用值指向内存空间的地址，代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置。 基本类型包括：byte,short,int,long,char,float,double,Boolean 引用类型包括：类类型，接口类型和数组。 变量的基本类型和引用类型的区别基本数据类型在声明时系统就给它分配空间： 12int a;a=10; //正确，因为声明a时就分配了空间 引用则不同，它声明时只给变量分配了引用空间，而不分配数据空间： 123456Date date;//执行实例化，开辟数据空间存放Date对象，然后把空间的首地址传给date变量 //date=new Date();//如果注释掉上一步操作//The local variable date may not have been initialized//也就是说对象的数据空间没有分配date.getDate(); 看一下下面的初始化过程，注意”引用”也是占用空间的，一个空Object对象的引用大小大概是4byte： 123Date a,b; //在内存开辟两个引用空间a = new Date();//开辟存储Date对象的数据空间，并把该空间的首地址赋给ab = a; //将a存储空间中的地址写到b的存储空间中 值传递和引用传递这里要用实际参数和形式参数的概念来帮助理解： 形式参数：定义方法时写的参数。 实际参数：调用方法时写的具体数值。 值传递方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值。 1234567891011public class Test &#123; public static void change(int a)&#123; a=50; &#125; public static void main(String[] args) &#123; int a=10; System.out.println(a); change(a); System.out.println(a); &#125;&#125; 很显然输出的 是10，10。传递的是值得一份拷贝，这份拷贝与原来的值没什么关系。内存分析： 引用传递也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址；在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。 1234567891011public class Test &#123; public static void change(int []a)&#123; a[0]=50; &#125; public static void main(String[] args) &#123; int []a=&#123;10,20&#125;; System.out.println(a[0]); change(a); System.out.println(a[0]); &#125;&#125; 显然输出结果为10 50。实际传递的是引用的地址值。内存分析： 再看一个引用传递的例子： 1234567891011121314151617181920class Emp &#123; public int age;&#125;public class Test &#123; public static void change(Emp emp) &#123; emp.age = 50; emp = new Emp();//再创建一个对象 emp.age=100; &#125; public static void main(String[] args) &#123; Emp emp = new Emp(); emp.age = 100; System.out.println(emp.age); change(emp); System.out.println(emp.age); System.out.println(emp.age); &#125;&#125; 输出为：100 50 50。内存分析： String类型传递这里要特殊考虑String，以及Integer、Double等几个基本类型包装类，它们都是immutable类型，因为没有提供自身修改的函数，每次操作都是新生成一个对象，所以要特殊对待，可以认为是和基本数据类型相似，传值操作。 先看一个String和StringBuffer的例子： 1234567891011121314151617181920212223242526public class ReferencePkValue1 &#123; public static void main(String[] args)&#123; ReferencePkValue1 pk=new ReferencePkValue1(); //String类似基本类型，值传递，不会改变实际参数的值 String test1="Hello"; pk.change(test1); System.out.println(test1); //StringBuffer和StringBuilder等是引用传递 StringBuffer test2=new StringBuffer("Hello"); pk.change(test2); System.out.println(test2.toString()); &#125; public void change(String str)&#123; str=str+"world"; &#125; public void change(StringBuffer str)&#123; str.append("world"); &#125;&#125;// Hello // Helloworld // 对String和StringBuffer的操作产生了不同的结果 String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。 123456789public static void main(String[] args) &#123; String str = "AAA"; change(str); System.out.println(str);&#125; public static void change(String s) &#123; s = "abc";&#125;// AAA String是一个类，类是引用数据类型，做为参数传递的时候，应该是引用传递。但是从结果看起来却是值传递。原因： String的API中有这么一句话：their values cannot be changed after they are created， 意思是：String的值在创建之后不能被更改。 API中还有一段： 12345678910111213String str = "abc"; //等效于： char data[] = &#123;'a', 'b', 'c'&#125;; String str = new String(data);/*流程1. 主函数进栈，str1初始化。2. 调用change方法，change( )进栈，将str1的地址值，复制一份给s。3. change方法中，重现创建了一个String对象”abc”，并将s指向了新的地址值。4. change方法运行完毕，s所指向的地址值已经改变。5. change方法弹栈。6. 主函数弹栈。*/ 也就是说：对String对象str的任何修改 等同于 重新创建一个对象，并将新的地址值赋值给str。String对象做为参数传递时，走的依然是引用传递，只不过String这个类比较特殊。 String对象一旦创建，内容不可更改。每一次内容的更改都是重现创建出来的新对象。 当change方法执行完毕时，s所指向的地址值已经改变。而s本来的地址值就是copy过来的副本，所以并不能改变str1的值。 String类型类似情况： 12345678910111213public void call(Test t) &#123; Test t2 = new Test(); t2.setName("cba'); t.setName("abc"); t = t2 ; &#125; public static void main(String[] arg) &#123; Test obj = new Test(); call (obj) ; System.out.println("obj"+obj.getName()); &#125;//obj: abc java并没有c++中指针、地址的概念，它只有句柄（handler）的概念。 总共构建了两个Test对象，假设称main方法构建的对象为对象1，call方法构建的对象为对象2， 在main方法中，变量obj获得了对象1的句柄， 在参数传递中，变量obj把这个句柄传递给变量t， 在call方法中，变量t首先改变了对象1的属性，然后变量t又获得了对象2的句柄（但obj仍然是对象1的句柄）， call方法返回后，由于对象2失去了唯一的句柄，不可避免的进入垃圾收集器的视线。而obj仍然是对象1的句柄，由于对象1的属性已经被重新设置，所以我们可以看到打印出来的结果是abc。 所以：在Java中方法参数的传递，对象是传递引用，基本数据类型是传递值。对于值类型的参数来说，传递的是值的拷贝。对于引用类型的参数来说，传递的是引用本身的拷贝。 值传递和引用传递的区别总结：值传递和引用传递的区别在于引用传递是否对对象的属性进行修改操作，若无修改操作，则类似于“值传递”，对形参的修改不会影响实参；若对对象的属性进行了修改操作，因为引用本身和引用的拷贝指向同一块地址，所以修改操作会影响到实际对象。]]></content>
      <categories>
        <category>JAVA</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储引擎]]></title>
    <url>%2F2018%2F03%2F13%2FdataBase%2Fmysql-engine%2F</url>
    <content type="text"><![CDATA[MySQL存储引擎存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）。在Oracle 和SQL Server等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的。而MySql数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。 MySQL存储引擎分类MyISAM这种引擎是mysql最早提供的。这种引擎又可以分为静态MyISAM、动态MyISAM 和压缩MyISAM三种： 静态MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。 动态MyISAM：如果数据表中出现 varchar、xxxtext或xxxBLOB 字段时，服务器将自动选择这种表类型。相对于静态MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用 optimize table 命令或优化工具来进行碎片整理。 压缩MyISAM：以上说到的两种类型的表都可以用 myisamchk 工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。 但是，不管是何种MyISAM表，目前它都不支持事务，行级锁和外键约束的功能。 MyISAM Merge引擎：这种类型是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表。常应用于日志和数据仓库。 InnoDBInnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。 memory(heap)这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。 archive这种类型只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。 当然MySql支持的表类型不止上面几种。下面我们介绍一下如何查看和设置数据表类型。 MySQL中关于存储引擎的操作查看数据库可以支持的存储引擎show engines 命令可以显示当前数据库支持的存储引擎情况 123456789101112131415mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MyISAM | YES | MyISAM storage engine | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || ARCHIVE | YES | Archive storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec) 查看表的结构等信息的若干命令Desc[ribe] tablename 查看数据表的结构 123456789mysql&gt; desc user;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || password | varchar(80) | YES | | NULL | || username | varchar(80) | YES | | NULL | |+----------+-------------+------+-----+---------+----------------+3 rows in set (0.00 sec) Show create table tablename 显示表的创建语句 123456789101112mysql&gt; show create table user;+-------+--------------------------------------------+| Table | Create Table |+-------+--------------------------------------------+| user | CREATE TABLE `user` ( || | `id` int(11) NOT NULL AUTO_INCREMENT, || | `password` varchar(80) DEFAULT NULL, || | `username` varchar(80) DEFAULT NULL, || | PRIMARY KEY (`id`) || | ) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+-------+--------------------------------------------+1 row in set (0.01 sec) show table status like ‘tablename’\G 显示表的当前状态值 123456789101112131415161718192021222324mysql&gt; show table status like 'user' \G;*************************** 1. row *************************** Name: user Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 0 Avg_row_length: 0 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: 1 Create_time: 2017-10-23 23:53:45 Update_time: NULL Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: 1 row in set (0.00 sec)ERROR: No query specified 综上可见，后两种方式都可以帮助我们查看某一表的存储引擎类型 设置或修改表的存储引擎创建数据库表时设置存储存储引擎的基本语法是： 12345Create table tableName(columnName(列名1) type(数据类型) attri(属性设置),columnName(列名2) type(数据类型) attri(属性设置),……..) engine = engineName 例如,假设要创建一个名为user的表,此表包括id,用户名username和性别sex三个字段，并且要设置表类型为merge。则可用如下的方式创建此数据表： 123456create table user( id int not null auto_increment, username char(20) not null, sex char(2), primary key(id)) engine=merge 修改存储引擎，可以用命令： 1Alter table tableName engine=engineName 假如，若需要将表user的存储引擎修改为archive类型，则可使用命令： 12345678910111213141516171819202122232425mysql&gt; alter table user engine=archive;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show table status like 'user' \G*************************** 1. row *************************** Name: user Engine: ARCHIVE Version: 10 Row_format: Compressed Rows: 0 Avg_row_length: 487 Data_length: 8720Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: 1 Create_time: NULL Update_time: 2018-01-26 20:36:34 Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: 1 row in set (0.00 sec) MySQL 常用数据存储引擎区别mysql 有多种存储引擎，目前常用的是 MyISAM 和 InnoDB 这两个引擎。 MyISAMMyISAM 是 mysql 5.5.5 之前的默认引擎，它支持 B-tree/FullText/R-tree 索引类型。 锁级别为表锁，表锁优点是开销小，加锁快；缺点是锁粒度大，发生锁冲动概率较高，容纳并发能力低，这个引擎适合查询为主的业务。 此引擎不支持事务，也不支持外键。 MyISAM强调了快速读取操作。它存储表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。 InnoDBInnoDB 存储引擎最大的亮点就是支持事务，支持回滚，它支持 Hash/B-tree 索引类型。 锁级别为行锁，行锁优点是适用于高并发的频繁表修改，高并发是性能优于 MyISAM。缺点是系统消耗较大，索引不仅缓存自身，也缓存数据，相比 MyISAM 需要更大的内存。 InnoDB 中不保存表的具体行数，也就是说，执行 select count(*) from table时，InnoDB 要扫描一遍整个表来计算有多少行。 支持事务，支持外键。 MemoryMemory 是内存级别存储引擎，数据存储在内存中，所以他能够存储的数据量较小。 因为内存的特性，存储引擎对数据的一致性支持较差。锁级别为表锁，不支持事务。但访问速度非常快，并且默认使用 hash 索引。 Memory存储引擎使用存在内存中的内容来创建表，每个Memory表只实际对应一个磁盘文件，在磁盘中表现为.frm文件。 总结 MyISAM InnoDB 存储结构 每张表被存放在三个文件：frm-格定义MYD(MYData)-数据文件MYI(MYIndex)-索引文件 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB 存储空间 MyISAM可被压缩，存储空间较小 InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 可移植性、备份及恢复 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 事务安全 不支持 每次查询具有原子性 支持 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表 AUTO_INCREMENT MyISAM表可以和其他字段一起建立联合索引 InnoDB中必须包含只有该字段的索引 SELECT MyISAM更优 INSERT InnoDB更优 UPDATE InnoDB更优 DELETE InnoDB更优 它不会重新建立表，而是一行一行的删除 COUNT without WHERE MyISAM更优。因为MyISAM保存了表的具体行数 InnoDB没有保存表的具体行数，需要逐行扫描统计，就很慢了 COUNT with WHERE 一样 一样，InnoDB也会锁表 锁 只支持表锁 支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的 外键 不支持 支持 FULLTEXT全文索引 支持 不支持（5.6.4以上支持英文全文索引） 可以通过使用Sphinx从InnoDB中获得全文索引，会慢一点 互联网项目中随着硬件成本的降低及缓存、中间件的应用，一般我们选择都以 InnoDB 存储引擎为主，很少再去选择 MyISAM 了。而业务真发展的一定程度时，自带的存储引擎无法满足时，这时公司应该是有实力去自主研发满足自己需求的存储引擎或者购买商用的存储引擎了。 原文： 浅谈MySql的存储引擎（表类型） MySQL 常用数据存储引擎区别]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串排序]]></title>
    <url>%2F2018%2F02%2F02%2Falgorithm%2FLSD%2F</url>
    <content type="text"><![CDATA[介绍低位优先（Least-Significant-DigitFirst，LSD） 的字符串排序：从右到左检查键中的字符。如果将一个字符串看作一个256进制的数字，那么从右向左检查字符串就等价于先检查数字的最低位。这种方法最适合用于键的长度都相同的字符串排序应用。 高位优先（MSD） 的字符串排序：从左到右检查键中的字符，首先查看的是最高位的字符。高位优先的字符串排序的吸引人之处在于。它们不一定需要检查所有的输入就能够完成排序。高位优先的字符串排序和快速排序类似，因为它们都会将需要排序的数组切分为独立的部分并递归地用相同的方法处理子数组来完成排序。区别在于 高位优先的字符串排序算法在切分时仅使用键的第一个字符，而快速排序的比较会涉及键的全部。 低位优先方法会为每个字符创建一个切分，而高位优先方法总会产生三个切分，分别对应被搜素键的第一个字符小于、等于或大于切分键的第一个字符的情况。 字母表在分析字符串排序算法时，字母表的大小是一个重要因素。我们的重点是基于扩展的ASCII字符集的字符串（R=256），但也会分析来自较小字母表的字符串（例如基因排序列）和来自较大字母表的字符串（例如含有65535个字符的Unicode字母表，它是自然语言编码的国际标准）。 java中表示字符串的两种方法 操作 字符数组 java字符串 声明 char[] a String s 根据索引访问字符 a[i] s.charAt(i) 获取字符串长度 a.length s.length() 表示方法转换 a=s.toCharArray() s=new String(a) 字母表API public class Alphabet Alphabet(String s) 根据s中的字符创建一张新的字母表 char toChar(int index) 获取字母表中索引位置的字符 int toIndex(char c) 获取c的索引，在0到R-1之间 boolean contains(char c) 是否包含c int R() 基数（字母表中的字符数量） INT lgR() 表示一个索引所需的比特数 int[] toIndices(String s) 将S转换为R进制的整数 String toChars(int[] indices) 将R进制的整数转换为基于该字母表的字符串 标准字母表 名称 R() lgR() 字符集 BINARY 2 1 01 DNA 4 2 ACTG OCTAL 8 3 01234567 DECIMAL 10 4 0123456789 HEXADECIMAL 16 4 0123456789ABCDEF PROTEIN 20 5 ACDEFGHIKLMNPQRSTVWY LOWERCASE 26 5 a~z UPPERCASE 26 5 A~Z BASE64 64 6 A~Za~z0~9+/ ASCII 128 7 ASCII字符集 EXTENDED_ASCII 256 8 扩展ASCII字符集 UNICODE16 65536 16 Unicode字符集 Alphabet实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class Alphabet &#123; public static final Alphabet BINARY = new Alphabet("01"); public static final Alphabet OCTAL = new Alphabet("01234567"); public static final Alphabet DECIMAL = new Alphabet("0123456789"); public static final Alphabet HEXADECIMAL = new Alphabet("0123456789ABCDEF"); public static final Alphabet DNA = new Alphabet("ACGT"); public static final Alphabet LOWERCASE = new Alphabet("abcdefghijklmnopqrstuvwxyz"); public static final Alphabet UPPERCASE = new Alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ"); public static final Alphabet PROTEIN = new Alphabet("ACDEFGHIKLMNPQRSTVWY"); public static final Alphabet BASE64 = new Alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); public static final Alphabet ASCII = new Alphabet(128); public static final Alphabet EXTENDED_ASCII = new Alphabet(256); public static final Alphabet UNICODE16 = new Alphabet(65536); private char[] alphabet; // the characters in the alphabet private int[] inverse; // indices private final int R; // the radix of the alphabet public Alphabet(String alpha) &#123; // check that alphabet contains no duplicate chars boolean[] unicode = new boolean[Character.MAX_VALUE]; for (int i = 0; i &lt; alpha.length(); i++) &#123; char c = alpha.charAt(i); if (unicode[c]) throw new IllegalArgumentException("Illegal alphabet: repeated character = '" + c + "'"); unicode[c] = true; &#125; alphabet = alpha.toCharArray(); R = alpha.length(); inverse = new int[Character.MAX_VALUE]; for (int i = 0; i &lt; inverse.length; i++) inverse[i] = -1; // can't use char since R can be as big as 65,536 for (int c = 0; c &lt; R; c++) inverse[alphabet[c]] = c; &#125; //Initializes a new alphabet using characters 0 through R-1. private Alphabet(int radix) &#123; this.R = radix; alphabet = new char[R]; inverse = new int[R]; // can't use char since R can be as big as 65,536 for (int i = 0; i &lt; R; i++) alphabet[i] = (char) i; for (int i = 0; i &lt; R; i++) inverse[i] = i; &#125; //Initializes a new alphabet using characters 0 through 255. public Alphabet() &#123; this(256); &#125; public boolean contains(char c) &#123; return inverse[c] != -1; &#125; @Deprecated public int R() &#123; return R; &#125; public int lgR() &#123; int lgR = 0; for (int t = R-1; t &gt;= 1; t /= 2) lgR++; return lgR; &#125; public int toIndex(char c) &#123; if (c &gt;= inverse.length || inverse[c] == -1) &#123; throw new IllegalArgumentException("Character " + c + " not in alphabet"); &#125; return inverse[c]; &#125; public int[] toIndices(String s) &#123; char[] source = s.toCharArray(); int[] target = new int[s.length()]; for (int i = 0; i &lt; source.length; i++) target[i] = toIndex(source[i]); return target; &#125; public char toChar(int index) &#123; if (index &lt; 0 || index &gt;= R) &#123; throw new IllegalArgumentException("index must be between 0 and " + R + ": " + index); &#125; return alphabet[index]; &#125; public String toChars(int[] indices) &#123; StringBuilder s = new StringBuilder(indices.length); for (int i = 0; i &lt; indices.length; i++) s.append(toChar(indices[i])); return s.toString(); &#125;&#125; 键索引计数法键索引计数 是一种适用于小整数键的简单排序方法。例如将全班学生按组好分类。这种方法有四个步骤： 1. 频率统计使用int数组count[]计算每个键出现的频率。对于数组中的每个元素，都使用它的键访问count[]中的相应元素并将其加1。如果键为r，则将count[r+1]加1。注：count[0]的值总是0，count[1]表示第零组（没有学生）。 2. 将频率转换为索引一般来说，任意给定的键的起始索引均为所有较小的键所对应的出现频率之和。对于每个键值r，小于r+1的键的频率之和为小于r的键的频率之和加上count[r]。示例中，第一组有3个人，第二组有5个人，因此第三组的起始位置是8。如下图： 3. 数据分类将所有元素（学生）移动到一个辅助数组aux[]中进行排序。每个元素在aux[]中的位置是由它的键（组别）对应的count[]值决定的，在移动之后将count[]中对应元素的值加1，以保证count[r]总是下一个键为r的元素在aux[]中的索引位置。这个过程只需要遍历一遍数据即可产生排序结果。如下图： 注意：这种实现方式的稳定性是很关键的，键相同的元素在排序后会被聚集到一起，但相对顺序没有变化。如下图： 4. 回写我们在将元素移动到辅助数组的过程中完成了排序，所以最后一步就是将排序的结果复制回原数组。 键索引计数法（a[].key()为[0,R)之间的一个整数）： 12345678910111213141516171819int N = a.length;String[] aux = new String[N];int[] count = new int[R+1];//计算出现频率for(int i = 0; i &lt; N; i++)&#123; count[a[i].key() + 1]++;&#125;//将频率转换为索引for(int r = 0; r &lt; R; r++)&#123; count[r+1] += count[r];&#125;//将元素分类for(int i = 0; i &lt; N; i++)&#123; aux[count[a[i].key()]++] = a[i];&#125;//回写for(int i = 0; i &lt; N; i++)&#123; a[i] = aux[i];&#125; 低位优先的字符串排序低位优先的字符串排序算法能够稳定地将定长字符串排序 。如果字符串的长度均为W，那就从右向左以每个位置的字符作为键，用索引计数法将字符串排序W遍。 12345678910111213141516171819202122232425262728public class LSD&#123; public static void sort(String[] a, int w) &#123; //通过前W个字符将a[]排序 int n = a.length; int R = 256; // extend ASCII alphabet size String[] aux = new String[n]; for (int d = w-1; d &gt;= 0; d--) &#123; // 根据第d个字符用键索引计数法排序 int[] count = new int[R+1]; // 计算出现频率 for (int i = 0; i &lt; n; i++) count[a[i].charAt(d) + 1]++; // 将频率转换为索引 for (int r = 0; r &lt; R; r++) count[r+1] += count[r]; // 将元素分类 for (int i = 0; i &lt; n; i++) aux[count[a[i].charAt(d)]++] = a[i]; // 回写 for (int i = 0; i &lt; n; i++) a[i] = aux[i]; &#125; &#125;&#125; 要将每个元素均为含有W个字符的字符串数组a[]排序，要进行W次键索引计数排序：从右向左，以每个位置的字符为键排序一次。 从理论上说，低位优先的字符串排序算法是一种适用于一般应用的线性时间排序算法。无论N有多大，它都只遍历W次数据。N个长为W的字符串的输入总共含有WN个字符，因此低位优先的字符串排序的运行时间与输入的规模成正比。 高位优先的字符串排序首先用键索引计数法将所有字符串按照首字母排序，然后（递归地）再将每个首字母所对应的子数组排序。和快速排序一样，高位优先的字符串排序会将数组切分为能够独立排序的子数组来完成排序任务，但它的切分会为每个首字母得到一个子数组，而不是像快速排序中那样产生固定的两个或三个切分。如下图： 1. 对字符串末尾的约定在高位优先的字符串排序算法中，要特别注意到达字符串末尾的情况。在排序中，合理的做法是将所有字符都已被检查过的字符串所在的子数组排在所有子数组的前面，这样就不需要递归地将该子数组排序，如下图所示： 为了简化这两步计算，我们使用了一个接受两个参数的私有方法charAt()来将字符串中字符索引转化为数组索引，当指定的位置超过了字符串的末尾时方法返回-1。然后将所有返回值加1，得到一个非负的int值并用它作为count[]的索引。这种转化意味着字符串中的每个字符都可能产生R+1种不同的值：0表示字符串的结尾 ，1表示字母表的第一个字符，2表示字母表第二个字符，等等。因为键索引计数法本来就需要一个额外的位置，所以使用代码int count[] = new int[R+2]创建记录统计频率的数组。 2. 指定的字母表高位优先的字符串排序的成本与字母表中的字符数量有很大关系 。改进基于较小的字母表的字符串排序程序的性能需要进行如下改动： 在构造函数中用一个alpha对象保存字母表； 在构造函数中将R设为alpha.R()； 在charAt()方法中将s.charAt(d)替换为alpha.toIndex(s.charAt(d))。 高位优先的字符串排序中count[]数组的意义： 高位优先的字符串排序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MSD &#123; private static final int R = 256; // 基数 private static final int CUTOFF = 15; // 小数组的切换阈值 private static String[] aux; //数据分类的辅助数组 private static int charAt(String s, int d)&#123; if(d &lt; s.length())&#123; return s.charAt(d); &#125;else&#123; return -1; &#125; &#125; public static void sort(String[] a) &#123; int n = a.length; aux = new String[n]; sort(a, 0, n-1, 0); &#125; private static void sort(String[] a, int lo, int hi, int d) &#123; // 以第d个字符为键将a[lo]至a[hi]排序 if (hi &lt;= lo + CUTOFF) &#123; insertion(a, lo, hi, d); return; &#125; int[] count = new int[R+2]; // 计算频率 for (int i = lo; i &lt;= hi; i++) &#123; int c = charAt(a[i], d); count[c+2]++; &#125; for (int r = 0; r &lt; R+1; r++) // 将频率转换为索引 count[r+1] += count[r]; for (int i = lo; i &lt;= hi; i++) &#123;// 数据分类 int c = charAt(a[i], d); aux[count[c+1]++] = a[i]; &#125; for (int i = lo; i &lt;= hi; i++) // 回写 a[i] = aux[i - lo]; for (int r = 0; r &lt; R; r++) // 递归的以每个字符为键进行排序 sort(a, lo + count[r], lo + count[r+1] - 1, d+1); &#125; /*************************** MSD辅助方法 *************************/ private static void insertion(String[] a, int lo, int hi, int d) &#123; for (int i = lo; i &lt;= hi; i++) for (int j = i; j &gt; lo &amp;&amp; less(a[j], a[j-1], d); j--) exch(a, j, j-1); &#125; // exchange a[i] and a[j] private static void exch(String[] a, int i, int j) &#123; String temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; // is v less than w, starting at character d private static boolean less(String v, String w, int d) &#123; // assert v.substring(0, d).equals(w.substring(0, d)); for (int i = d; i &lt; Math.min(v.length(), w.length()); i++) &#123; if (v.charAt(i) &lt; w.charAt(i)) return true; if (v.charAt(i) &gt; w.charAt(i)) return false; &#125; return v.length() &lt; w.length(); &#125;&#125; 在将一个字符串数组a[]排序时，首先根据它们的首字母用键索引计数法进行排序，然后（递归地）根据子数组中的字符串的首字母将子数组排序。 3. 小型子数组高位优先的字符串排序只需要检查若干个字符就能完成所有字符串的排序。换句话说，这种方法能够快速地将需要排序的数组切分为较小的数组。小型子数组对于高位优先的字符串排序的性能至关重要 。因此，将小数组切换到插入排序对于高位优先的字符串排序算法是必须的。为了避免重复检查已知相同的字符所带来的成本，我们对前d个字符均相同的字符串执行插入排序。 4. 等值键对于含有大量等值键的子数组的排序会较慢。如果相同的子字符串出现的过多，切换排序方法的条件将不会出现，那么递归方法就会检查所有相同键中的每一个字符。另外，键索引计数法无法有效判断字符串中的字符是否全部相同：它不仅需要检查每个字符和移动每个字符串，还需要初始化所有的频率统计并将它们转换为索引等。因此，高位优先的字符串排序的最坏的情况就是所有键均相同。 5. 性能高位优先的字符串排序算法的性能取决于数据 。对于基于比较的方法，我们主要关注的是键的顺序；对于高位优先的字符串排序算法，键的顺序并不重要，我们关注的是键所对应的值。如下图： 对于随机输入，高位优先的字符串排序算法只会检查足以区别字符串所需的字符，相对于输入数据中的字符总数，算法的运行时间是亚线性 的（只会检查字符串中的一部分）。 对于非随机的输入，高位优先的字符串排序算法可能仍然是亚线性的，但需要检查的字符可能比随机情况下更多。 在最坏情况下，高位优先的字符串排序算法会检查所有键中的所有字符串，所以相对于数据中的所有字符它所需的运行时间是线性的（和低位优先的字符串排序算法相同）。 三向字符串快速排序三向字符串快速排序是根据高位优先的字符串排序算法改进快速排序，根据键的首字母进行三向切分，仅在中间子数组中的下一个字符（因为键的首字母都与切分字符相等）继续递归排序。对于字符串的排序，这个方法比普通的快速排序和高位优先的字符串排序更友好，实际上它是这两个算法的结合。三向字符串快速排序的示意图如下： 高位优先的字符串排序可能会创建大量（空）子数组，而三向字符串快速排序的切分总是只有三个。因此三向字符串排序能够很好处理等值键、有较长公共前缀的键、取值范围较小的键和小数组—所有高位优先的字符串排序算法不擅长的各种情况，重要的是这种切分方法能够适应键的不同部分的不同结构，和快速排序一样，三向字符串快速排序也不需要额外的空间。适用于三向字符串快速排序的典型情况如下： 三向字符串快速排序实现： 1234567891011121314151617181920212223public class Quick3string &#123; public static void sort(String[] a) &#123; sort(a, 0, a.length-1, 0); &#125; // 3-way string quicksort a[lo..hi] starting at dth character private static void sort(String[] a, int lo, int hi, int d) &#123; if (hi &lt;= lo) return; int lt = lo, gt = hi; int v = charAt(a[lo], d); int i = lo + 1; while (i &lt;= gt) &#123; int t = charAt(a[i], d); if (t &lt; v) exch(a, lt++, i++); else if (t &gt; v) exch(a, i, gt--); else i++; &#125; sort(a, lo, lt-1, d); if (v &gt;= 0) sort(a, lt, gt, d+1); sort(a, gt+1, hi, d); &#125;&#125; 在将字符串数组a[]排序时，根据它们的首字母进行三向切分，然后（递归地）将得到三个子数组排序：一个含有所有首字母小于切分字符的字符串子数组，一个含有所有首字母等于切分字符的字符串的子数组（排序时忽略它们的首字母），一个含有所有首字母大于切分字符的字符串的子数组。该算法的实现只是为快速排序算法中的递归方法添加了一个参数来保存当前的切分字母并令三向切分的代码使用该字符，然后适当修改递归调用。 1. 小型子数组通过对小型子数组进行特殊处理：对前d个字符均相同的字符串执行插入排序来提高效率，这样能够跳过已知相等的字符。 2. 随机化和快速排序一样，最好在排序之前将数组打乱或是将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素。这么做主要是为了预防数组已经有序或是接近有序的最坏情况。 3. 性能要将含有N个随机字符串的数组排序，三向字符串快速排序平均需要比较字符~2NlnN次。 4. 举例：网站日志分析网站所有活动，每项活动都含有发起者的域名，这种排序结果中的很多字符串都有很长的公共前缀，所以这种算法不会重复检查他们。 字符串排序算法的选择各种字符串排序算法的性能特点：]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表]]></title>
    <url>%2F2018%2F01%2F30%2Falgorithm%2FHST%2F</url>
    <content type="text"><![CDATA[介绍用一个数组来实现无序的符号表，将键作为数组的索引而数组中键i处存储的就是它对应的值。这样我们就可以快速访问任意键的值。散列表就是这种简易方法的扩展并能够处理更加复杂的类型的键。我们需要用算术操作将键转化为数组的索引来访问数组中的键值对。 使用散列的查找算法分为两步。第一步是用散列函数将被查找的键转化为数组的一个索引。第二步是一个处理碰撞冲突的过程。两种解决碰撞的方法：拉链法 和 线性探测法 。散列表的核心问题碰撞冲突如下图： 散列表是算法在时间 和 空间上作出权衡 的经典例子。如果没有内存限制，我们可以直接将键作为数组的索引，那么所有查找操作只需要访问内存一次即可完成。另一方面，如果没有时间限制，我们可以使用无序数组并进行顺序查找，这样就只需要很少的内存。事实上，只需要调整散列表的参数就可以在空间和时间之间做出取舍。 散列函数散列函数能够将键转化为数组的索引。散列函数和键的类型有关。严格来说，对于每种类型的键我们都需要一个与之对应的散列函数 。如果键是一个数，那我们就可以直接使用这个数；如果键是一个字符串，我们就需要将这个字符串转化为一个数；如果键含有多个部分，比如邮件地址，我们需要用某种方法将这些部分结合起来。 1. 正整数将整数散列最常用的方法是除留余数法 。我们选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数 。这个计算能够有效地将键散布在0到M-1的范围内。除留余数法如下图： 2. 浮点数如果键是0到1之间的实数，我们可以将它乘以M并四舍五入得到一个0至M-1之间的索引值。但这个方法是有缺陷的，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。修正这个问题的办法是将键表示为二进制数然后再使用除留余数法（java是这么做的）。 3. 字符串除留余数法可以处理较长的键，例如字符串，我们只需将它们当作大整数即可。下面代码是用除留余数法计算String s的散列值： 1234int hash = 0;for(int i = 0; i &lt; s.length(); i++)&#123; hash = (R * hash + s.charAt(i)) % M;&#125; java的charAt()函数能够返回一个char值，即一个非负16位整数。如果R比任何字符的值都大，这种计算相当于将字符串当作一个N位的R进制值，将它除以M并取余。一种叫Horner方法的经典算法用N次乘法、加法和取余来计算一个字符串的散列值。只要R足够小，不造成溢出，那么结果就能够如我们所愿，落在0至M-1内。使用一个较小的素数，例如31，可以保证字符串中的所有字符都能发挥作用。java的String的默认实现使用了一个类似的方法。 4. 组合键如果键的类型含有多个整形变量，我们可以和String类型一样将它们混合起来。例如，假设被查找的键的类型是Date，其中含有几个整形的域：day，month和year。我们可以这样计算它的散列值： 1int hash = (((day * R + month) % M) * R + year) % M; 5. java的约定每种数据类型都需要相应的散列函数，于是java令所有数据类型都继承了一个能够返回一个32比特整数的hashCode()方法。每一种数据类型的hashCode()方法都必须和equals()方法一致。这说明如果你要为自定义的数据类型定义散列函数，你需要同时重写hashCode()和equals()两个方法。默认散列函数会返回对象的内存地址，但这只适用于很少的情况。java为很多常用的数据类型重写了hashCode()方法（包括String、Integer、Double、File和URL）。 6. 将hashCode()的返回值转化为一个数组索引因为我们需要的是数组的索引而不是一个32位整数，我们在实现中会将默认的hashCode()方法和除留余数法结合起来产生一个0到M-1的整数。方法如下： 123private int hash(Key x)&#123; return (x.hashCode() &amp; 0x7fffffff) % M;&#125; 这段代码会将符号位屏蔽（将一个32位整数变为一个31位非负整数），然后用除留余数法计算它除以M的余数。 7. 自定义的hashCode()方法散列表的用例希望hashCode()方法能够将键平均地散布为所有可能的32位整数。在java中所有数据类型都继承了hashCode()方法，因此我们可以将对象中的每个变量的hashCode()返回值转化为32位整数并计算得到散列值。如下： 12345678910111213public class Transaction&#123; private final String who; private final Date when; private final double amount; public int hashCode()&#123; int hash = 17; hash = 31 * hash + who.hashCode(); hash = 31 * hash + when.hashCode(); hash = 31 * hash + ((Double) amount).hashCode(); return hash; &#125;&#125; 对于原始类型的对象，可以将其转化为对应的数据类型然后再调用hashCode()方法。 8. 软缓存如果散列值的计算很耗时，可以将每个键的散列值缓存起来，即在每个键中使用一个hash变量来保存它的hashCode()的返回值。java中的String对象的hashCode()方法就是使用了这种缓存方法来减少计算量。总的来说，要为一个数据类型实现一个优秀的散列方法需要满足三个条件： 一致性：等价的键必然产生相等的散列值； 高效性：计算简便； 均匀性：均匀地散列所有的键。 基于拉链法的散列表散列算法的第二步是碰撞处理，也就是处理两个或多个键的散列值相同的情况。一种直接的办法是将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法称为拉链法 。查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。 基于拉链法的散列表SeparateChainingHashST使用了一个SequentialSearchST对象的数组，在put()和get()的实现中先计算散列函数来选定被查找的SequentialSearchST对象，然后使用符号表的put()和get()方法来完成相应的任务。 标准索引用例使用基于拉链法的散列表如下图所示： 基于拉链法的散列表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class SeparateChainingHashST&lt;Key, Value&gt; &#123; private static final int INIT_CAPACITY = 997; private int n; // 键值对总数 private int m; // 散列表的大小 private SequentialSearchST&lt;Key, Value&gt;[] st; // 存放链表对象的数组 public SeparateChainingHashST() &#123; this(INIT_CAPACITY); &#125; //创建m条链表 public SeparateChainingHashST(int m) &#123; this.m = m; st = (SequentialSearchST&lt;Key, Value&gt;[]) new SequentialSearchST[m]; for (int i = 0; i &lt; m; i++) st[i] = new SequentialSearchST&lt;Key, Value&gt;(); &#125; // hash value between 0 and m-1 private int hash(Key key) &#123; return (key.hashCode() &amp; 0x7fffffff) % m; &#125; public Value get(Key key) &#123; int i = hash(key); return (Value)st[i].get(key); &#125; public void put(Key key, Value val) &#123; if (val == null) &#123; delete(key); return; &#125; // double table size if average length of list &gt;= 10 if (n &gt;= 10*m) resize(2*m); int i = hash(key); if (!st[i].contains(key)) n++; st[i].put(key, val); &#125; public Iterable&lt;Key&gt; keys() &#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (int i = 0; i &lt; m; i++) &#123; for (Key key : st[i].keys()) queue.enqueue(key); &#125; return queue; &#125; &#125; 这段符号表的实现维护着一条链表的数组，用散列函数来为每个键选择一条链表。在创建st[]时需要进行类型转换，因为java不允许泛型的数组。默认的构造函数使用了997条链表，当能够预知所需要的符号表的大小时，这种方案能够得到不错的性能，一种更可靠的方案是动态调整链表数组的大小。在一张含有M条链条和N个键的散列表中，未命中查找和插入操作所需的比较次数为~N/M 。 散列表的大小在实习拉链法的散列表时，我们的目标是选择适当的数组大小M，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。而拉链法的一个好处就是这不是关键性的选择。如果存入的键多于预期，查找所需的时间只会比选择更大的数组稍长；如果少于预期，虽然有些浪费空间但查找会非常快。当内存不是很紧张时，可以选择一个足够大的M，使得查找变为常数；当内存紧张时，选择尽量大的M仍然能将性能提高M倍。 动态调整数组大小对于拉链法，如果能准确地估计用例所需的散列表大小N，调整数组大小的工作并不是必须的，只需要根据查找耗时和（1+N/M）成正比来选取一个适当的M即可。 1234567891011private void resize(int chains) &#123; SeparateChainingHashST&lt;Key, Value&gt; temp = new SeparateChainingHashST&lt;Key, Value&gt;(chains); for (int i = 0; i &lt; m; i++) &#123; for (Key key : st[i].keys()) &#123; temp.put(key, st[i].get(key)); &#125; &#125; this.m = temp.m; this.n = temp.n; this.st = temp.st;&#125; 删除操作要删除一个键值对，先用散列值找到含有该键的SequentialSearchST对象，然后调用该对象的delete()方法。 12345678public void delete(Key key) &#123; int i = hash(key); if (st[i].contains(key)) n--; st[i].delete(key); // halve table size if average length of list &lt;= 2 if (m &gt; INIT_CAPACITY &amp;&amp; n &lt;= 2*m) resize(m/2);&#125; 有序性相关操作散列最主要的饿目的在于均匀地将键散布开来，因此在计算散列后键的顺序信息就丢失了。所以要实现有序符号表的有序性相关操作，散列表不是合适的选择。在键的顺序不重要的应用中，它可能是最快的（也是使用最广泛的）符号表实现。当使用java的内置数据类型作为键，或是在使用含有经过完善测试的hashCode()方法的自定义类型作为键时，基于拉链法散列表算法能够提供快速而方便的查找和插入操作。 基于线性探测法的散列表实现散列表的另一种方式是用大小为M的数组保存N个键值对，其中M&gt;N。我们需要依靠数组汇中的空位解决碰撞冲突。基于这种策略的所有方法被统称为开放地址散列表 。开放地址散列表中最简单的方法叫做线性探测法 ：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表中的下一个位置（将索引值加1）。这样的线性探测可能产生三种结果： 命中，该位置的键和被查找的键相同； 未命中，键为空（该位置没有键）； 继续查找，该位置的键和被查找的键不同。 我们用散列函数找到键在数组中的索引，检查其中的键和被查找的键是否相同。如果不同则继续查找（将索引增大，到达数组结尾时折回数组的开头），直到找到该键或者遇到一个空元素。如下图所示： 开放地址类的散列表的核心思想是与其将内存用作链表，不如将它们作为在散列表的空元素。这些空元素可以作为查找结束的标志。我们在实现中使用了并行数组，一条保存键，一条保存值，并像前面讨论那样使用散列函数产生访问数据所需的数组索引。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LinearProbingHashST&lt;Key, Value&gt; &#123; private int n; // 符号表中键值对的总数 private int m; // 线性探测表的大小 private Key[] keys; // 键 private Value[] vals; // 值 public LinearProbingHashST(int capacity) &#123; m = capacity; n = 0; keys = (Key[]) new Object[m]; vals = (Value[]) new Object[m]; &#125; private int hash(Key key) &#123; return (key.hashCode() &amp; 0x7fffffff) % m; &#125; public void put(Key key, Value val) &#123; if (val == null) &#123; delete(key); return; &#125; // double table size if 50% full if (n &gt;= m/2) resize(2*m); int i; for (i = hash(key); keys[i] != null; i = (i + 1) % m) &#123; if (keys[i].equals(key)) &#123; vals[i] = val; return; &#125; &#125; keys[i] = key; vals[i] = val; n++; &#125; public Value get(Key key) &#123; for (int i = hash(key); keys[i] != null; i = (i + 1) % m) if (keys[i].equals(key)) return vals[i]; return null; &#125; public Iterable&lt;Key&gt; keys() &#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (int i = 0; i &lt; m; i++) if (keys[i] != null) queue.enqueue(keys[i]); return queue; &#125;&#125; 这段符号表的实现使用空（null）来表示一簇键的结束。如果一个新键的散列值是一个空元素，那么就将它保存在那里；如果不是，我们就顺序查找一个空元素来保存它。要查找一个键，我们从它的散列值开始顺序查找，如果找到则命中，如果遇到空元素则未命中。 删除操作从基于线性探测的散列表中删除一个键，直接将该键所在的位置设为null是不行的，这样会导致此位置之后的元素无法被查找。因此，我们需要将被删除键的右侧的所有键重现插入散列表。 1234567891011121314151617181920212223242526272829public void delete(Key key) &#123; if (!contains(key)) return; // find position i of key int i = hash(key); while (!key.equals(keys[i])) &#123; i = (i + 1) % m; &#125; // delete key and associated value keys[i] = null; vals[i] = null; // rehash all keys in same cluster i = (i + 1) % m; while (keys[i] != null) &#123; // delete keys[i] an vals[i] and reinsert Key keyToRehash = keys[i]; Value valToRehash = vals[i]; keys[i] = null; vals[i] = null; n--; put(keyToRehash, valToRehash); i = (i + 1) % m; &#125; n--; // halves size of array if it's 12.5% full or less if (n &gt; 0 &amp;&amp; n &lt;= m/8) resize(m/2);&#125; 和拉链法一样，开放地址类的散列表的性能也依赖于&amp;= N/M，我们将&amp;称为散列表的使用率 。对于基于拉链法的散列表，&amp;是每条链表的长度，因此一般大于1；对于基于线性探测法的散列表，&amp;是表中已经被占用的空间的比例，它是不可能大于1（散列表被占满）的，因为此时未命中的查找会导致无限循环。为了保证性能，我们会动态调整数组的大小来保证使用率在1/8到1/2之间。 键簇线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目，叫做键簇 。短小的键簇能保证较高的效率。如下图： 动态调整数组大小对于线性探测法，调整数组的大小是必需的，因为当用例插入的键值对数量超过预期时它的查找时间不仅会变得非常长，还会在散列表被填满时进入无限循环。 1234567891011private void resize(int capacity) &#123; LinearProbingHashST&lt;Key, Value&gt; temp = new LinearProbingHashST&lt;Key, Value&gt;(capacity); for (int i = 0; i &lt; m; i++) &#123; if (keys[i] != null) &#123; temp.put(keys[i], vals[i]); &#125; &#125; keys = temp.keys; vals = temp.vals; m = temp.m;&#125; 内存使用符号表的内存使用： 方法 N个元素所需的内存（引用类型） 基于拉链法的散列表 ~48N+32M 基于线性探测的散列表 在~32N和~128N之间 各种二叉查找树 ~56N 拉链法和线性探测法的性能差别主要是因为拉链法为每个键值对都分配了一块内存而线性探测则为整张表使用了两个很大的数组。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡查找树（红黑二叉查找树）]]></title>
    <url>%2F2018%2F01%2F29%2Falgorithm%2FredblackBST%2F</url>
    <content type="text"><![CDATA[介绍在一颗含有N个结点的树中，我们希望树高为~lgN，这样就能保证所有查找都能在~lgN次比较内结束，就和二分查找一样。但是在动态插入中保持树的完美平衡的代价太高了。 2-3查找树定义：一颗2-3查找树或为一颗空树，或由以下结点组成： 2-结点：含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-结点：含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点。中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 2-3查找树示意图： 一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都是相同的。 1. 查找要判断一个键是否在树中，我们先将它和根结点中的键比较，如果它和其中任意一个相等，查找命中；否则就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。具体查找过程如下： 2. 向2-结点中插入新键在2-3树中插入一个新结点，可以先和二叉查找树一样进行一次未命中的查找，如果未命中的查找结束于一个2-结点，我们只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。如下图： 如果未命中的查找结束于一个3-结点，事情就麻烦了。 3. 向一颗只含有一个3-结点的树中插入新键我们需要向一颗只含有一个3-结点的树中插入一个新键，这颗树有两个键，所以在它唯一的结点中已经没有可插入新键的空间了。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。它很自然地扩展了以前的结点并含有3个键和4条链接。然后很容易将它转换为一颗由3个2-结点组成的2-3树，其中一个结点（根）含有中键，一个结点含有3个键中的最小者（和根结点的左链接相连），一个结点含有3个键中的最大者（和根结点的右链接相连）。这棵树既是一颗含有3个结点的二叉查找树，又是一颗完美平衡的2-3树。如下图： 4. 向一个父结点为2-结点的3-结点中插入新键假设未命中的查找结束于3-结点，而它的父结点是一个2-结点，在这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间 。我们可以想刚才一样构造一个临时 的4-结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中。根据我们的假设，父结点中是有空间的：父结点是一个2-结点，插入后变成一个3-结点。另外，这次转换也不影响2-3树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了，树仍然是完美平衡的，插入后所有的空链接到根结点的距离仍然相同。其过程如下图： 5. 向一个父结点为3-结点的3-结点中插入新键现在假设未命中的查找结束于一个父结点为3-结点的结点，我们再次和刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入到它的父结点中，但父结点也是一个3-结点，因此需要再用这个中键构造一个临时4-结点，然后在这个结点上进行相同的变换 ，即分解这个父结点并将它的中键插入到更高层次的父结点，直到遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。该过程如下： 6. 分解根结点如果从插入结点到根结点的路径上全都是3-结点，我们的根结点最终变成一个临时的4-结点。此时我们可以按照向一颗只有一个3-结点的树中插入新键的方法处理这个问题。我们将临时的4-结点分解为3个2-结点，使树的高度加1。这次最后的变换仍然保持了树的完美平衡性，因为它变换的是根结点。其过程如下图： 7. 局部变换将一个4-结点分解为一颗2-3树可能有6中情况，如下图。 这个4-结点可能是根结点，可能是一个2-结点的左子结点或者右子结点，也可能是一个3-结点的左子结点、中子结点或者右子结点。2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。树中的任何地方只有符合相应的模式，变换都可以进行。每个变换都会将4-结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。这些局部变换不会影响树的全局有序性和平衡性。 8. 全局性质如下图所示的是当一个4-结点是一个3-结点的中子结点时的完整变换情况。如果在变换之前根结点到所有空链接的路径长度为h，那么变换后该长度仍然为h。所有的变换都具有这个性质，即使是将一个4-结点分解为两个2-结点并将其父结点由2-结点变为3-结点，或是由3-结点变为一个临时的4-结点时也是如此。当根结点被分解为3个2-结点时，所有空链接到根结点的路径长度才会加1。 9. 总结和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。在一颗大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个 。因此我们可以确定2-3树在最坏情况下仍然有较好的性能。上面我们理解了2-3树的插入算法，下面我们要学习一种名为红黑二叉查找树的简单数据结构来实现它。 红黑二叉查找树红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。 1.替换3-结点我们将树中的链接分为两种类型：红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接。确切地说，我们将3-结点表示为由一条左斜的红色链接（两个2-结点其中之一是另一个的左子结点）相连的两个2-结点。如图所示： 这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一颗对应的二叉查找树。我们将用这种方式表示的2-3树的二叉查找树称为红黑二叉查找树 ，简称红黑树 。 2. 一种等价的定义红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树： 红链接均为左链接； 没有任何一个结点同时和两条红链接相连； 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 满足这样定义的红黑树和相应的2-3树是一一对应的。 3. 一一对应如果我们将一颗红黑树中的红链接画平，那么所有的空链接到根结点的距离都将是相同的。如下图： 如果我们将由红链接相连的结点合并，得到的就是一颗2-3树。无论选择何种方式定义，红黑树都既是二叉查找树，也是2-3树。如下图： 因此我们能够在保持一一对应关系的基础上实现2-3树的插入算法，那么我们就能够将两个算法的优点结合起来：二叉查找树中简洁高效的查找方法和2-3树中高效的平衡插入算法。 4. 颜色表示因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量中。红色表示true，黑色表示false，约定空链接为黑色。当我们提到一个结点的颜色时，我们指的是指向该结点的链接的颜色。如下图： 123456private static final boolean RED = true;private static final boolean BLACK = false;private boolean isRed(Node x)&#123; if(x == null) return false; return x.color == RED;&#125; 5. 旋转旋转操作会改变红链接的指向。首先，假设我们有一条红色的右链接需要被转化为左链接 ，这个操作叫做左旋转 ，它对应的方法接受一条指向红黑树中的某个结点的链接作为参数。假设被指向的结点的右链接是红色的，这个方法会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根结点的链接。操作很容易理解：我们只是将用两个键中的较小者作为根结点变为将较大者作为根结点。实现将一个红色左链接转换为一个红色右链接的一个右旋转的代码完全相同，只需要将left和right互换即可。其操作如下图： 6. 在旋转后重置父结点的链接无论左旋转还是右旋转，旋转操作都会返回一条链接。我们总是会用rotateRight()或rotateLeft()的返回值重置父结点（或根结点）中相应的链接。这个链接可能是红色也可能是黑色，rotateRight()和rotateLeft()都通过将x.color设为h.color保留它原来的颜色。这可能会产生两条连续的红链接，但我们的算法会继续用旋转操作修正这种情况。这种简洁的代码是我们使用递归实现二叉查找树的各种方法的主要原因。它使得旋转操作成为了普通插入操作的一个简单补充。 在插入新键时我们可以使用旋转操作保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要性质：有序性 和 完美平衡性 。 7. 向单个2-结点中插入新键一颗只含有一个键的红黑树只含有一个2-结点。插入另一个键之后，我们马上就需要将它们旋转。如果新键小于老键，我们只需要新增一个红色的结点即可，新的红黑树和单个3-结点完全等价。如果新键大于老键，那么新增的红色结点将会产生一条红色的右链接。我们需要使用root = rotateLeft(root) 来将其旋转为红色左链接并修正根结点的链接，插入操作才算完成。两种情况的结果均为一颗和单个3-结点等价的红黑树，其中含有两个键，一条红链接，树的黑链接高度为1，如下图所示： 8. 向树底部的2-结点插入新键用和二叉查找树相同的方式向一颗红黑树中插入一个新键会在树的底部新增一个结点（为了保证有序性），但总是用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么上面的两种处理方法仍然适用。如果指向新结点的是父结点的左链接，那么父结点就直接成为了一个3-结点；如果指向新结点的是父结点的右链接，这需要一次左旋转去修正它。其操作如下图所示： 9. 向一颗双键树（即一个3-结点）中插入新键分三种情况：新键小于树中的两个键，在两者之间，新键大于树中的两个键。每种情况中都会产生一个同时连接到两条红链接的结点，我们需要修正这一点。 三者中最简单的情况是新键大于原树中的两个键，因此它被连接到3-结点的右链接。此时树是平衡的，根结点是中间大小的键，它有两条红链接分别和较小和较大的结点相连。如果我们将两条链接的颜色都由红变黑，那么我们就得到了一颗由三个结点组成、高为2的平衡树。它正好能够对应一颗2-3树。其他两种情况也会转化为这种情况。 如果新键小于原树中的两个键，它会被连接到最左边的空链接，这样就产生了两条连续的红链接，此时我们只需要将上层的红链接右旋转即可得到第一种情况（中间键为根节点并和其他两个结点用红链接相连）。 如果新键介于原树中的两个键之间，这又会产生两条连续的红链接，一条红色左链接接一条红色右链接，此时我们只需要将下层的红链接左旋转即可得到第二种情况（两条连续的红色左链接）。 总的来说，我们通过0次、1次和2次旋转以及颜色的变化得到了期望的结果。整个操作如下图： 10. 颜色转换我们专门用一个方法flipColors()来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑，同时还要将父结点的颜色由黑变红。这项操作最重要的性质在于它和旋转操作一样是局部变换，不会影响整颗树的黑色平衡性 。如下图所示： 11. 根结点总是黑色由9所述的情况中，颜色转换会使根结点变为红色。这也可能出现在很大的红黑树中。严格地说，红色的根结点说明根结点是一个3-结点的一部分，但实际情况是我们每次插入后都会将根结点设为黑色。注意：每当根结点由红变黑时树的黑链接高度就会加1 。 12. 向树底部的3-结点插入新键同9所述的三种情况：指向新结点的链接可能是3-结点的右链接（此时我们只需要转换颜色即可），或是左链接（此时我们需要进行右旋转再转换颜色），或是中链接（此时我们需要先左旋转下层链接然后右旋转上层链接，最后再转换颜色）。颜色转换会使的中结点的链接变红，相当于将它送入了父结点。这意味着在父结点中继续插入一个新键，我们也会继续用相同的办法解决。其操作如下图： 13. 将红链接在树中向上传递2-3树中的插入算法需要我们分解3-结点，将中间键插入父结点，如此这般直到遇到一个2-结点或是根结点。为了达成这个目标：每次必要的旋转之后我们都会进行颜色转换，这使得中结点变红。在父结点看来，处理这样一个红色结点的方式和处理一个新插入的红色结点完全相同，即继续把红链接转移到中结点上去。在红黑树中实现2-3树的插入算法的关键操作所需的步骤：要在一个3-结点下插入新键，先创建一个临时的4-结点，将其分解并将红链接由中间键传递给它的父结点。重复这个过程，我们就能将红链接在树中向上传递，直至遇到一个2-结点或者根结点 。其操作如下图所示： 在沿着插入点到根结点的路径向上移动时所经过的每个结点中顺序完成以下操作，我们就能完成插入操作： 如果右子结点是红色的而左子结点是黑色的，进行左旋转； 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转； 如果左右子结点均为红色，进行颜色转换。 实现因为保持树的平衡所需的操作是由下向上在每个所经过的结点中进行的，将它们植入我们已有的实现中十分简单：只需要在递归调用后完成这些操作即可，上一段中列出的三种操作都可以通过一个检测两个结点的颜色的if语句完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class RedBlackBST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; private class Node&#123; //含有color变量的Node对象 private Key key; // key private Value val; // associated data private Node left, right; // links to left and right subtrees private boolean color; // color of parent link private int size; // subtree count public Node(Key key, Value val, boolean color, int size) &#123; this.key = key; this.val = val; this.color = color; this.size = size; &#125; &#125; /* * 红黑树的插入算法 */ public void put(Key key, Value val) &#123; if (val == null) &#123; delete(key); return; &#125; root = put(root, key, val); root.color = BLACK; &#125; private Node put(Node h, Key key, Value val) &#123; if (h == null) return new Node(key, val, RED, 1); int cmp = key.compareTo(h.key); if (cmp &lt; 0) h.left = put(h.left, key, val); else if (cmp &gt; 0) h.right = put(h.right, key, val); else h.val = val; if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.size = size(h.left) + size(h.right) + 1; return h; &#125; /************************辅助方法start********************************/ private boolean isRed(Node x) &#123; if (x == null) return false; return x.color == RED; &#125; private int size(Node x) &#123; if (x == null) return 0; return x.size; &#125; public int size() &#123; return size(root); &#125; private Node rotateLeft(Node h) &#123; Node x = h.right; h.right = x.left; x.left = h; x.color = x.left.color; x.left.color = RED; x.size = h.size; h.size = size(h.left) + size(h.right) + 1; return x; &#125; private Node rotateRight(Node h) &#123; Node x = h.left; h.left = x.right; x.right = h; x.color = x.right.color; x.right.color = RED; x.size = h.size; h.size = size(h.left) + size(h.right) + 1; return x; &#125; private void flipColors(Node h) &#123; h.color = !h.color; h.left.color = !h.left.color; h.right.color = !h.right.color; &#125;/***************************辅助方法end********************************/&#125; 除了递归调用后的三条if语句，红黑树中put()的递归实现和二叉查找树中put()的实现完全相同。它们在查找路径上保证了红黑树和2-3树的一一对应关系，使得树的平衡性接近完美。第一条if语句会将任意含有红色右链接的3-结点（或临时的4-结点）向左旋转；第二条if语句会将临时的4-结点中两条连续红链接中的上层链接向右旋转；第三条if语句会进行颜色转换并将红链接在树中向上传递。下图是用标准索引测试用例和用同一组键按升序构造一颗红黑树的轨迹： 删除操作删除操作比插入操作更加复杂，不仅要在（为了删除一个结点而）构造临时4-结点时沿着查找路径向下进行变换，还要在分解遗留的4-结点时沿着查找路径向上进行变换（同插入操作）。 1. 自顶向下的2-3-4树我们先学习一个沿查找路径既能向上也能向下进行变换的稍简单得算法：2-3-4树的插入算法 ，2-3-4树中允许存在我们以前见过的4-结点。它的插入算法沿查找路径向下进行变换是为了保证当前结点不是4-结点（这样树底才有空间来插入新的键），沿查找路径向上进行变换是为了将之前创建的4-结点配平，如下图所示： 向下的变换和我们在2-3树中分解4-结点所进行的变换完全相同。如果根结点是4-结点，我们就将它分解成三个2-结点，使得树的高度加1。在向下查找的过程中，如果遇到一个父结点为2-结点的4-结点，我们将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点变成一个3-结点；如果遇到一个父结点为3-结点的4-结点，我们将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点变为一个4-结点；我们不必担心会遇到父结点为4-结点的4-结点，因为插入算法本身保证了这一情况不会出现。到达树底后，我们也只会遇到2-结点或者3-结点，所以我们可以插入新的键。要用红黑树实现这个算法，我们需要： 将4-结点表示为由三个2-结点组成的一颗平衡的子树，根结点和两个子结点都用红链接相连； 在向下的过程中分解所有4-结点并进行颜色转换； 和插入操作一样，在向上的过程中用旋转将4-结点配平（因为4-结点可以存在，所以允许一个结点同时连接到两条链接）。 只需要将上面put方法移动一行就能实现2-3-4树的插入操作：将flipColors语句（及其if语句）移动到递归调用前（null测试和比较操作之间） 。 2. 删除最小键从树底部的3-结点中删除键是简单的，但2-结点删除一个键会留下一个空结点，一般我们会将它替换为一个空链接，但这样会破坏树的完美平衡性所以我们需要这样做：为了保证我们不会删除一个2-结点，我们沿着左链接向下进行变换，确保当前结点不是2-结点。分下面几种情况： 如果当前结点的左子结点不是2-结点，完成； 如果当前结点的坐子结点是2-结点而它的亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移动到左子结点中； 如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为合并为一个4-结点，使父结点由3-结点变为2-结点或者由4-结点变为3-结点。 在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3-结点或者4-结点，然后我们就可以直接从中将其删除，将3-结点变成2-结点，或者将4-结点变为3-结点。然后我们再回头向上分解所有临时的4-结点。删除最小键操作如下图所示： 3. 删除操作在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是2-结点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后继结点交换，就和二叉查找树一样。因为当前结点必然不是2-结点，问题已经转换为在一颗根结点不是2-结点的子树中删除最小的键，我们可以在这颗树中使用前面所说的算法。和以前一样，删除之后我们需要向上回溯并分解余下的4-结点。 红黑树的性质结论：所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别（范围查找除外，它所需的额外时间和返回的键的数量成正比） 。 一颗大小为N的红黑树的高度不会超过2lgN。 一颗大小为N的红黑树中，根节点到任意结点的平均路径长度为~1.00lgN。 红黑树能够保证对数级别的查找和插入操作的实现 。 红黑树最吸引人的一点是它的实现中最复杂的代码仅限于put方法和删除方法。二叉查找树中的查找最大键和最小键、select、rank、floor、ceiling和范围查找方法不会做任何改动即可继续使用，因为红黑树也是二叉查找树而这些操作也不会涉及结点的颜色。各种符号表实现的性能总结：]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉查找树]]></title>
    <url>%2F2018%2F01%2F26%2Falgorithm%2Fbst%2F</url>
    <content type="text"><![CDATA[介绍定义：一颗二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。二叉查找树如下图： 在二叉树中，每个结点只能有一个父结点（根结点没有父结点），每个结点包含的链接可以为空或者只有左右两个链接，分别指向自己的左子结点和右子结点。因此可以将二叉查找树定义为一个空链接，或者是一个有左右两个链接的结点，每个链接都指向一颗独立的子二叉树。二叉查找树是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。具体来说，就是使用每个结点含有两个链接 （链表中每个结点只含有一个链接）的二叉查找树来高效的实现符号表。 二叉查找树的实现用二叉查找树实现有序符号表。采用递归实现。 1. 数据类型和链表一样，我们嵌套定义了一个私有类来表示二叉查找树上的一个结点。每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器。左链接指向一颗由小于该结点的所有键组成的二叉查找树，右链接指向一颗由大于该结点的所有键组成的二叉查找树。变量N给出以该结点为根的子树的结点总数。二叉查找树表示一条有序的键列图： 基于二叉查找树的符号表： 12345678910111213141516171819202122232425262728public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; // 二叉查找树的根结点 private class Node &#123; private Key key; // 键 private Value val; // 值 private Node left, right; // 指向子树的链接 private int size; // 以该结点为根的子树中的结点总数 public Node(Key key, Value val, int size) &#123; this.key = key; this.val = val; this.size = size; &#125; &#125; public int size() &#123; return size(root); &#125; private int size(Node x) &#123; if (x == null) &#123; return 0; &#125;else &#123; return x.size; &#125; &#125;&#125; 2. 查找在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中，否则我们就递归地在子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。当找到一个含有被查找的键的结点（命中）或者当前子树变为空（未命中）时结束。如图： 二叉查找树的查找方法的实现： 123456789101112public Value get(Key key) &#123; return get(root, key);&#125;private Value get(Node x, Key key) &#123; //在以x为根结点的子树中查找并返回key所对应的值 if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return get(x.left, key); else if (cmp &gt; 0) return get(x.right, key); else return x.val;&#125; 3. 插入插入的实现逻辑和递归查找很相似：如果树是空的，就返回一个含有该键值对的新结点；如果被查找的键小于根结点，我们会继续在左子树中插入该键，否则在右子树中插入该键。二叉查找树的插入操作： 二叉查找树的插入方法的实现： 1234567891011121314151617public void put(Key key, Value val) &#123; if (val == null) &#123; delete(key); return; &#125; root = put(root, key, val);&#125;private Node put(Node x, Key key, Value val) &#123; if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = put(x.left, key, val); else if (cmp &gt; 0) x.right = put(x.right, key, val); else x.val = val; x.size = 1 + size(x.left) + size(x.right); return x;&#125; 4. 查找和插入的递归实现可以将递归调用前的代码想象成沿着树向下走：它会将给定的键和每个结点的键相比较并根据结果向左或者向右移动到下一个结点。然后将递归调用后的代码想象成沿着树向上爬，对于get()方法，这对应着一系列的返回指令（return），但是对于put()方法，新结点会链接到树底层的空结点上，这意味着重置搜索路径上每个父结点指向子结点的链接，并增加路径上每个结点中的计数器的值。如图：一个二叉树的成长： 5. 分析使用二叉查找树的算法的运行时间取决于树的形状，而树的形状取决于键被插入的先后顺序。在最好的情况下，一颗含有N个结点的树是完全平衡的，每条空链接和根结点的距离都为~lgN。在最坏的情况下搜索路径上可能有N个结点。如图所示： 如下图3.2.8所示的简单模型：键的分布是均匀随机的，或者说它们插入的顺序是随机的。对这个模型的分析而言，二叉查找树和快速排序几乎就是双胞胎。树的根结点就是快速排序中的第一个切分元素（左侧的键都比它小，右侧的键都比它大），这对于所有的子树同样适用，这和快速排序中对子数组的递归排序完全对应。 说明： 在由N个随机键构造的二叉查找树中，查找命中平均所需的比较次数为~2lnN（约1.39lgN）。 在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为~2lnN（约1.39lgN）。 第二条说明插入一个新键的成本是对数级别的，这是基于二分查找的有序数组所不具备的灵活性，因为它的插入操作所需访问数组的次数是线性级别的。 6. 有序性相关的方法最大键和最小键如果根结点的左链接为空，那么一颗二叉查找树中最小的键就是跟结点；如果左链接非空，那么树中的最小键就是左树中的最小键。采用递归实现： 123456789101112131415public Key min() &#123; return min(root).key; &#125; private Node min(Node x) &#123; if (x.left == null) return x; else return min(x.left); &#125; public Key max() &#123; return max(root).key; &#125; private Node max(Node x) &#123; if (x.right == null) return x; else return max(x.right); &#125; 向上取整和向下取整如果给定的键key小于二叉查找树的根结点的键，那么小于等于key的最大建floor(key)一定在根结点的左子树中；如果给定的键key大于二叉查找树的根结点，那么只有当根结点右子树中存在小于等于key的结点时，小于等于key的最大键才会出现在右子树中，否则根结点就是小于等于key的最大键。向下取整函数的计算如下图： 1234567891011121314151617181920212223242526272829303132public Key floor(Key key) &#123; Node x = floor(root, key); if (x == null) return null; else return x.key;&#125; private Node floor(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp &lt; 0) return floor(x.left, key); Node t = floor(x.right, key); if (t != null) return t; else return x; &#125;public Key ceiling(Key key) &#123; Node x = ceiling(root, key); if (x == null) return null; else return x.key;&#125;private Node ceiling(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp &lt; 0) &#123; Node t = ceiling(x.left, key); if (t != null) return t; else return x; &#125; return ceiling(x.right, key); &#125; 选择和排名二叉查找树中的选择操作和基于切分的数组选择操作类似。在二叉查找树的每个结点中维护的子树结点计数器变量N就是用来支持此操作的。比如要找到排名为K的键（即树中正好有K个小于它的键）。如果左子树中的结点树t大于k，那就继续递归地在左子树中查找排名为K的键；如果t等于k，就返回根结点中的键；如果t小于k，就递归地在右子树中查找排名为 （k-t-1）的键。二叉查找树中的select操作： 排名rank()是select()的逆方法，它会返回给定键的排名。如果给定键和根结点相等，就返回左子树中的结点总数t；如果给定的键小于根结点，就返回该键在左子树中的排名（递归计算）；如果给定的键大于根结点，就返回t+1（根结点）加上它在右子树中的排名。 1234567891011121314151617181920212223public Key select(int k) &#123; Node x = select(root, k); return x.key;&#125; private Node select(Node x, int k) &#123; if (x == null) return null; int t = size(x.left); if (t &gt; k) return select(x.left, k); else if (t &lt; k) return select(x.right, k-t-1); else return x; &#125; public int rank(Key key) &#123; return rank(key, root);&#125; private int rank(Key key, Node x) &#123; if (x == null) return 0; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return rank(key, x.left); else if (cmp &gt; 0) return 1 + size(x.left) + rank(key, x.right); else return size(x.left); &#125; 7. 删除操作删除最大键和最小键和put()方法一样，我们的递归方法接受一个指向结点的链接，并返回一个指向结点的链接。这样我们就能方便地改变树的结构，将返回的链接赋给作为参数的链接。对于deleteMin()，我们要不断深入根结点的左子树中直至遇到一个空链接，然后将指向该结点的链接指向该结点的右子树。此时已经没有任何链接指向要被删除的结点，因此它会被垃圾收集器清理掉。在删除结点后正确的设置它的父结点并更新它到根结点的路径上的所有结点的计数器的值。 1234567891011121314151617181920public void deleteMin() &#123; root = deleteMin(root);&#125;private Node deleteMin(Node x) &#123; if (x.left == null) return x.right; x.left = deleteMin(x.left); x.size = size(x.left) + size(x.right) + 1; return x;&#125;public void deleteMax() &#123; root = deleteMax(root);&#125;private Node deleteMax(Node x) &#123; if (x.right == null) return x.left; x.right = deleteMax(x.right); x.size = size(x.left) + size(x.right) + 1; return x;&#125; 删除操作删除操作之后我们要处理两颗子树，但被删除结点的父结点只有一条空出来的链接。T.Hibbard在1962年提出了解决这个难题的第一个方法，在删除结点X后用它的后继结点补它的位置。因为X有一个右子结点，因此它的后继结点就是其右子树中的最小结点，这样的替换仍然能够保证树的有序性。可以用4个步骤完成X替换为它的后继结点的任务：如下图。 将指向即将被删除的结点的链接保存为t； 将X指向它的后继结点min（t.right）； 将X的右链接指向deleteMin（t.right），也就是在删除后所有结点仍然都大于x.key的子二叉树； 将X的左链接（本为空）设为t.left（其下所有的键都小于被删除的结点和它的后继结点）。 在递归调用后，我们会修正被删除的结点和父结点的链接，并将由此结点到根结点的路径上的所有结点的计数器减1（这里计数器的值仍然会被设为其所有子树中的结点总数加一）。 1234567891011121314151617181920public void delete(Key key) &#123; root = delete(root, key); &#125;private Node delete(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = delete(x.left, key); else if (cmp &gt; 0) x.right = delete(x.right, key); else &#123; if (x.right == null) return x.left; if (x.left == null) return x.right; Node t = x; x = min(t.right); //上面二叉查找树最小键方法 x.right = deleteMin(t.right); x.left = t.left; &#125; x.size = size(x.left) + size(x.right) + 1; return x;&#125; 该方法的缺陷在于选用后继结点时一个随意的决定，并且没有考虑树的对称性，在某些实际应用中可能产生性能问题。所以实际上，前趋结点和后继结点的选择应该是随机的。 8. 范围查找要实现能够返回给定范围内键的keys()方法，我们首先需要一个遍历二叉查找树的基本方法，叫做中序遍历 。先打印出根结点的左子树中的所有键，再打印出根结点的键，最后打印出根结点的右子树中的所有键。为了实现接受两个参数并能够将给定范围内的键返回给用例的Keys()方法，我们将所有落在给定范围以内的键加入一个队列Queue并跳过那些不可能含有所查找键的子树。 二叉查找树的范围查找操作： 12345678910111213141516171819public Iterable&lt;Key&gt; keys() &#123; if (isEmpty()) return new Queue&lt;Key&gt;(); return keys(min(), max());&#125;public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root, queue, lo, hi); return queue;&#125; private void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi) &#123; if (x == null) return; int cmplo = lo.compareTo(x.key); int cmphi = hi.compareTo(x.key); if (cmplo &lt; 0) keys(x.left, queue, lo, hi); if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) queue.enqueue(x.key); if (cmphi &gt; 0) keys(x.right, queue, lo, hi); &#125; 性能分析在一颗二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比 。我们可以认为二叉查找树是符合随机构造的树 。对于构造树的键不是随机的可以使用平衡二叉查找树 ，它能保证无论键的插入顺序如何，树的高度都将是总键数的对数。简单的符号表实现的成本总结如下图：]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[符号表]]></title>
    <url>%2F2018%2F01%2F26%2Falgorithm%2Fst%2F</url>
    <content type="text"><![CDATA[介绍定义：符号表是一种存储键值对的数据结构，支持两种操作：插入（put），即将一组新的键值对存入表中；查找（get），即根据给定的键得到相应的值。 一种简单得泛型符号表API： public class ST&lt;Key, Value&gt; 描述 默认实现 ST() 创建一张符号表 void put(Key key, Value val) 将键值对存入表中（若值为空则将键key从表中删除） Value get(Key key) 获取键key对应的值（若键key不存在则返回null） void delete(Key key) 从表中删除键key（及其对应的值） put(key, null) boolean contains(key key) 键key在表中是否有对应的值 return get(key) != null boolean isEmpty() 表是否为空 return size() == 0 int size() 表中键值对数量 Iterable keys() 表中所有键的集合 说明： 不允许存在重复的键，并且键不为空； 新值会替代旧值，并且值不为空； 两种删除：延时删除，即将键对应的值置为空，某个时候删除所有值为空的键；即时删除，立刻从表中删除指定的键。 有序符号表许多符号表的实现都利用了Comparable接口带来的键的有序性来更好地实现put()和get()方法。一种有序的泛型符号表的API： public class ST&lt;Key extends Comparable, Value&gt; 描述 默认实现 ST() 创建一张有序符号表 void put(Key key, Value val) 将键值对存入表中（若值为空则将键key从表中删除） Value get(Key key) 获取键key对应的值（若键key不存在则返回空） void delete(Key key) 从表中删除键key（及其对应的值） put(key, null) boolean contains(key key) 键key是否存在于表中 return get(key) != null boolean isEmpty() 表是否为空 return size() == 0 int size() 表中的键值对数量 Key min() 最小的键 key max() 最大的键 key floor(Key key) 小于等于key的最大键 key ceiling(key key) 大于等于key的最小键 int rank(key key) 小于key的键的数量 key select(int k) 排名为k的键 void deleteMin() 删除最小的键 delete(min()) void deleteMax() 删除最大的键 delete(max()) int size(key lo, key hi) [lo…hi]之间键的数量 Iterable keys(key lo, key hi) [lo…hi]之间的所有键，已排序 return keys(min(),max()) Iterable keys() 表中所有键的集合，已排序 说明： 最大键最小键类似优先队列的IndexMinPQ()，主要区别在于优先队列中可以存在重复的键，但符号表不可以。 排名的选择：对于0到size()-1的所有i都有i==rank(select(i))，且所有的键都满足key==select(rank(key))。 int size(key lo, key hi)的默认实现： if(hi.compareTo(lo)&lt;0) {return 0;}else if(contains(hi)){return rank(hi)-rank(lo)+1;}else{return rank(hi)-rank(lo);} 键的等价性：java维护所有Comparable类型中compareTo()方法和equals()方法的一致性，即（a.compareTo(b)==0）和（a.equals(b)）返回值相同。和排序算法一样，java为许多经常作为键的数据类型提供了标准的compareTo方法。为避免二义性，有序符号表中只使用compareTo方法比较两个键，而不使用equals方法。 查找的成本模型：在学习符号表的实现时，我们会统计比较的次数。在内循环不进行比较（极少）的情况下，我们统计数组的访问次数。 下面是两种初级的符号表的实现： 无序链表中的顺序查找符号表使用的数据结构的一个简单选择是链表，每个结点存储一个键值对。get()的实现即为遍历链表，用equals()方法比较需要被查找的键和每个结点中的键。如果匹配成功我们就返回相应的值，否则我们返回null。put()的实现也是遍历链表，用equals()方法比较需被查找的键和每个结点中的键。如果匹配成功我们就用第二个参数指定的值更新和该键相关联的值，否则我们就用给定的键值对创造一个新的结点并将其插入到链表的开头。这种方法称为顺序查找：在查找中一个一个地顺序遍历符号表中的所有键并使用equals方法来寻找与被查找的键匹配的键。 算法：顺序查找（基于无序链表）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SequentialSeqrchST&lt;Key, Value&gt; &#123; private int N; private Node first; //链表首结点 private class Node&#123; //链表结点的定义 Key key; Value val; Node next; public Node(Key key, Value val, Node next)&#123; this.key = key; this.val = val; this.next = next; &#125; &#125; //查找给定的键，返回相关联的值 public Value get(Key key)&#123; for(Node x = first; x != null; x = x.next)&#123; if(key.equals(x.key))&#123; return x.val; //命中 &#125; &#125; return null; //未命中 &#125; //查找给定的键，找到则更新其值，否则在表中新建结点 public void put(Key key, Value val)&#123; for(Node x = first; x != null; x = x.next)&#123; if(key.equals(x.key))&#123; x.val = val; //命中，更新 return; &#125; &#125; first = new Node(key, val, first); //未命中，新建结点 &#125; public int size() &#123; return N; &#125; //即时型的delete()方法 public void delete(Key key) &#123; first = delete(first, key); &#125; private Node delete(Node x, Key key) &#123; if (x == null) return null; if (key.equals(x.key)) &#123; n--; return x.next; &#125; x.next = delete(x.next, key); return x; &#125; //表中所有键的集合 public Iterable&lt;Key&gt; keys() &#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (Node x = first; x != null; x = x.next)&#123; queue.enqueue(x.key); &#125; return queue; &#125;&#125; 说明： 符号表的实现使用了一个私有内部类Node来在链表中保存键和值； 在含有N对键值的基于（无序）链表的符号表中，未命中的查找和插入 操作都需要N次比较。命中的查找在最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要~N^2/2次比较； 查找一个已经存在的键并不需要线性级别的时间。一种度量方法是查找表中的每个键，并将总时间除以N。在查找表中的每个键的可能性都相同的情况下，这个结果就是一次查找平均所需的比较数。我们称为随机命中 。 使用基于链表的符号表的索引用例的轨迹： 有序数组中的二分查找下面是有序符号表API的完整实现。它使用的数据结构是一对平行的数组，一个存储键一个存储值。该实现的核心是rank()方法，它返回表中小于给定键的键的数量。我们将所有更大的键向后移动一格来腾出位置（从后向前移动）并将给定的键值对分别插入到各自数组中的合适位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private static final int INIT_CAPACITY = 2; private Key[] keys; private Value[] vals; private int n = 0; public BinarySearchST(int capacity) &#123; keys = (Key[]) new Comparable[capacity]; vals = (Value[]) new Object[capacity]; &#125; //动态调整数组大小 private void resize(int capacity) &#123; assert capacity &gt;= n; Key[] tempk = (Key[]) new Comparable[capacity]; Value[] tempv = (Value[]) new Object[capacity]; for (int i = 0; i &lt; n; i++) &#123; tempk[i] = keys[i]; tempv[i] = vals[i]; &#125; vals = tempv; keys = tempk; &#125; public int size() &#123; return n; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public boolean contains(Key key) &#123; return get(key) != null; &#125; public Value get(Key key) &#123; if (isEmpty()) return null; int i = rank(key); if (i &lt; n &amp;&amp; keys[i].compareTo(key) == 0) return vals[i]; return null; &#125; //二分查找 public int rank(Key key) &#123; int lo = 0, hi = n-1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; int cmp = key.compareTo(keys[mid]); if (cmp &lt; 0) hi = mid - 1; else if (cmp &gt; 0) lo = mid + 1; else return mid; &#125; return lo; &#125; public void put(Key key, Value val) &#123; if (val == null) &#123; delete(key); return; &#125; int i = rank(key); // key is already in table if (i &lt; n &amp;&amp; keys[i].compareTo(key) == 0) &#123; vals[i] = val; return; &#125; // insert new key-value pair if (n == keys.length) resize(2*keys.length); for (int j = n; j &gt; i; j--) &#123; keys[j] = keys[j-1]; vals[j] = vals[j-1]; &#125; keys[i] = key; vals[i] = val; n++; assert check(); &#125; public void delete(Key key) &#123; if (isEmpty()) return; // compute rank int i = rank(key); // key not in table if (i == n || keys[i].compareTo(key) != 0) &#123; return; &#125; for (int j = i; j &lt; n-1; j++) &#123; keys[j] = keys[j+1]; vals[j] = vals[j+1]; &#125; n--; keys[n] = null; // to avoid loitering vals[n] = null; // resize if 1/4 full if (n &gt; 0 &amp;&amp; n == keys.length/4) resize(keys.length/2); assert check(); &#125; public void deleteMin() &#123; delete(min()); &#125; public void deleteMax() &#123; delete(max()); &#125; public Key min() &#123; return keys[0]; &#125; public Key max() &#123; return keys[n-1]; &#125; public Key select(int k) &#123; if (k &lt; 0 || k &gt;= size()) &#123; throw new IllegalArgumentException("called select() with invalid argument: " + k); &#125; return keys[k]; &#125; public Key floor(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to floor() is null"); int i = rank(key); if (i &lt; n &amp;&amp; key.compareTo(keys[i]) == 0) return keys[i]; if (i == 0) return null; else return keys[i-1]; &#125; public Key ceiling(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to ceiling() is null"); int i = rank(key); if (i == n) return null; else return keys[i]; &#125; public int size(Key lo, Key hi) &#123; if (lo == null) throw new IllegalArgumentException("first argument to size() is null"); if (hi == null) throw new IllegalArgumentException("second argument to size() is null"); if (lo.compareTo(hi) &gt; 0) return 0; if (contains(hi)) return rank(hi) - rank(lo) + 1; else return rank(hi) - rank(lo); &#125; public Iterable&lt;Key&gt; keys() &#123; return keys(min(), max()); &#125; public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123; if (lo == null) throw new IllegalArgumentException("first argument to keys() is null"); if (hi == null) throw new IllegalArgumentException("second argument to keys() is null"); Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); if (lo.compareTo(hi) &gt; 0) return queue; for (int i = rank(lo); i &lt; rank(hi); i++) queue.enqueue(keys[i]); if (contains(hi)) queue.enqueue(keys[rank(hi)]); return queue; &#125; private boolean check() &#123; return isSorted() &amp;&amp; rankCheck(); &#125; private boolean isSorted() &#123; for (int i = 1; i &lt; size(); i++) if (keys[i].compareTo(keys[i-1]) &lt; 0) return false; return true; &#125; // check that rank(select(i)) = i private boolean rankCheck() &#123; for (int i = 0; i &lt; size(); i++) if (i != rank(select(i))) return false; for (int i = 0; i &lt; size(); i++) if (keys[i].compareTo(select(rank(keys[i]))) != 0) return false; return true; &#125;&#125; 我们使用有序数组存储键的原因是，二分查找法能够根据数组的索引大大减小每次查找所需的比较次数。在有序数组中使用二分查找排名的轨迹： 这段符号表的实现用两个数组保存键和值，使用二分查找方法实现rank()方法，递归地rank()保留了以下性质： 如果表中存在该键，rank()应该返回该键的位置，也就是表中小于它的键的数量； 如果表中不存在该键，rank()还是应该返回表中小于它的键的数量。 使用基于有序数组的符号表实现的索引用例的轨迹： 对二分查找的分析： 在N个键的有序数组中进行二分查找最多需要（lgN+1）次比较（无论成功与否）； 向大小为N的有序数组中插入一个新的元素在最坏情况下需要访问~2N次数组，因此向一个空符号表中插入N个元素在最坏情况下需要访问~N^2次数组 二分查找减少了比较的次数，但无法减少运行所需的时间，put()方法的效率还是太慢了，无法处理大数量。 它无法处理Leipzing Corpora数据库，因为查找和插入操作是混合进行的，而且符号表也太大了。 总结简单得符号表实现的成本总结： 情况 顺序查找 二分查找 最坏情况下的查找 N lgN 最坏情况下的插入 N 2N 平均情况下的查找 N/2 N 平均情况下的插入 lgN N 是否高效支持有序性 否 是 查找算法的核心问题是能够保证同事查找和插入操作都是对数级别的算法和数据结构。要支持高效的插入，我们需要一种链式结构，可以将二分查找的效率和链表的灵活性结合起来的数据结构就是二叉查找树 。下面是符号表的各种实现的优缺点： 数据结构 实现 优点 缺点 链表（顺序查找） SequentialSearchST 适用于小型问题 对于大型符号表很慢 有序数组（二分查找） BinarySearchST 最优的查找效率和空间需求，能够进行有序性相关的操作 插入操作很慢 二叉查找树 BST 实现简单，能够进行有序性相关的操作 没有性能上界的保证，链接需要额外的空间 平衡二叉查找树 RedBlackBST 最优的查找和插入效率，能够进行有序性相关的操作 链接需要额外的空间 散列表 SeparateChainHashST LinearProbingHashST 能够快速地查找和插入常见类型的数据 需要计算每种类型的数据的散列，无法进行有序性相关的操作，链接和空结点需要额外的空间]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL性能优化]]></title>
    <url>%2F2018%2F01%2F23%2FdataBase%2Fmysqloptimize%2F</url>
    <content type="text"><![CDATA[一、优化SQL语句的一般步骤1. 通过 show status 命令了解各种 SQL 的执行频率MySQL 客户端连接成功后，通过show [session|global] status 命令可以提供服务器状态信息，也可以在操作系统上使用 mysqladmin extended-status 命令获得这些消息。show [session|global] status 可以根据需要加上参数session或者global来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写默认使用参数是session。 Com_xxx 表示每个 xxx 语句执行的次数,我们通常比较关心的是以下几个统计参数： Com_select：执行 select 操作的次数,一次查询只累加 1。 Com_insert：执行 INSERT 操作的次数,对于批量插入的 INSERT 操作，只累加一次。 Com_update：执行 UPDATE 操作的次数。 Com_delete：执行 DELETE 操作的次数。 上面这些参数对于所有存储引擎的表操作都会进行累计。 下面这几个参数只是针对InnoDB 存储引擎的,累加的算法也略有不同。 Innodb_rows_read:select 查询返回的行数。 Innodb_rows_inserted:执行 INSERT 操作插入的行数。 Innodb_rows_updated:执行 UPDATE 操作更新的行数。 Innodb_rows_deleted:执行 DELETE 操作删除的行数。 通过以上几个参数，可以很容易地了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的 SQL 大致的执行比例是多少。对于更新操作的计数,是对执行次数的计数，不论提交还是回滚都会进行累加。 对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。 此外，以下几个参数便于用户了解数据库的基本情况。 Connections:试图连接 MySQL 服务器的次数。 Uptime:服务器工作时间。 Slow_queries:慢查询的次数。 2. 定位执行效率较低的 SQL 语句可以通过以下两种方式定位执行效率较低的 SQL 语句： 通过慢查询日志定位那些执行效率较低的 SQL 语句，用log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以学习日志管理的相关部分。 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前 MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。 3. 通过 EXPLAIN 分析低效 SQL 的执行计划通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN 或者 DESC 命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比如想计算 2006 年所有公司的销售额，需要关联 sales 表和 company 表，并且对 moneys 字段做求和(sum)操作，相应 SQL 的执行计划如下： 每个列的简单解释如下: select_type：表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询,即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等。 table：输出结果集的表。 type：表示表的连接类型，性能由好到差的连接类型为： system（表中仅有一行，即常量表） const（单表中最多有一个匹配行，例如 primary key 或者 unique index） eq_ref（对于前面的每一行，在此表中只查询一条记录,简单来说，就是多表连接中使用 primary key 或者 unique index） ref（与 eq_ref 类似，区别在于不是使用 primary key 或者 unique index,而是使用普通的索引） ref_or_null（与 ref 类似,区别在于条件中包含对 NULL 的查询） index_merge（索引合并优化） unique_subquery（in的后面是一个查询主键字段的子查询） index_subquery （与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询） range （单表中的范围查询） index （对于前面的每一行,都通过查询索引来得到数据） all （对于前面的每一行,都通过全表扫描来得到数据） possible_keys：表示查询时,可能使用的索引。 key：表示实际使用的索引。 key_len：索引字段的长度。 rows：扫描行的数量。 Extra：执行情况的说明和描述。 4. 确定问题并采取相应的优化措施经过以上步骤，基本就可以确认问题出现的原因。此时用户可以根据情况采取相应的措施，进行优化提高执行的效率。在上面的例子中，已经可以确认是对 a 表的全表扫描导致效率的不理想，那么对 a 表的year 字段创建索引： 创建索引后，再看一下这条语句的执行计划： 可以发现建立索引后对 a 表需要扫描的行数明显减少（从 1000 行减少到 1 行），可见索引的使用可以大大提高数据库的访问速度，尤其在表很庞大的时候这种优势更为明显。 二、索引问题1. 索引的存储分类MyISAM 存储引擎的表的数据和索引是自动分开存储的，各自是独立的一个文件；InnoDB存储引擎的表的数据和索引是存储在同一个表空间里面，但可以有多个文件组成。 MySQL 中索引的存储类型目前只有两种（BTREE 和 HASH），具体和表的存储引擎相关：MyISAM 和InnoDB 存储引擎都只支持 BTREE 索引；MEMORY/HEAP 存储引擎可以支持HASH和BTREE 索引。 MySQL 目前不支持函数索引，但是能对列的前面某一部分进索引（前缀索引），例如 name 字段，可以只取 name 的前 4 个字符进行索引，这个特性可以大大缩小索引文件的大小，用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。下面是创建前缀索引的一个例子: 1mysql&gt; create index ind_company2_name on company2(name(4)); 2. MySQL如何使用索引查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。 使用索引在 MySQL 中，下列几种情况下有可能使用到索引： 对于创建的多列索引，只要查询的条件中用到了最左边的列，索引一般就会被使用： 对于使用 like 的查询，后面如果是常量并且只有%号不在第一个字符，索引才可能会被使用： 如果对大的文本进行搜索,使用全文索引而不用使用 like ‘%…%’。 如果列名是索引，使用 column_name is null 将使用索引： 存在索引但不使用索引在下列情况下，虽然存在索引,但是 MySQL 并不会使用相应的索引。 如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引。例如，如果列key_part1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好： 1select * from table_name where key_part1 &gt; 1 and key_part1 &lt; 90; 如果使用 MEMORY/HEAP 表并且 where 条件中不使用“=”进行索引列，那么不会用到索引。heap 表只有在“=”的条件下才会使用索引。 用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到，例如: 从上面可以发现只有 year 列上面有索引，来看如下的执行计划: 可见虽然在 year 这个列上存在索引 ind_sales_year，但是这个 SQL 语句并没有用到这个索引，原因就是 or 中有一个条件中的列没有索引。 如果不是索引列的第一部分，如下例子: 可见虽然在 money 上面建有复合索引，但是由于 money 不是索引的第一列，那么在查询中这个索引也不会被 MySQL 采用。 如果 like 是以%开始，例如: 可见虽然在 name 上建有索引，但是由于 where 条件中 like 的值的“%”在第一位了，那么MySQL 也不会采用这个索引。 如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的，因为MySQL 默认把输入的常量值进行转换以后才进行检索。如下面的例子中 company2 表中的 name 字段是字符型的，但是 SQL 语句中的条件值是一个数值型值,因此即便在 name 上有索引,，MySQL 也不能正确地用上索引，而是继续进行全表扫描。 从上面的例子中可以看到，第一个 SQL 语句中把一个数值型常量赋值给了一个字符型的列name，那么虽然在 name 列上有索引，但是也没有用到；而第二个 SQL 语句就可以正确使用索引。 3. 查看索引的情况如果索引正在工作，Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果正进行大量的表扫描，Handler_read_rnd_next 的值较高，则通常说明表索引不正确或写入的查询没有利用索引，具体如下： 从上面的例子中可以看出，目前使用的 MySQL 数据库的索引情况并不理想。 三、两个简单实用的优化方法1. 定期分析表和检查表分析表的语法如下： 1analyze [local | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 本语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得 SQL 能够生成正确的执行计划。如果用户感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题。在分析期间,使用一个读取锁定对表进行锁定。这对于 MyISAM,，BDB 和 InnoDB 表有作用。对于 MyISAM 表，本语句与使用 myisamchk -a 相当，下面对表 sales 做了表分析: 检查表的语法如下： 1check table tbl_name [, tbl_name] ... [option] ... option=&#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125; 检查表的作用是检查一个或多个表是否有错误。 CHECK TABLE 对 MyISAM 和 InnoDB 表有作用。对于 MyISAM 表，关键字统计数据被更新，例如: CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在，举例如下。 首先我们创建一个视图。 12mysql&gt; create view sales_view3 as select * from sales3;--Quick ok, 0 rows affected (0.00sec) 然后 CHECK 一下该视图,发现没有问题。 现在删除掉视图依赖的表。 12mysql&gt; drop table sales3;--Quick ok, 0 rows affected (0.00sec) 再来 CHECK 一下刚才的视图,发现报错了。 2. 定期优化表优化表的语法如下: 1optimize [local | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 如果已经删除了表的一大部分，或者如果已经对含有可变长度行的表（含有 VARCHAR、BLOB 或 TEXT 列的表）进行了很多更改，则应使用 OPTIMIZE TABLE 命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对 MyISAM、BDB 和 InnoDB 表起作用。 注意：ANALYZE、CHECK、OPTIMIZE 执行期间将对表进行锁定，因此一定注意要在数据库不繁忙的时候执行相关的操作。 四、常用SQL的优化1. 大批量插入数据当用 load 命令导入数据的时候，适当的设置可以提高导入的速度。对于 MyISAM 存储引擎的表，可以通过以下方式快速的导入大量的数据： 123ALTER TABLE tbl_name DISABLE KEYS;loading the dataALTER TABLE tbl_name ENABLE KEYS; DISABLE KEYS 和 ENABLE KEYS 用来打开或者关闭 MyISAM 表非唯一索引的更新。在导入大量的数据到一个非空的 MyISAM 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的 MyISAM 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。 123456789mysql&gt; alter table film_test2 disable keys;--Query OK, 0 rows affected (0.00 sec)mysql&gt; load data infile &apos;/home/mysql/film_test.txt&apos; into table film_test2;--Query OK, 529056 rows affected (6.34 sec)--Records: 529056 Deleted: 0 Skipped: 0 Warnings: 0mysql&gt; alter table film_test2 enable keys;--Query OK, 0 rows affected (12.25 sec) 上面是对MyISAM表进行数据导入时的优化措施，对于InnoDB类型的表，这种方式并不能提高导入数据的效率，可以有以下几种方式提高InnoDB表的导入效率。 因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效地提高导入数据的效率。 在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。 12345SET UNIQUE_CHECKS=0;#loading the dataload data infile &apos;/home/mysql/film_test.txt&apos; into table film_test2;SET UNIQUE_CHECKS=1; 如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。 12345SET AUTOCOMMIT=0;#loading the dataload data infile &apos;/home/mysql/film_test.txt&apos; into table film_test2;SET AUTOCOMMIT=1; 2. 优化 INSERT 语句当进行数据 INSERT 的时候,可以考虑采用以下几种优化方式。 如果同时从同一客户插入很多行，尽量使用多个值表的 INSERT 语句，这种方式将大大缩减客户端与数据库之间的连接、关闭等消耗，使得效率比分开执行的单个 INSERT 语句快（在一些情况中几倍）。下面是一次插入多值的一个例子: 1insert into test values(1,2),(1,3),(1,4)... 如果从不同客户插入很多行，能通过使用 INSERT DELAYED 语句得到更高的速度。DELAYED 的含义是让 INSERT 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁，这比每条语句分别插入要快的多；LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完后才进行插入。 将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）。 如果进行批量插入，可以增加 bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对 MyISAM 表使用。 当从一个文本文件装载一个表时，使用 LOAD DATA INFILE。这通常比使用很多 INSERT 语句快 20 倍。 3. 优化 GROUP BY 语句默认情况下，MySQL 对所有 GROUP BY col1，col2….的字段进行排序。这与在查询中指定ORDER BY col1，col2…类似。因此，如果显式包括一个包含相同的列的 ORDER BY 子句，则对 MySQL 的实际执行性能没有什么影响。 如果查询包括 GROUP BY 但用户想要避免排序结果的消耗，则可以指定 ORDER BY NULL禁止排序。 4. 优化 ORDER BY 语句在某些情况中，MySQL 可以使用一个索引来满足 ORDER BY 子句，而不需要额外的排序。WHERE 条件和 ORDER BY 使用相同的索引，并且 ORDER BY 的顺序和索引顺序相同，并且ORDER BY 的字段都是升序或者都是降序。 例如，下列 SQL 可以使用索引： 123SELECT * FROM t1 ORDER BY key_part1,key_part2,... ;SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC; 但是在以下几种情况下则不使用索引: 123456SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;--order by 的字段混合 ASC 和 DESCSELECT * FROM t1 WHERE key2=constant ORDER BY key1;--用于查询行的关键字与 ORDER BY 中所使用的不相同SELECT * FROM t1 ORDER BY key1, key2;--对不同的关键字使用 ORDER BY: 5. 优化嵌套查询MySQL 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性地完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）替代。连接（JOIN）之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 6. MySQL 如何优化 OR 条件对于含有 OR 的查询子句，如果要利用索引，则 OR 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。MySQL 在处理含有 OR字句的查询时，实际是对 OR 的各个字段分别查询后的结果进行了 UNION。 7. 使用 SQL 提示SQL 提示（SQL HINT）是优化数据库的一个重要手段，简单来说就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。 USE INDEX 在查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。 IGNORE INDEX 如果用户只是单纯地想让 MySQL 忽略一个或者多个索引，则可以使用 IGNORE INDEX 作为 HINT。 FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用 FORCE INDEX 作为 HINT。例如，当不强制使用索引的时候，因为 id 的值都是大于 0 的，因此 MySQL 会默认进行全表扫描，而不使用索引,如下所示： 但是，当使用 FORCE INDEX 进行提示时，即便使用索引的效率不是最高，MySQL 还是选择使用了索引，这是 MySQL 留给用户的一个自行选择执行计划的权力。加入 FORCE INDEX 提示后再次执行上面的 SQL： 执行计划中使用了 FORCE INDEX 后的索引。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Sql优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql优化]]></title>
    <url>%2F2018%2F01%2F22%2FdataBase%2Foptimizesql%2F</url>
    <content type="text"><![CDATA[本节针对sql优化的常见优化点做一总结： 一、常见sql语句优化 对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by 涉及的列上建立索引。 避免在where子句中使用is null 或 is not null对字段进行判断。 1select id from table where name is null 在这个查询中，就算我们为 name 字段设置了索引，查询分析器也不会使用，因此查询效率底下。为了避免这样的查询，在数据库设计的时候，尽量将可能会出现 null 值的字段设置默认值，这里如果我们将 name 字段的默认值设置为0，那么我们就可以这样查询： 1select id from table where name = 0 避免在 where 子句中使用 != 或 &lt;&gt; 操作符。 1select name from table where id &lt;&gt; 0 数据库在查询时，对 != 或 &lt;&gt; 操作符不会使用索引，而对于 &lt; 、 &lt;= 、 = 、 &gt; 、 &gt;= 、 BETWEEN AND，数据库才会使用索引。因此对于上面的查询，正确写法应该是： 123select name from table where id &lt; 0union all --这里没有用or连接where后面的两个条件select name from table where id &gt; 0 避免在 where 子句中使用 or来链接条件。 1select id from tabel where name = &apos;UncleToo&apos; or name = &apos;PHP&apos; 这种情况应该这样写： 123select id from tabel where name = &apos;UncleToo&apos;union allselect id from tabel where name = &apos;PHP&apos; 少用 in 或 not in。虽然对于 in 的条件会使用索引，不会全表扫描，但是在某些特定的情况，使用其他方法也许效果更好。如： 1select name from tabel where id in(1,2,3,4,5) 像这种连续的数值，我们可以使用 BETWEEN AND，如： 1select name from tabel where id between 1 and 5 注意 like 中通配符的使用。下面的语句会导致全表扫描，尽量少用。如： 12select id from tabel where name like&apos;%UncleToo%&apos;select id from tabel where name like&apos;%UncleToo&apos; 而下面的语句执行效率要快的多，因为它使用了索引： 1select id from tabel where name like&apos;UncleToo%&apos; 避免在 where 子句中对字段进行表达式操作。 1select name from table where id/2 = 100 正确的写法应该是： 1select name from table where id = 100*2 避免在 where 子句中对字段进行函数操作。 12select id from table where substring(name,1,8) = &apos;UncleToo&apos;select id from table where datediff(day,datefield,&apos;2014-07-17&apos;) &gt;= 0 这两条语句中都对字段进行了函数处理，这样就是的查询分析器放弃了索引的使用。正确的写法是这样的： 12select id from table where name like&apos;UncleToo%&apos;select id from table where datefield &lt;= &apos;2014-07-17&apos; 也就是说，不要在 where 子句中的 = 左边进行函数、算术运算或其他表达式运算。 在子查询中，用 exists 代替 in 是一个好的选择。 1select name from a where id in(select id from b) 但是下面这条语句查询的速度要快的多： 1select name from a where exists(select 1 from b where id = a.id) 结论：in适合B表比A表数据小的情况，exists()适合B表比A表数据大的情况。具体参考：in和exist区别 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么在sex上建了索引也对查询效率起不了作用。 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用varchar代替 char ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 避免频繁创建和删除临时表，以减少系统表资源的消耗。需要使用临时表的时机：当需要重复引用大型表或常用表中的某个数据集时。在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。临时表最好显示的删除，先 truncate table ，然后 drop table ，这样可以避免系统资源占用。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。游标使用时机：对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。 尽量避免向客户端返回大数据量。 inner关联的表可以先查出来，再去关联leftjoin的表 表关联时取别名，也能提高效率 查询多用索引列取查，用charindex或者like[0-9]来代替%% 使用数据仓库的形式，建立单独的表存储数据，根据时间戳定期更新数据。将多表关联的数据集中抽取存入一张表中，查询时单表查询，提高了查询效率。 二、sql查询优化查询速度慢的常见原因 没有索引或者没有用到索引（这是查询慢最常见的问题，是程序设计的缺陷） I/O吞吐量小，形成了瓶颈效应。 没有创建计算列导致查询不优化。 内存不足 。 网络速度慢 。 查询出的数据量过大（可以采用多次查询，其他的方法降低数据量）。 锁或者死锁（这也是查询慢最常见的问题，是程序设计的缺陷）。 sp_lock，sp_who，活动的用户查看，原因是读写竞争资源。 返回了不必要的行和列 。 查询语句不好，没有优化。 优化方法 把数据、日志、索引放到不同的I/O设备上，增加读取速度，数据量（尺寸）越大，提高I/O越重要。 纵向、横向分割表，减少表的尺寸（sp_spaceuse）。 升级硬件，提高网速。 根据查询条件，建立索引，优化索引、优化访问方式，限制结果集的数据量。注意填充因子要适当（最好是使用默认值0）。索引应该尽量小，使用字节数小的列建索引好（参照索引的创建），不要对有限的几个值的字段建单一索引如性别字段。 扩大服务器的内存，Windows 2000和SQL server 2000能支持4-8G的内存。配置虚拟内存：虚拟内存大小应基于计算机上并发运行的服务进行配置。运行 Microsoft SQL Server 2000 时，可考虑将虚拟内存大小设置为计算机中安装的物理内存的 1.5 倍。如果另外安装了全文检索功能，并打算运行 Microsoft 搜索服务以便执行全文索引和查询，可考虑：将虚拟内存大小配置为至少是计算机中安装的物理内存的 3 倍。将 SQL Server max server memory 服务器配置选项配置为物理内存的 1.5 倍（虚拟内存大小设置的一半）。 增加服务器 CPU个数。但是必须明白并行处理串行处理更需要资源例如内存。使用并行还是串行程是MsSQL自动评估选择的。单个任务分解成多个任务，就可以在处理器上运行。例如耽搁查询的排序、连接、扫描和GROUP BY字句同时执行，SQL SERVER根据系统的负载情况决定最优的并行等级，复杂的需要消耗大量的CPU的查询最适合并行处理。但是更新操作Update,Insert， Delete还不能并行处理。 如果是使用like进行查询的话，简单的使用index是不行的，但是全文索引，耗空间。 like ‘a%’ 使用索引 like ‘%a’ 不使用索引用 like ‘%a%’ 查询时，查询耗时和字段值总长度成正比,所以不能用CHAR类型，而是VARCHAR。对于字段的值很长的建全文索引。 DB Server 和APPLication Server 分离；OLTP和OLAP分离 重建索引 DBCC REINDEX ，DBCC INDEXDEFRAG，收缩数据和日志 DBCC SHRINKDB，DBCC SHRINKFILE.。设置自动收缩日志。对于大的数据库不要设置数据库自动增长，它会降低服务器的性能。在T-sql的写法上有很大的讲究，下面列出常见的要点：首先，DBMS处理查询计划的过程是这样的： 查询语句的词法、语法检查 将语句提交给DBMS的查询优化器 优化器做代数优化和存取路径的优化 由预编译模块生成查询规划 然后在合适的时间提交给系统处理执行 最后将执行结果返回给用户其次，看一下SQL SERVER的数据存放的结构：一个页面的大小为8K(8060)字节，8个页面为一个盘区，按照B树存放。 Commit和rollback的区别 ，Rollback：回滚所有的事物。 Commit：提交当前的事物.。没有必要在动态SQL里写事物，如果要写请写在外面如： begin tran exec(@s) commit trans 或者将动态SQL 写成函数或者存储过程。 在查询Select语句中用Where字句限制返回的行数，避免表扫描，如果返回不必要的数据，浪费了服务器的I/O资源，加重了网络的负担降低性能。如果表很大，在表扫描的期间将表锁住，禁止其他的联接访问表，后果严重。 尽可能不使用光标，它占用大量的资源。如果需要row-by-row地执行，尽量采用非光标技术,如：在客户端循环，用临时表，Table变量，用子查询，用Case语句等等。 注意使用DISTINCT，在没有必要时不要用，它同UNION一样会使查询变慢。重复的记录在查询里是没有问题的 。 用select top 100 / 10 Percent 来限制用户返回的行数或者SET ROWCOUNT来限制操作的行 如果要插入大的二进制值到Image列，使用存储过程，千万不要用内嵌Insert来插入(不知JAVA是否)。因为这样应用程序首先将二进制值转换成字符串（尺寸是它的两倍），服务器受到字符后又将他转换成二进制值.存储过程就没有这些动作: 方法：Create procedure p_insert as insert into table(Fimage) values (@image), 在前台调用这个存储过程传入二进制参数，这样处理速度明显改善。 尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL,可以使用临时存储过程，该过程（临时表）被放在Tempdb中。以前由于SQL SERVER对复杂的数学计算不支持，所以不得不将这个工作放在其他的层上而增加网络的开销。SQL2000支持UDFs,现在支持复杂的数学计算，函数的返回值不要太大，这样的开销很大。用户自定义函数象光标一样执行的消耗大量的资源，如果返回大的结果采用存储过程 三、 sql使用规范sql使用规范 尽量避免大事务操作，慎用holdlock子句，提高系统并发能力。 尽量避免反复访问同一张或几张表，尤其是数据量较大的表，可以考虑先根据条件提取数据到临时表中，然后再做连接。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该改写；如果使用了游标，就要尽量避免在游标循环中再进行表连接的操作。 注意where字句写法，必须考虑语句顺序，应该根据索引顺序、范围大小来确定条件子句的前后顺序，尽可能的让字段顺序与索引顺序相一致，范围从大到小。 不要在where子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。 尽量使用“&gt;=”，不要使用“&gt;”。 注意一些or子句和union子句之间的替换。 注意表之间连接的数据类型，避免不同类型数据之间的连接。 注意存储过程中参数和数据类型的关系。 注意insert、update操作的数据量，防止与其他应用冲突。如果数据量超过200个数据页面（400k），那么系统将会进行锁升级，页级锁会升级成表级锁。 索引使用规范 索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引。 尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引。 避免对大表查询时进行table scan，必要时考虑新建索引。 在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用。 要注意索引的维护，周期性重建索引，重新编译存储过程。 临时表的使用规范 尽量避免使用distinct、order by、group by、having、join、cumpute，因为这些语句会加重tempdb的负担。 避免频繁创建和删除临时表，减少系统表资源的消耗。 在新建临时表时，如果一次性插入数据量很大，那么可以使用select into代替create table，避免log，提高速度；如果数据量不大，为了缓和系统表的资源，建议先create table，然后insert。 如果临时表的数据量较大，需要建立索引，那么应该将创建临时表和建立索引的过程放在单独一个子存储过程中，这样才能保证系统能够很好的使用到该临时表的索引。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先truncate table，然后drop table，这样可以避免系统表的较长时间锁定。 慎用大的临时表与其他大表的连接查询和修改，减低系统表负担，因为这种操作会在一条语句中多次使用tempdb的系统表。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Sql优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引实现原理]]></title>
    <url>%2F2018%2F01%2F20%2FdataBase%2Fsqlindex%2F</url>
    <content type="text"><![CDATA[数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。 下图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。 一、局部性原理与磁盘预读由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。 预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 二、B-/+Tree索引的性能分析先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧： 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。 B＋tree 是一个n叉树，每个节点有多个叶子节点，一颗B+树包含根节点，内部节点，叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上叶子节点的节点。B＋tree的性质： n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。 B＋tree结构原型图大概如下： 由于B+tree的性质， 它通常被用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引，因为B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度（B+ 树元素自底向上插入）。 三、SQLS数据访问SQLS访问没有建立索引的数据表SQLS在接到查询请求时，首先会分析sysindexes表中一个叫做索引标志符（INDID：Index ID）的字段的值，如果该值为0，表示这是一张数据表而不是索引表，SQLS就会使用FirstIAM找到该表的IAM页链，也就是所有数据页集合。对于没有索引的表，SQLS在查询时会执行一次全表扫描，即使在第一行找到记录，也会从头到尾扫描一遍。 SQLS访问建立了非聚集索引的数据表非聚集索引可以建多个，具有B树结构，其叶级节点不包含数据页，只包含索引行。假定一个表中只有非聚集索引，则每个索引行包含了非聚集索引键值以及行定位符（ROW ID），它们指向具有该键值的数据行，每一个RID由文件ID、页编号和在页中行的编号组成。 当INDID的值在2至250之间时，意味着表中存在非聚集索引页，此时，SQLS调用root字段的值指向非聚集索引B树的root，在其中查找与被查询最相近的值，根据这个值找到在非叶级节点中的页号，然后顺藤摸瓜在叶级节点相应的页面中找到该值的RID，最后根据这个RID在Heap中定位所在的页和行并返回到查询端。例如：在Lastname上建立了非聚集索引，执行 1select * from member where Lastname = &apos;OTA&apos; 查询过程是： SQLS查询INDID的值为2；–例如图书馆第X排 立即从根出发，在非叶级节点中定位最接近”OTA”的值“Martin”，并查到其位于叶级页面的第61页； 仅在叶级页面的第61页的“Martin”下搜寻”OTA”的RID为N：706:4，表示Lastname字段中名为“OTA”的记录位于堆的第706页的第4行，N表示文件的ID值，与数据无关； 根据上述信息，SQLS将信息找出并显示在前台。视表的数据大小，整个查询过程从百分之几毫秒到数毫秒之间。 SQLS访问建立了聚集索引的数据表在聚集索引中，数据所在的数据页是叶级，索引数据所在的索引也是非叶级。查询原理与非聚集索引相似，但由于记录是按照聚集索引中索引键值进行排序的。也就是说聚集索引的索引键值就是具体的数据页。例：在Lastname字段上建立了聚集索引，则执行： 1select * from member where Lastname = &apos;OTA&apos; 查询过程是： SQLS查询INDID值为1，这是在系统中只建立了聚集索引的标志； 立即从根出发，在非叶级节点中定位最接近”OTA”的值“Martin”，并查到其位于叶级页面的第120页； 在位于叶级页面第120页的Martin下搜寻到“OTA”条目，而这一条目就是数据记录本身； 将该记录返回客户端。 由于同一张表中同时只能按照一种顺序排列，所以聚集索引只能建立一个，并且建立聚集索引需要至少相当于源表120%的附加空间，以存放源表的副本和索引中间页。 SQLS访问既有非聚集索引又有聚集索引的数据表就像在图书馆中，前台卡片柜中可以有不同类别的图书索引卡，然而每张卡片上都载明了那个特殊编号，并不是书籍存放的具体位置。这样在最大程度上既照顾了数据检索的快捷性，又使索引的日常维护变得更加可行，这是最为科学的检索方法。 也就是说，在只建立了非聚集索引的情况下，每个叶级节点指明了记录的行定位符（RID）；而在既有聚集索引又有非聚集索引的情况下，每个叶级节点所指向的是该聚集索引的索引键值，即数据记录本身。例：聚集索引建立在Lastname，非聚集索引建立在Firstname上，则执行： 1select * from member where firstname = &apos;Mike&apos; 查询过程： SQLS查询INDID的值为2； 立即从根出发，在Firstname非聚集索引的非叶级节点中定位最接近”Mike”的值“Jose”条目； 从Jose条目下的叶级页面中查到Mike逻辑位置，不是RID而是聚集索引的指针； 根据这一指针所指示位置，直接进入位于Lastname的聚集索引中的叶级页面中到达Mike数据记录本身； 将该记录返回客户端。 当数据发生更新时，我们只负责对聚集索引的键值维护，而不必考虑非聚集索引，我们只要在ID类的字段上建立聚集索引，而在其他经常需要查询的字段上建立非聚集索引。这样可以体验到索引带来的灵活与快捷，又相对避免了维护索引所导致的大量的额外资源消耗。 四、索引的管理与优化在海量数据的情况下，如果合理的建立了索引，则会大大加强sql的执行查询、对结果进行排序、分组的操作效率。但是索引也有一些先天的不足，系统要占大约为表的1.2倍的硬盘和内存空间来保存索引，更新数据的时候，系统必须要有额外的时间来同时对索引进行更新，以维持数据和索引的一致性。所以建立索引一定要在加快查询速度和降低修改速度之间做好平衡。SQLS维护索引消耗的资源，以及面对索引的管理与优化可以从下面六个方面入手： 页分裂微软MOC教导我们：当一个数据量达到8K容量，如果此时发生插入 或更新数据的操作，将导致页的分裂： 有聚集索引的情况下：聚集索引将被插入和更新的行指向特定的页，该页由聚集索引关键字决定。 只有堆的情况下：只要有空间就可以插入新的行，但是如果我们对行数据的更新需要更多的空间，以致大于当前页的可用空间，行就被移到新的页中，并且在原位置留下一个转发指针，指向被移动的新行，如果具有转发指针的行又被移动了，那么原来的指针将重新指向新的位置。 如果堆中有非聚集索引，那么尽管插入和更新操作在堆中不会发生页分裂，但是在非聚集索引上仍然产生页分裂。 无论有无索引，大约一半的数据将保留在老页面，而另一半数据将放入新的页面，并且新页面可能被分配到任何可用的页。所以频繁页分裂，后果很严重，将是物理表产生大量数据碎片，导致直接造成I/O效率的急剧下降，最后，需要重建索引。 填充因子在创建索引时，可以为这个索引指定一个填充因子，以便在索引的每个叶级页面上保留一定百分比的空间，将来数据可以进行扩充和减少页分裂。填充因子是从0到100的百分比数值，设为100时表示将数据页填满，只有当不会对数据进行更改时（只读）才用此值。值越小则数据页上的空闲空间越大，这样可以减少在索引增长过程中进行页分裂的需要，但这一操作需要占用更多的硬盘空间。 填充因子只在创建索引时执行，索引创建以后，当表中进行数据的添加、删除或更新操作时，是不会保持填充因子的，因此当表中的数据进行了较大的变动，这时可以从容的重建索引，重新指定填充因子，重新分布数据。 填充因子指定不当，就会降低数据库的读取的性能，其降低量与填充因子设置值成反比。例如：当填充因子的值为50，数据库的读取性能就会降低两倍。 两道数学题当建立了众多的索引，在查询工作中SQLS就只能按照“最高指示”用索引处理每一个提交的查询呢？实际上SQLS几乎完全是“自主”的决定是否使用索引或使用哪一个索引。下面看两个例子： 如果某表的一条记录在磁盘上占用1000字节（1K）的话，我们对其中10字节的一个字段建立索引，那么该记录对应的索引大小只有10字节（0.01K）。SQLS的最小空间分配单元是页（page），一个页面在磁盘上占用8K空间，所以一页只能存储8条记录，但可以存储800条索引。现在我们要从一个有800条记录的表中检索符合某个条件的记录，如果没有索引的话，我们需要遍历8000条X1000字节/8K字节=1000个页面才能够找到结果。如果在检索字段上有上述索引的话，那么我们可以在8000条X10字节/8K字节=10个页面中就能检索到满足条件的索引块，然后根据索引块上的指针逐一找到结果数据块，这样I/O访问量肯定要少得多。 然而有时用索引比不上不用索引快。 同上，如果要无条件检索全部记录（不用where语句），不用索引的话需要访问8000条X1000字节/8K字节=1000个页面；而使用索引的话，首先检索索引，访问8000条X10字节/8K字节=10个页面得到索引检索结果，再根据索引结果去对应数据页面，由于是检索全部数据，所以需要再访问8000条X1000字节/8K字节=1000个页面将全部数据读取出来，一共访问了1010个页面，这显然不如不用索引快。 SQLS内部有一套完整的数据索引优化技术，在上述情况下，SQLS会自动使用表扫描的方法检索数据而不会使用任何索引。SQLS知道什么时候用索引，什么时候不用索引是因为SQLS除了维护数据信息外，还维护着数据统计信息。 统计信息在企业管理器–&gt;Database–&gt;Northwind数据库–&gt;单击“属性”–&gt;选择“Options”选项卡，观察“Settings”下的各项复选项，从Settings中我们可以看到，在数据库中，SQLS将默认的自动创建和更新统计信息，这些统计信息包括数据密度和分布信息，正是它们帮助SQLS确定最佳的查询策略：建立查询计划和是否使用索引以及使用什么样的索引。 在创建索引时，SQLS会创建分布数据页来存放有关索引的两种统计信息：分布表和密度表。查询优化器使用这些统计信息估算使用该索引进行查询的成本（Cost），并在此基础上判断引用对某个特定查询是否有用。 随着表中的数据发生变化，SQLS自动定期更新这些统计信息。统计更新的频率取决于字段或索引中的数据量以及数据更改量。例如：对于一万条记录的表，当1000个索引值发生改变时该表的统计信息可能需要更新。 索引的人工维护当数据变化达到某一程度时将会影响到索引的使用，这时需要对索引进行维护。随着数据行的插入、删除和数据页的分裂，有些索引页可能只包含几页数据，另外应用在执行大量I/O的时候，重建非聚集索引可以维护I/O的效率。重建索引实际上是重现组织B树。需要重建索引的情况有： 数据和使用模式大幅度变化； 排序的顺序发生改变； 要进行大量插入操作或已经完成； 使用I/O查询的磁盘读次数比预料的要多； 由于大量数据修改，使得数据页和索引页没有充分使用而导致空间的使用超出估算； dbcc检查出索引有问题 索引的使用原则先认识下索引的两个重要属性：唯一性索引和复合性索引。 唯一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据。如果表中已经有一个主键约束或者唯一性约束，那么当创建表或者修改表时，SQLS自动创建一个唯一性索引。但出于必须保证唯一性，那么应该创建主键约束或者唯一性约束，而不是创建一个唯一性索引。 复合索引就是一个索引创建在两个列或者多个列上。在搜索时，当两个或者多个列作为一个关键值时，最好在这些列上创建复合索引。当创建复合索引时，应该考虑这些规则： 最多可以把16个列合并成一个单独的复合索引，构成复合索引的列的总长度不能超过900字节； 在复合索引中，所有列必须来自同一张表，不能跨表建立复合列； 在复合索引中，列的排列顺序是非常重要的，原则上，应该首先定义最唯一的列； 为了是查询优化器使用复合索引，查询语句中的where子句必须参考复合索引中第一列。 综上总结下索引的使用原则： 逻辑主键使用唯一的成组索引，对系统键（作为存储过程）采用唯一的非成组索引，对任何外键列采用非成组索引。考虑数据库的空间有多大，表如何进行访问，还有这些访问是否主要用作读写； 不要索引memo/note字段，不要索引大型字段（有很多字符），这样作会让索引占用太多的存储空间； 不要索引常用的小型表； 不要为小型数据表设置过多的索引，如果经常有插入和删除操作就更不要设置索引，因为SQLS对插入和删除提供的索引维护可能比扫描表空间消耗的时间更多。 查询是一个物理过程，表面上是SQLS在东跑西跑，其实真正大部分压马路的工作是由磁盘输入输出系统（I/O）完成，全表扫描需要从磁盘上读取每一个数据页，如果有索引指向数据值，则I/O读几次磁盘就可以。但是在随着发生的增、删、改操作中，索引的存在会大大增加工作量，因此，合理的索引设计是建立在对各种查询的分析和预测上的，只有正确地使用索引与程序结合起来，才能产生最佳的优化方案。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Sql优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis命令]]></title>
    <url>%2F2018%2F01%2F13%2Fredis%2Frediscommand%2F</url>
    <content type="text"><![CDATA[字符串Redis的字符串就是一个由字节组成的序列，在Redis里面，字符串可以存储以下3中类型的值： 字节串（byte string） 整数 浮点数 自增自减操作Redis对字符串执行自增和自减的命令： 命令 用例和描述 INCR INCR key-name ———将键存储的值加1 DECR DECR key-name ———将键存储的值减去1 INCRBY INCRBY key-name amount ——-将键存储的值加上整数amount DECRBY DECRBY key-name amount ——-将键存储的值减去整数amount INCRBYFLOAT INCRBYFLOAT key-name amount ——-将键存储的值加上浮点数amount，redis2.6及以上可用 注意： 当存储在redis字符串里面的值可以被解释（interpret）为十进制整数或者浮点数时，redis允许用户对这个字符串执行各种INCR和DECR操作； 当用户对一个不存在的键或者保存了空串的键执行自增或者自减操作，则redis会将这个键当作0来处理； 当用户尝试对一个值无法解释为整数或者浮点数的字符串键执行自增或者自减操作，则redis会返回一个错误。 Redis的INCR和DECR操作示例： 12345678Jedis conn = new Jedis("localhost");conn.get('key'); //尝试获取一个不存在的键将得到一个none值，不显示conn.incr('key'); //1conn.incr('key',15); //16conn.decr('key',5); //11conn.get('key'); //'11'conn.set('key',13); //trueconn.incr('key'); //14 Redis对字符串进行读取和写入操作Redis处理子串和二进制位的命令： 命令 用例和描述 APPEND APPEND key-name value —将值value追加到给定键key-name当前存储的值的末尾 GETRANGE GETRANGE key-name start end —获取一个由偏移量start至end范围内的子串，包含start和end在内 SETRANGE SETRANGE key-name offset value —将从offset偏移量开始的子串设置为给定值 GETBIT GETBIT key-name offset — 将字节串看作是二进制位串（bit string），并返回位串中偏移量为offset的二进制位的值 SETBIT SETBIT key-name offset value — 将字节串看作是二进制位串，并将位串中偏移量为offset的二进制位的值设置为value BITCOUNT BITCOUNT key-name [start end] — 统计二进制位串中值为1的二进制位的数量 BITOP BITOP operation dest-key key-name [key-name …] — 对一个或多个二进制位串执行包括并（AND）、或（OR）、异或（XOR）、非（NOT）在内的任意一种按位运算操作（bitwise operation），并将计算得出的结果保存在dest-key键里面 注意： redis现在的GETRANGE命令是由以前的SUBSTR命令改写而来的，因此，Python现在仍然可以使用substr()方法来获取子串； 在使用SETRANGE或者SETBIT命令对字符串进行写入的时候，如果字符串当前的长度不能满足写入的要求，那么redis会自动地使用空字节null来将字符串扩展至所需的长度，然后才执行写入或者更新操作。 在使用GETRANGE读取字符串的时候，超出字符串末尾的数据会被视为是空串，而在使用GETBIT读取二进制位串的时候，超出字符串末尾的二进制位会被视为是0。 Redis的子串操作和二进制位操作示例： 12345678910111213141516171819202122//将'hello'追加到目前并不存在的'new-string-key'键里conn.append('new-string-key', 'hello '); //返回6L，append命令会在执行之后返回字符串当前的长度conn.append('new-string-key', 'world!'); //12L//redis的索引以0开始，范围的终点（endpoint）默认包含在这个范围conn.substr('new-string-key', 3, 7); //'lo wo'//将h和w从小写改成大写conn.setrange('new-string-key', 0, 'H'); //12 ，setrange命令会在执行之后同样返回字符串当前总长度conn.setrange('new-string-key', 6, 'W'); //12conn.get('new-string-key'); //'Hello World!'//setrange命令既可以用于替换字符串里已有的内容，又可以增长字符串conn.setrange('new-string-key', 11, ', how are you?'); //25conn.get('new-string-key'); //'Hello World, how are you?'//在对redis存储的二进制位进行解释（interpret）时，记住redis存储的二进制位是按照偏移量从高到低排列的conn.setbit('another-key', 2, 1); //0, setbit命令会返回二进制位被设置之前的值conn.setbit('another-key', 7, 1); //0//通过将第2个二进制位以及第7个二进制位的值设置为1，键的值将变为'!'，也就是编码为33的字符conn.get('another-key'); //'!' Redis通过使用子串操作和二进制位操作，配合WATCH命令、MULTI命令和EXEC命令，用户可以自己动手去构建任何他们想要的数据结构。 列表列表是由多个字符串组成的有序序列结构。Redis的列表允许用户从序列的两端推入或者弹出元素，获取列表元素，以及执行各种常见的列表操作。除此之外，列表还可以用来存储任务信息、最近浏览过的文章或者常用联系人信息。 一些常用的列表命令： 命令 用例和描述 RPUSH RPUSH key-name value [value …] — 将一个或多个值推入列表的右端 LPUSH LPUSH key-name value [value …] — 将一个或多个值推入列表的左端 RPOP RPOP key-name — 移除并返回列表最右端的元素 LPOP LPOP key-name — 移除并返回列表最左端的元素 LINDEX LINDEX key-name offset — 返回列表偏移量为offset的元素 LRANGE LRANGE key-name start end — 返回[start, end]范围内的所有元素 LTRIM LTRIM key-name start end — 对列表进行修剪，只保留[start, end]范围内的元素 常用命令示例： 1234567891011121314conn.rpush('list-key', 'last'); //1L 向列表推入元素，执行完毕会返回列表当前的长度conn.lpush('list-key', 'first'); //2Lconn.rpush('list-key', 'new last');conn.lrange('list-key', 0, -1); //['first', 'last', 'new last']//通过重复地弹出列表左端的元素，可以按照从左到右的顺序来获取列表中的元素conn.lpop('list-key'); //'first'conn.lpop('list-key'); //'last' conn.lrange('list-key', 0, -1); //['new last']//可以同时推入多个元素conn.rpush('list-key', 'a','b','c'); //4Lconn.lrange('list-key', 0, -1); //['new last','a','b','c']conn.ltrim('list-key', 2, -1) //true conn.lrange('list-key', 0, -1); //['b','c'] 组合使用LTRIM和LRANGE可以构建一个在功能上类似于LPOP或RPOP，但能够一次返回并弹出多个元素的操作。下面的几个列表命令可以将元素从一个列表移动到另一个列表，或者阻塞（block）执行命令的客户端直到有其他客户端给列表添加元素为止。 阻塞式的列表弹出命令以及在列表之间移动元素的命令： 命令 用例和描述 BLPOP BLPOP key-name [key-name …] timeout — 从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现 BRPOP BRPOP key-name [key-name …] timeout — 从第一个非空列表中弹出位于最右端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现 RPOPLPUSH RPOPLPUSH source-key dest-key — 从source-key 列表中弹出最右端的元素，然后将这个元素推入dest-key 列表的最左端，并向用户返回这个元素 BRPOPLPUSH BRPOPLPUSH source-key dest-key timeout — 从source-key 列表中弹出最右端的元素，然后将这个元素推入dest-key 列表的最左端，并向用户返回这个元素；如果source-key为空，那么在timeout秒之内阻塞并等待可弹出的元素出现 阻塞式命令示例： 12345678910111213141516conn.rpush('list', 'item1'); //1conn.rpush('list', 'item2'); //2conn.rpush('list2', 'item3'); //1//将一个元素从一个列表移动到另一个列表，并返回被移动的元素conn.brpoplpush('list2', 'list', 1); //'item3'//当列表不包含任何元素时，阻塞弹出操作会在给定的时限内等待可弹出的元素的出现，并在时限到达后返回Noneconn.brpoplpush('list2', 'list', 1); conn.lrange('list', 0, -1); //['item3','iten1','item2']conn.brpoplpush('list', 'list2', 1); //'item2'//blpop命令会从左至右地检查传入的列表，并对最先遇到的非空列表执行弹出操作conn.blpop(['list', 'list2'], 1); //('list', 'item3')conn.blpop(['list', 'list2'], 1); //('list', 'item1')conn.blpop(['list', 'list2'], 1); //('list2', 'item2')conn.blpop(['list', 'list2'], 1); 对于阻塞弹出命令和弹出并推入命令，最常见的用例就是消息传递（messaging）和任务队列（task queue）。列表的一个主要优点在于它可以包含多个字符串值，这使得用户可以将数据集中在同一个地方。Redis的集合也提供了与列表类似的特性，但集合只能保存各不相同的元素。 集合Redis的集合以无序的方式来存储多个各不相同的元素，用户可以快速地对集合执行添加元素操作、移除元素操作以及检查一个元素是否存在于集合里。 一些常用的集合命令： 命令 用例和描述 SADD SADD key-name item [item … ] — 将一个或多个元素添加到集合里面，并返回被添加元素当中原本并不存在于集合里面的元素数量 SREM SREM key-name item [item … ] — 从集合里面移除一个或多个元素，并返回被移除元素的数量 SISMEMBER SISMEMBER key-name item — 检查元素是否存在于集合key-name里 SCARD SCARD key-name — 返回集合包含的元素的数量 SMEMBERS SMEMBERS key-name — 返回集合包含的所有元素 SRANDMEMBER SRANDMEMBER key-name [count] — 从集合里面随机地返回一个或多个元素。当count为正数时，命令返回的随机元素不会重复，当count为负数时，命令返回的随机元素可能会出现重复 SPOP SPOP key-name — 随机地移除集合中的一个元素，并返回被移除的元素 SMOVE SMOVE source-key dest-key item — 如果集合source-key包含元素item，那么从集合source-key里面移除元素item，并将元素item添加到集合dest-key中；成功返回1，否则返回0 redis集合示例： 123456789conn.sadd('set-key', 'a', 'b', 'c'); //3 --返回被添加元素的数量conn.srem('set-key', 'c', 'd'); //1 --返回被移除元素的数量conn.srem('set-key', 'c', 'd'); //0conn.scard('set-key'); //2conn.smembers('set-key'); //set(['a', 'b'])//将元素移动到另一个集合conn.smove('set-key', 'set-key2', 'a'); //trueconn.smove('set-key', 'set-key2', 'c'); //falseconn.smembers('set-key'); //set(['a']) 用于组合和处理多个集合的Redis命令： 命令 用例和描述 SDIFF SDIFF key-name [key-name …] — 返回那些存在于第一个集合、但不存在于其他集合中的元素（差集运算） SDIFFSTORE SDIFFSTORE dest-key key-name [key-name … ] — 将差集运算存储到dest-key键里面 SINTER SINTER key-name [key-name …] — 返回那些同时存在于所有集合中的元素（交集运算） SINTERSTORE SINTERSTORE dest-key key-name [key-name … ] — 将交集运算存储到dest-key键里面 SUNION SUNION key-name [key-name …] — 返回那些至少存在于一个集合中的元素（并集运算） SUNIONSTORE SUNIONSTORE dest-key key-name [key-name … ] — 将并集运算存储到dest-key键里面 redis的差集、交集、并集示例： 12345conn.sadd('skey1', 'a', 'b', 'c', 'd'); //4conn.sadd('skey2', 'c', 'd', 'e', 'f'); //4conn.sdiff('skey1', 'skey2'); // set(['a', 'b'])conn.sinter('skey1', 'skey2'); // set(['c', 'd'])conn.sunion('skey1', 'skey2'); // set(['a', 'b', 'c', 'd', 'e', 'f']) 散列Redis的散列可以让用户将多个键值对存储到一个Redis键里面。 用于添加和删除键值对的散列操作： 命令 用例和描述 HMGET HMGET key-name key [key … ] — 从散列获取一个或多个键的值 HMSET HMSET key-name key value [key value … ] — 为散列里面的一个或多个键设置值 HDEL HDEL key-name key [key …] — 删除散列里面的一个或多个键值对，返回成功找到并删除的键值对数量 HLEN HLEN key-name — 返回散列包含的键值对数量 hlen命令用于一次读取或者设置多个键的hmget和hmset，像hmget和hmset这种批量处理多个键的命令既可以给用户带来方便，又可以通过减少命令的调用次数以及客户端与Redis之间的通信往返次数来提升Redis的性能。 redis散列命令示例： 123456conn.hmset('hash-key', &#123;'k1':'v1', 'k2':'k2', 'k3':'k3'&#125;); //trueconn.hmget('hash-key', ['k2', 'k3']); //['v2', 'v3']//hlen命令通常用于调试一个包含非常多键值对的散列conn.hlen('hash-key'); //3//hdel命令在成功地移除了至少一个键值对时返回trueconn.hdel('hash-key', 'k1', 'k3'); //true redis更高级特性： 命令 用例和描述 HEXISTS HEXISTS key-name key — 检查给定键是否存在于散列中 HKEYS HKEYS key-name — 获取散列包含的所有键 HVALS HVALS key-name — 获取散列包含的所有值 HGETALL HGETALL key-name — 获取散列包含的所有键值对 HINCRBY HINCRBY key-name key increment — 将键key存储的值加上整数increment HINCRBYFLOAT HINCRBYFLOAT key-name key increment — 将键key存储的值加上浮点数increment 尽管有hgetall存在，但hkeys和hvals也是很有用，如果散列包含的值非常大，那么用户可以先使用hkeys取出散列包含的所有键，然后再使用hget一个一个地取出键的值，从而避免一次获取多个大体积的值而导致服务器阻塞。hincrby和hincrbyfloat类似于处理字符串的incrby和incrbyfloat，区别就是前者处理散列，后者处理字符串。 散列高级特性示例： 123456conn.hmset('hash-key2', &#123;'short':'hello', 'long':1000*'1'&#125;); //trueconn.hkeys('hash-key2'); //['long', 'short']conn.hexists('hash-key2', 'num'); //false//和字符串一样，对散列中尚未存在的键执行自增操作时，redis会将键的值当作0来处理conn.hincrby('hash-key2', 'num'); //1Lconn.hexists('hash-key2', 'num'); //true 有序集合和散列存储着键与值之间的映射类似，有序集合也存储着成员与分值之间的映射，并且提供了分值处理命令，以及根据分值大小有序地获取（fetch）或扫描（scan）成员和分值的命令。 一些常用的有序集合命令： 命令 用例和描述 ZADD ZADD key-name score member [score member … ] — 将带有给定分值的成员添加到有序集合里面 ZREM ZREM key-name member [member … ] — 从有序集合里面移除给定的成员，并返回被移除成员的数量 ZCARD ZCARD key-name — 返回有序集合包含的成员数量 ZINCRBY ZINCRBY key-name increment member — 将member成员的分值加上increment ZCOUNT ZCOUNT key-name min max — 返回分值介于min和max之间的成员数量 ZRANK ZRANK key-name member — 返回成员member在有序集合中的排名 ZSCORE ZSCORE key-name member — 返回成员member的分值 ZRANGE ZRANGE key-name start stop [WITHSCORES] — 返回有序集合中排名介于start和stop 之间的成员，如果给定了WITHSCORES选项，则将分值一并返回 redis有序集合示例： 12345678910conn.zadd('zset-key', 3, 'a', 2, 'b', 1, 'c'); //3conn.zcard('zset-key'); //3conn.zincrby('zset-key', 'c', 3); //4.0//获取单个成员的分值对于实现计数器或者排行榜之类的功能非常有用conn.zscore('zset-key', 'b'); //2.0//排名以0开始conn.zrank('zset-key', 'c'); //2conn.zcount('zset-key', 0, 3); //2Lconn.zrem('zset-key', 'b'); //trueconn.zrange('zset-key', 0, -1, withscores); //[('a', 3.0), ('c', 4.0)] 有序集合的范围型数据获取和删除命令以及并集、交集命令： 命令 用例和描述 ZREVRANK ZREVRANK key-name member — 返回有序集合里成员member的排名，成员按照分值从大到小排列（逆序） ZREVRANGE ZREVRANGE key-name start stop [WITHSCORES] — 返回有序集合给定排名范围内的成员 ZRANGEBYSCORE ZRANGEBYSCORE key min max [WITHSCORES]\ [LIMIT offset count]返回有序集合中分值介于min和max之间的所有成员 ZREVRANGEBYSCORE ZREVRANGEBYSCORE key max min [WITHSCORES]\ [LIMIT offset count]获取有序集合中分值介于min和max之间的所有成员，并按分值从大到小的顺序来返回它们 ZREMRANGEBYRANK ZREMRANGEBYRANK key-name start stop — 移除有序集合中排名介于start和stop之间的所有成员 ZREMRANGEBYSCORE ZREMRANGEBYSCORE key-name min max — 移除有序集合中分值介于min和max之间的所有成员 ZINTERSTORE ZINTERSTORE dest-key key-count key [key … ] \ [WEIGHTS weight [weight … ]] \ [AGGREGATE SUM\ MIN\ MAX] — 对给定的有序集合执行类似于集合的交集运算 ZUNIONSTORE ZUNIONSTORE dest-key key-count key [key … ] \ [WEIGHTS weight [weight … ]] \ [AGGREGATE SUM\ MIN\ MAX] — 对给定的有序集合执行类似于集合的并集运算 ZINTERSTORE和ZUNIONSTORE命令示例： 1234567891011conn.zadd('zset-1', 1, 'a', 2, 'b', 3, 'c'); //3conn.zadd('zset-1', 4, 'b', 1, 'c', 0, 'd'); //3conn.zinterstore('zset-i', ['zset-1', 'zset-2']); //2L//默认使用的聚合函数是SUMconn.zrange('zset-i', 0, -1, withscore=true); //[(4.0, 'c'), (6.0, 'b')]conn.zunionstore('zset-u', ['zset-1', 'zset-2'], aggregate='min'); //4Lconn.zrange('zset-u', 0, -1, withscore=true); //[(0.0, 'd'), (1.0, 'a'), (1.0, 'c'), (2.0, 'b')]//用户还可以把集合作为输入传给zinterstore和zunionstore，命令会将集合看作是成员分值全为1的有序集合来处理conn.sadd('set-1', 'a', 'b'); //2conn.zunionstore('zset-u2', ['zset-1', 'zset-2', 'set-1']); //4Lconn.zrange('zset-u2', 0, -1, withscore=true); //[(1.0, 'd'), (2.0, 'a'), (4.0, 'c'), (6.0, 'b')] 发布与订阅发布与订阅（publish/subscribe）模式，又称pub/sub模式，redis也实现了这种模式。发布与订阅特点是订阅者（listener）负责订阅频道（channel），发送者（publisher）负责向频道发送二进制字符串消息（binary string message）。每当有消息被发送至给定频道时，频道的所有订阅者都会收到消息。 redis提供的发布与订阅命令： 命令 用例和描述 SUBSCRIBE SUBSCRIBE channel [channel … ] — 订阅给定的一个或多个频道 UNSUBSCRIBE UNSUBSCRIBE [channel [channel … ]] — 退订给定的一个或多个频道，如果执行时没有给定频道则退订所有频道 PUBLISH PUBLISH channel message — 向给定频道发送消息 PSUBSCRIBE PSUBSCRIBE pattern [pattern … ] — 订阅与给定模式相匹配的所有频道 PUNSUBSCRIBE PUNSUBSCRIBE [pattern [pattern … ]] — 退订给定的模式，如果执行时没有给定频道则退订所有模式 redis提供的发布与订阅很少用有两个原因： redis系统的稳定性有关。对于旧版redis，当用户读取速度慢导致消息积压，会使得redis输出缓冲区体积变大，导致redis速度变慢甚至奔溃，新版会设置client-output-buffer-limit pubsub选项，会自动断开不符合要求的订阅客户端。 数据传输的可靠性有关。客户端在执行订阅的过程中断线则会丢失断线期间发送的消息。后面总结解决方法。 排序Redis的排序操作和其他编程语言的排序操作一样，都可以根据某种比较规则对一系列元素进行有序的排列。负责执行排序操作的SORT命令可以根据字符串、列表、集合、有序集合、散列这5种键里面存储着的数据，对列表、集合以及有序集合进行排序。SORT命令的定义： 命令 用例和描述 SORT SORT source-key [BY pattern] \ [LIMIT offset count] \ [get pattern [get pattern … ]] \ [ASC\ DESC] \ [ALPHA] \ [STORE dest-key] — 根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果 使用SORT命令提供的选项可以实现以下功能： 根据降序而不是默认的升序来排序元素； 将元素看作是数字来进行排序，或者将元素看作是二进制字符串来进行排序； 使用被排序元素之外的其他值作为权重来进行排序，甚至还可以从输入的列表、集合、有序集合以外的其他地方进行取值。 SORT命令示例： 1234567891011121314conn.rpush('sort-input', 23, 15, 110, 7); //4//根据数字大小排序conn.sort('sort-input'); //['7', '15', '23', '110']//根据字母表顺序排序conn.sort('sort-input', alpha=true); //['110', '23', '15', '7']//添加一些用于执行排序操作和获取操作的附加数据conn.hset('d-7', 'field', 5); //1Lconn.hset('d-15', 'field', 1); //1Lconn.hset('d-23', 'field', 9); //1Lconn.hset('d-110', 'field', 3); //1L//将散列的域（field）用作权重，对sort-input列表进行排序conn.sort('sort-input', by='d-*-&gt;field'); //['15', '110', '7', '23']//获取外部数据，并将它们用作命令的返回值，而不是返回被排序的数据conn.sort('sort-input', by='d-*-&gt;field', get='d-*-&gt;field'); //['1', '3', '5', '9'] SORT是redis唯一一个可以同时处理3种不同类型的数据的命令，但基本的redis事务同样可以让我们在一连串不间断执行的命令里面操作多种不同类型的数据。 基本的Redis事务Redis的基本事务（basic transaction）需要用到MULTI命令和EXEC命令，这种事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令。Redis有5个命令可以让用户在不被打断（interruption）的情况下多个键执行操作，它们分别是WATCH、MULTI、EXEC、UNWATCH和DISCARD。和关系数据库那种可以在执行的过程中进行回滚（rollback）的事务不同，在redis里面，被multi命令和exec命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。当一个事务执行完毕之后，redis才会处理其他客户端的命令。 在redis里面执行事务，当redis从一个客户端那里接收到multi命令时，redis会将这个客户端之后发送的所有命令都放到一个队列里面，直到这个客户端发送exec命令为止，然后redis就会在不被打断的情况下，一个接一个地执行存储在队列里面的命令。 说明： multi和exec事务的一个主要作用是移除竞争条件； 在redis里面使用流水线的另一个目的是提高性能，在执行一连串命令时，减少redis与客户端之间的通信往返次数可以大幅度降低客户端等待回复所需要的时间。 键的过期时间过期时间特性对于清理缓存数据非常有用，但是只有少数几个命令可以原子地为键设置过期时间，并且对于列表、集合、散列和有序集合这样的容器（container）来说，键的过期时间命令只能为整个键设置而没有办法为键里面的单个元素设置过期时间，为了解决这个问题，我们可以用存储时间戳的有序集合来实现针对单个元素的过期时间。用于处理过期时间的redis命令： 命令 示例和描述 PERSIST PERSIST key-name — 移除键的过期时间 TTL TTL key-name — 查看给定键距离过期时间还有多少秒 EXPIRE EXPIRE key-name seconds — 让给定键在指定的秒数之后过期 EXPIREAT EXPIREAT key-name timestsmp — 将给定键的过期时间设置为给定的UNIX时间戳 PTTL PTTL key-name 查看给定键距离过期时间还有多少毫秒 PEXPIRE PEXPIRE key-name milliseconds — 让给定键在指定的毫秒数之后过期 PEXPIREAT PEXPIREAT key-name timestsmp-milliseconds — 将一个毫秒级精度的UNIX时间戳设置为给定键的过期时间 redis过期时间命令示例： 1234567conn.set('key', 'value'); //trueconn.get('key'); //'value'conn.expire('key', 2); //truetime.sleep(2);conn.get('key');conn.set('key', 'value2'); //trueconn.expire('key', 100); conn.ttl('key'); //true 100]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构]]></title>
    <url>%2F2018%2F01%2F08%2Fredis%2FredisBasics%2F</url>
    <content type="text"><![CDATA[Redis简介Redis是一个速度非常快的非关系数据库（non-relational database），它能够自动以两种不同的方式将数据写入硬盘，可以存储键与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能。Redis不使用表，它的数据库也不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。 分片是一种将数据划分为多个部分的方法，对数据的划分可以基于键包含的ID、基于键的散列值，或者基于以上两者的某种组合。通过对数据进行分片，用户可以将数据存储到多台机器里面，也可以从多台机器里面获取数据，这种方法在解决某些问题时可以获得线性级别的性能提升。 一些数据库和缓存服务器的对比： 名称 类型 数据存储选项 查询类型 附加功能 Redis 使用内存存储（in-memory）的非关系数据库 字符串、列表、集合、散列表、有序集合 每种数据类型的专属命令，批量操作（bulkoperation）和不完全（partial）的事务支持 发布与订阅，主从复制（master/slave replication），持久化，脚本（存储过程） memcached 使用内存存储的键值缓存 键值之间的映射 创建、读取、更新、删除以及其他几个命令 为提升性能而设的多线程服务器 MySQL 关系数据库 可以处理多个表的视图，支持空间（spatial）和第三方扩展 函数、存储过程 支持ACID性质（需要使用InnoDB），主从复制和主主复制 PostgreSQL 关系数据库 支持可定制类型 内置函数、自定义的存储过程 支持ACID性质，主从复制，由第三方支持的多主复制（multi-master replication） MongoDB 使用硬盘存储（on-disk）的非关系文档存储 每个表可以包含多个无schema的BSON文档 创建、读取、更新、删除、条件查询命令等 支持map-reduce操作，主从复制，分片，空间索引（spatial index） 当服务器被关闭时，服务器存储的数据将何去何从？ Redis拥有两种持久化方法，用小而紧凑的格式将存储在内存中的数据写入硬盘： 时间点转储（point-in-time dump）：转储操作既可以在“指定时间段内有指定数量的写操作执行”这一条件被满足时执行；又可以通过调用两条转储到硬盘命令中的任何一条来执行； 追加：将所有修改了数据库的命令都写入一个只追加（append-only）文件里面，用户可以根据数据的重要程度，将只追加写入设置为从不同步（sync）、每秒同步一次或者每写入一个命令就同步一次。 Redis实现了主从复制： 执行复制的从服务器会连接上主服务器，接受主服务器发送的整个数据库的初识副本（copy）；之后主服务器执行的写命令，都会被发送到所有连接着的从服务器去执行，从而实时地更新从服务器的数据集。因为从服务器包含的数据会不断地进行更新，所以客户端可以向任意一个从服务器发送读请求，以此来避免对主服务器进行集中式的访问。 Redis数据结构Redis提供的5中结构： 结构类型 结构存储的值 结构的读写能力 STRING 可以是字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增（increment）或者自减（decrement）操作 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪（trim）；读取单个或者多个元素；根据值查找或者移除元素 SET 包含字符串的无序收集器（unordered collection），并且被包含的每个字符串都是独一无二、各不相同 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合中随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对；获取所有的键值对 ZSET 字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定 添加、获取、删除单个元素；根据分值范围（range）或者成员来获取元素 字符串Redis的字符串和其他键值存储提供的字符串类似。 字符串命令： 命令 行为 GET 获取存储在给定键中的值 SET 设置存储在给定键中的值 DEL 删除存储在给定键中的值 使用示例： 列表Redis支持链表结构。一个列表结构可以有序地存储多个字符串。 列表命令： 命令 行为 RPUSH/LPUSH 将给定值推入列表的右端/左端 LRANGE 获取列表在给定范围上的所有值 LINDEX 获取列表在给定位置上的单个元素 LPOP/RPOP 从列表的左端/右端弹出元素 使用示例： 说明： 在向列表推入新元素之后，rpush命令会返回列表当前的长度； 使用0为范围的起始索引，-1为范围的结束索引，可以取出列表包含的所有元素； 从列表里面弹出一个元素，被弹出的元素将不再存在于列表。 集合Redis的集合和列表都可以存储多个字符串，它们之间的不同在于，列表可以存储多个相同的字符串，而集合则通过使用散列表来保证存储的字符串各不相同（这些散列表只有键，但没有与键相关联的值）。 集合命令： 命令 行为 SADD 将给定元素添加到集合 SMEMBERS 返回集合包含的所有元素 SISMEMBER 检查给定的元素是否存在于集合中 SREM 如果给定的元素存在于集合中，移除这个元素 使用示例： 说明： 添加元素到集合，返回命令1表示成功，0表示该元素已经存在； 使用命令移除集合中元素时，命令会返回被移除元素的数量。 散列表Redis的散列可以存储多个键值之间的映射。和字符串一样，散列存储的值既可以是字符串也可以是数字值，并且用户可以对散列存储的数字值执行自增或自减操作。 散列命令： 命令 行为 HSET 在散列里面关联起给定的键值对 HGET 获取指定散列键的值 HGETALL 获取散列包含的所有键值对 HDEL 移除给定键 使用示例： 说明： 在添加/删除键值对在散列表时，命令会返回一个值来表示添加/删除之前是否存在于散列表里面。 有序集合有序集合和散列一样，都用于存储键值对。有序集合的键被称为成员（member），每个成员都是各不相同的；有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是Redis里面唯一一个既可以根据成员访问元素（和散列一样），又可以根据分值以及分值的排序顺序来访问元素的结构。 有序集合命令： 命令 行为 ZADD 将一个带有给定分值的成员添加到有序集合里面 ZRANGE 根据元素在有序排序中所处的位置，从有序集合里面获取多个元素 ZRANGEBYSCORE 获取有序集合在给定分值范围内的所有元素 ZREM 移除给定成员 使用示例： 说明： 在获取有序集合包含的所有元素时，多个元素会按照分值大小排序； 用户可以根据分值来获取有序集合中的一部分元素。 Redis应用]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用对象-关系映射持久化数据（ORM）]]></title>
    <url>%2F2017%2F12%2F15%2Fspring%2Fobjrelational%2F</url>
    <content type="text"><![CDATA[介绍在数据持久化的世界中， JDBC能很好地完成份内的事并且在一些特定的场景下表现出色。 但此外，我们还需要一些更复杂的特性： 延迟加载（Lazy loading） ： 有时候我们并不希望立即获取完整的对象间关系。 举一个典型的例子， 假设我们在查询一组PurchaseOrder对象， 而每个对象中都包含一个LineItem对象集合。 如果我们只关心PurchaseOrder的属性， 那查询出LineItem的数据就毫无意义。 而且这可能是开销很大的操作。 延迟加载允许我们只在需要的时候获取数据。 预先抓取（Eager fetching） ： 这与延迟加载是相对的。 借助于预先抓取， 我们可以使用一个查询获取完整的关联对象。 如果我们需要PurchaseOrder及其关联的LineItem对象， 预先抓取的功能可以在一个操作中将它们全部从数据库中取出来， 节省了多次查询的成本。 级联（Cascading） ： 更改数据库中的表会同时修改其他表。当删除Order对象时， 需要同时删除关联的LineItem。 一些可用的框架提供了这样的服务， 这些服务的通用名称是对象/关系映射（object-relational mapping， ORM）。 Spring对多个持久化框架都提供了支持， 包括Hibernate、 iBATIS、Java数据对象（ Java Data Objects， JDO） 以及Java持久化API（ JavaPersistence API， JPA） 。 与Spring对JDBC的支持那样， Spring对ORM框架的支持提供了与这些框架的集成点以及一些附加的服务： 支持集成Spring声明式事务； 透明的异常处理； 线程安全的、 轻量级的模板类； DAO支持类； 资源管理。 Spring中集成HibernateHibernate不仅提供了基本的对象关系映射， 还提供了ORM工具所应具有的所有复杂功能，比如缓存、 延迟加载、 预先抓取以及分布式缓存。 声明Hibernate的Session工厂使用Hibernate所需的主要接口是org.hibernate.Session。 Session接口提供了基本的数据访问功能， 如保存、 更新、 删除以及从数据库加载对象的功能。获取Hibernate Session对象的标准方式是借助于Hibernate SessionFactory接口的实现类。在Spring中， 我们要通过Spring的某一个Hibernate Session工厂bean来获取Hibernate SessionFactory。 从3.1版本开始， Spring提供了三个Session工厂bean供我们选择： org.springframework.orm.hibernate3.LocalSessionFactoryBean org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean org.springframework.orm.hibernate4.LocalSessionFactoryBean 至于选择使用哪一个Session工厂， 这取决于使用哪个版本的Hibernate以及你使用XML还是使用注解来定义对象-数据库之间的映射关系。 123456789101112131415161718192021222324252627282930313233343536373839404142//使用Hibernate 3.2或更高版本(不包括4及以上) 并且使用XML定义映射，使用第一个@Beanpublic LocalSessionFactoryBean sessionFactory(DataSource dataSource)&#123; LocalSessionFactoryBean sfb = new LocalSessionFactoryBean(); sfb.setDataSource(dataSource); //属性dataSource装配了一个DataSource bean的引用 sfb.setMappingResources(new String[] &#123;"Spitter.hbm.xml"&#125;); //一个或多个的Hibernate映射文件， 在这些文件中定义了应用程序的持久化策略 Properties props = new Properties(); //hibernateProperties属性配置了Hibernate如何进行操作的细节 props.setProperty("dialect","org.hibernate.dialect.H2Dialect"); sfb.setHibernateProperties(props); return sfb;&#125;//使用注解的方式定义持久化(不包括4及以上)，可以使用第二个@Beanpublic AnnotationSessionFactoryBean sessionFactory(DataSource ds)&#123; AnnotationSessionFactoryBean sfb = new AnnotationSessionFactoryBean(); sfb.setDataSource(ds); sfb.setPackagesToScan(new String[] &#123;"com.habuma.spitter.domain"&#125;); Properties props = new Properties(); props.setProperty("dialect","org.hibernate.dialect.H2Dialect"); sfb.setHibernateProperties(props); return sfb;&#125;//使用Hibernate 4,可以使用第三个。能够支持基于XML的映射和基于注解的映射@Beanpublic LocalSessionFactoryBean sessionFactory(DataSource dataSource)&#123; LocalSessionFactoryBean sfb = new LocalSessionFactoryBean(); sfb.setDataSource(dataSource); sfb.setPackagesToScan(new String[] &#123;"com.habuma.spitter.domain"&#125;); /*还可以使用annotatedClasses属性来将应用程序中所有的持久化类以全限定名的方式明确列出： sfb.setAnnotatedClasses(new Class&lt;?&gt;[]&#123;Spitter.class, Spittle.class&#125;); */ Properties props = new Properties(); props.setProperty("dialect","org.hibernate.dialect.H2Dialect"); sfb.setHibernateProperties(props); return sfb;&#125;/*使用packagesToScan属性告诉Spring扫描一个或多个包以查找域类， 这些类通过注解的方式表明要使用Hibernate进行持久化， 这些类可以使用的注解包括JPA的@Entity或@MappedSuperclass以及Hibernate的@Entity*/ 构建不依赖于Spring的Hibernate代码使用上下文Session（ Contextual session）。 通过这种方式， 会直接将Hibernate SessionFactory装配到Repository中， 并使用它来获取Session。例：借助Hibernate Session实现不依赖于Spring的Repository 12345678910111213141516171819202122232425262728293031323334353637383940/* * @Repository是Spring的另一种构造性注解， 它能够像其他注解一样被Spring的组件扫描所扫描到 * 好处：1. 减少显式配置以外--不必声明HibernateSpitterRepository bean * 2. 异常处理 */@Repositorypublic class HibernateSpitterRepository&#123; /* * 通过@Inject注解让Spring自动将一个SessionFactory注入 */ @Inject public HibernateSpitterRepository(SessionFactory sessionFactory)&#123; this.sessionFactory = sessionFactory;//注入SessionFactory &#125; private Session currentSession()&#123; return SessionFactory.getCurrentSession();//从SessionFactory中获取当前Session &#125; public long count()&#123; return findAll().size(); &#125; public Spitter save(Spitter spitter)&#123; Serializable id = currentSession().save(spitter);//使用当前Session return new Spitter((Long) id, spitter.getUsername(), spitter.getPassword(), spitter.getFullName(), spitter.getEmail(), spitter.isUpdateByEmail()); &#125; public Spitter findOne(long id)&#123; return (Spitter) currentSession().get(Spitter.class,id); &#125; public Spitter findByUsername(String username)&#123; return (Spitter) currentSession().createCriteria(Spitter.class) .add(Restrictions.eq("username",username)).list().get(0); &#125; public List&lt;Spitter&gt; findAll()&#123; return (List&lt;Spitter&gt;) currentSession().createCriteria(Spitter.class).list(); &#125;&#125; @Repository注解处理异常： 为了给不使用模板的Hibernate Repository添加异常转换功能， 我们只需在Spring应用上下文中添加一个PersistenceExceptionTranslationPostProcessor bean： 12345678@Beanpublic BeanPostProcessor persistenceTranslation()&#123; return new PersistenceExceptionTranslationPostProcessor();&#125;/* * PersistenceExceptionTranslationPostProcessor是一个bean 后置处理器（bean post-processor），它会在所有拥有 *@Repository注解的类上添加一个通知器（advisor），这样就会捕获任何平台相关的异常并以Spring非检查型数据访问异常 * 的形式重新抛出。 */ 上面是Hibernate版本的Repository，没有依赖Spring的特定类（ 除了@Repository注解以外 ）。 这种不使用模板的方式也适用于开发纯粹的基于JPA的Repository Spring与Java持久化APIJava持久化API（ Java Persistence API， JPA） 诞生在EJB 2实体Bean的废墟之上， 并成为下一代Java持久化标准。 JPA 是基于POJO的持久化机制。在Spring中使用JPA的第一步是要在Spring应用上下文中将实体管理器工厂（ entity manager factory） 按照bean的形式来进行配置。 配置实体管理器工厂基于JPA的应用程序需要使用EntityManagerFactory的实现类来获取EntityManager实例。 JPA定义了两种类型的实体管理器： 应用程序管理类型（ Application-managed） ： 当应用程序向实体管理器工厂直接请求实体管理器时， 工厂会创建一个实体管理器。 在这种模式下， 程序要负责打开或关闭实体管理器并在事务中对其进行控制。 这种方式的实体管理器适合于不运行在JavaEE容器中的独立应用程序。 容器管理类型（ Container-managed） ： 实体管理器由Java EE创建和管理。 应用程序根本不与实体管理器工厂打交道。 相反， 实体管理器直接通过注入或JNDI来获取。 容器负责配置实体管理器工厂。 这种类型的实体管理器最适用于Java EE容器， 在这种情况下会希望在persistence.xml指定的JPA配置之外保持一些自己对JPA的控制。 以上的两种实体管理器实现了同一个EntityManager接口。 应用程序管理类型的EntityManager是由EntityManagerFactory创建的， 而EntityManagerFactory是通过PersistenceProvider的createEntityManagerFactory()方法得到的。 而容器管理类型的Entity ManagerFactory是通过PersistenceProvider的createContainerEntityManager Factory()方法获得的。 如果你使用的是应用程序管理类型的实体管理器， Spring承担了应用程序的角色并以透明的方式处理EntityManager； 在容器管理的场景下， Spring会担当容器的角色。这两种实体管理器工厂分别由对应的Spring工厂Bean创建： LocalEntityManagerFactoryBean生成应用程序管理类型的EntityManager-Factory。 LocalContainerEntityManagerFactoryBean生成容器管理类型的Entity-ManagerFactory。 应用程序管理类型和容器管理类型的实体管理器工厂之间唯一值得关注的区别是在Spring应用上下文中如何进行配置。 配置应用程序管理类型的JPA对于应用程序管理类型的实体管理器工厂来说， 它绝大部分配置信息来源于一个名为persistence.xml的配置文件。 这个文件必须位于类路径下的META-INF目录下。persistence.xml的作用在于定义一个或多个持久化单元。 持久化单元是同一个数据源下的一个或多个持久化类。 简单来讲，persistence.xml列出了一个或多个的持久化类以及一些其他的配置如数据源和基于XML的配置文件。 如下是一个典型的persistence.xml文件， 它是用于Spittr应用程序的： 123456789101112&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0"&gt; &lt;persistence-unit name="spitterPU"&gt; &lt;class&gt;com.habuma.spittr.domain.Spitter&lt;/class&gt; &lt;class&gt;com.habuma.spittr.domain.Spittle&lt;/class&gt; &lt;properties&gt; &lt;property name="toplink.jdbc.driver" value="org.hsqldb.jdbcDriver" /&gt; &lt;property name="toplink.jdbc.url" value="jdbc.hsqldb:hsql://localhost/spitter/spitter" /&gt; &lt;property name="toplink.jdbc.user" value="sa" /&gt; &lt;property name="toplink.jdbc.password" value="" /&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;/persistence&gt; 可以通过以下的@Bean注解方法在Spring中声明LocalEntityManagerFactoryBean： 123456789@Beanpublic LocalEntityManagerFactoryBean entityManagerFactoryBean()&#123; LocalEntityManagerFactoryBean emfb = new LocalEntityManagerFactoryBean(); emfb.setPersistenceUnitName("spitterPU"); return emfb;&#125;/* * 赋给persistenceUnitName属性的值就是persistence.xml中持久化单元的名称 */ 使用容器管理类型的JPA借助于Spring对JPA的支持， 再将配置信息放在persistence.xml中就显得不那么明智了。 实际上， 这样做妨碍了我们在Spring中配置EntityManagerFactory。所以我们常用下面这种方式。 容器管理的JPA采取了一个不同的方式。当运行在容器中时，可以使用容器（Spring） 的信息生成EntityManagerFactory。可以将数据源信息配置在Spring应用上下文中，例如， 如下的@Bean注解方法声明了在Spring中来配置容器管理类型的JPA： 12345678910111213141516@Beanpublic LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter JpaVendorAdapter)&#123; LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean(); emfb.setDataSource(dataSource); //数据源也可以在persistence.xml中配置，但这里优先级更高 emfb.setJpaVendorAdapter(jpaVendorAdapter); emfb.setPackagesToScan("com.habuma.spittr.domain"); return emfb;&#125;/* * paVendorAdapter属性用于指明所使用的是哪一个厂商的JPA实现。 Spring提供了多个JPA厂商适配器： * 1. EclipseLinkJpaVendorAdapter * 2. HibernateJpaVendorAdapter * 3. OpenJpaVendorAdapter * 4. TopLinkJpaVendorAdapter（在Spring 3.1版本中， 已经将其废弃了） */ 这里使用Hibernate作为JPA实现， 所以将其配置为Hibernate-JpaVendorAdapter： 123456789@Beanpublic JpaVendorAdapter jpaVendorAdapter()&#123; HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter(); adapter.setDatabase("HSQL"); //表示使用的数据库是Hypersonic adapter.setShowSql(true); adapter.setGenerateDdl(false); adapter.setDatabasePlatform("org.hibernate.dialect.HSQLDialect"); return adapter;&#125; 因为LocalContainerEntityManagerFactoryBean可以直接设置PackagesToScan属性，上例中，会扫描com.habuma.spittr.domain包， 查找带有@Entity注解的类。 因此， 没有必要在persistence.xml文件中进行声明了。 同时，因为DataSource也是注入到LocalContainer-EntityManager FactoryBean中的， 所以也没有必要在persistence.xml文件中配置数据库信息了。 从JNDI获取实体管理器工厂可以使用Spring jee命名空间下的jee:jndi-lookup元素来获取对EntityManagerFactory的引用： 1&lt;jee:jndi-lookup id="emf" jndi-name="persistence/spitterPU" /&gt; 也可以使用如下的Java配置来获取EntityManagerFactory： 123456@Beanpublic JndiObjectFactoryBean entityManagerFactory()&#123; JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean(); jndiObjectFB.setJndiName("jdbc/SpittrDS"); return jndiObjectFB; //JndiObjectFactoryBean是FactoryBean接口的实现， 它能够创建EntityManagerFactory&#125; 不管你采用何种方式得到EntityManagerFactory， 一旦得到这样的对象， 接下来就可以编写Repository了。 编写基于JPA的Repository纯粹的JPA方式远胜于基于模板的JPA，先看一个不使用Spring模板的纯JPA Repository： 123456789101112131415161718@Repository@Transactionalpublic class JpaSpitterRepository implements SpitterRepository&#123; @PersistenceUnit private EntityManagerFactory emf; //注入EntityManagerFactory public void addSpitter(Spitter spitter)&#123; emf.createEntityManager().persist(spitter); //创建并使用EntityManager &#125; public Spitter getSpitterById(long id)&#123; return emf.createEntityManager().find(Spitter.class, id); &#125; public Spitter saveSpitter(Spitter spitter)&#123; emf.createEntityManager().merge(spitter); &#125;&#125;/*使用@PersistenceUnit注解，spring会将EntityManagerFactory注入到Repository中，之后JpaSpitterRepository的方法 *就能使用它来创建EntityManager，然后EntityManager可以针对数据库执行操作 */ 在JpaSpitterRepository中， 唯一的问题在于每个方法都会调用createEntityManager() ，所以EntityManager并不是线程安全的， 一般来讲并不适合注入到像Repository这样共享的单例bean中。 如下我们可以借助@PersistentContext注解为JpaSpitterRepository设置EntityManager。例：将EntityManager的代理注入到Repository之中 1234567891011121314151617181920@Repository @Transactional //表明这个Repository中的持久化方法是在事务上下文中执行的public class JpaSpitterRepository implements SpitterRepository&#123; @PersistentContext private EntityManager em; //注入EntityManager public void addSpitter(Spitter spitter)&#123; em.persist(spitter); //使用EntityManager &#125; public Spitter getSpitterById(long id)&#123; return em.find(Spitter.class, id); &#125; public Spitter saveSpitter(Spitter spitter)&#123; em.merge(spitter); &#125;&#125;/*@PersistenceContext并不会真正注入EntityManager,而是给了它一个EntityManager的代理。 真正的EntityManager是与 * 当前事务相关联的那一个， 如果不存在这样的EntityManager的话， 就会创建一个新的。 这样的话， 我们就能始终以线程 * 安全的方式使用实体管理器。 */ 注意1：@PersistenceUnit和@PersistenceContext并不是Spring的注解， 它们是由JPA规范提供的。 必须要配置Spring的PersistenceAnnotationBeanPostProcessor。 如果已使用了context:annotation-config或context:componentscan， 这些配置元素会自动注册PersistenceAnnotationBeanPostProcessor bean。 否则的话，就需要显式地注册这个bean： 1234@Beanpublic PersistenceAnnotationBeanPostProcessor paPostProcessor()&#123; return new PersistenceAnnotationBeanPostProcessor();&#125; 注意2：对于@Repository注解， 它的作用与开发Hibernate上下文Session版本的Repository时是一致的。 由于没有使用模板类来处理异常， 所以我们需要为Repository添加@Repository注解这样PersistenceExceptionTranslationPostProcessor就会知道要将这个bean产生的异常转换成Spring的统一数据访问异常。 我们需要将其作为一个bean装配到Spring中 ： 1234@Beanpublic BeanPostProcessor persistenceTranslation()&#123; return new PersistenceExceptionTranslationPostProcessor();&#125; 借助Spring Data实现自动化的JPA Repository我们发现上面的程序还会直接与EntityManager 交互来查询数据库。Spring Data JPA能够终结这种一遍遍地编写相同的持久化方法，SpringData能够让我们只编写Repository接口就可以了。 根本就不再需要实现类了。例： 1public interface SpitterRepository extends JpaRepository&lt;Spitter,Long&gt;&#123;&#125; 编写Spring Data JPA Repository的关键在于要从一组接口中挑选一个进行扩展。 这里， SpitterRepository扩展了Spring Data JPA的JpaRepository。 通过这种方 式， JpaRepository进行了参数化， 所以它就能知道这是一个用来持久化Spitter对象的Repository， 并且Spitter的ID类型为Long。 另外， 它还会继承18个执行持久化操作的通用方法， 如保存Spitter、 删除Spitter以及根据ID查询Spitter。 为了要求Spring Data创建SpitterRepository的实现， 我们需要在Spring配置中添加一个元素。 例：启用Spring Data JPA： 123456&lt;beans xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemaLocation="http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.0.xsd"&gt; &lt;jpa:repositories base-package="com.habuma.spittr.db" /&gt;&lt;/beans&gt; 同context:component-scan元素一样， jpa:repositories元素也需要指定一个要进行扫描的base-package。 不过， context:component-scan会扫描包（及其子包） 来查找带有@Component注解的类，而jpa:repositories会扫描它的基础包来查找扩展自SpringData JPA Repository接口的所有接口。 如果发现了扩展自Repository的接口， 它会自动生成（在应用启动的时候） 这个接口的实现。 同样，如果使用java配置的话，需要添加@EnableJpaRepositories 注解： 123@Configuration@EnableJpaRepositories(basePackages="com.habuma.spittr.db")public class JpaConfiguration&#123;...&#125; SpitterRepository接口， 它扩展自JpaRepository， 而JpaRepository又扩展自Repository标记接口（虽然是间接的） 。 因此， SpitterRepository就传递性地扩展了Repository接口， 也就是Repository扫描时所要查找的接口。 当Spring Data找到它后， 就会创建SpitterRepository的实现类， 其中包含了继承自JpaRepository、 PagingAndSortingRepository和CrudRepository的18个方法。Repository的实现类是在应用启动的时候生成的，也就是Spring的应用上下文创建的时候。 它并不是在构建时通过代码生成技术产生的， 也不是接口方法调用时才创建的。 Spring Data JPA很棒的一点在于它能为Spitter对象提供18个便利的方法来进行通用的JPA操作， 而无需你编写任何持久化代码。 如果你的需求超过了它所提供的这18个方法的话， Spring Data JPA提供了几种方式来为Repository添加自定义的方法。 定义查询方法例：根据给定的username查找Spitter对象 123public interface SpitterRepository extends JpaRepository&lt;Spitter,Long&gt;&#123; Spitter findByUsername(String username);&#125; 当创建Repository实现的时候， Spring Data会检查Repository接口的所有方法， 解析方法的名称， 并基于被持久化的对象来试图推测方法的目的。 本质上， Spring Data定义了一组小型的领域特定语言（domainspecific language ， DSL） ， 在这里， 持久化的细节都是通过Repository方法的签名来描述的。 Repository方法Repository方法是由一个动词、 一个可选的主题（Subject） 、 关键词By以及一个断言所组成。 如下图： 对大部分场景来说，主题会被省略。要查询的对象类型是通过如何参数化JpaRepository接口来确定的， 而不是方法名称中的主题。 如果主题的名称以Distinct开头的话， 那么在生成查询的时候会确保所返回结果集中不包含重复记录。 断言指定了限制结果集的属性 ，在断言中， 会有一个或多个限制结果的条件。 每个条件必须引用一个属性， 并且还可以指定一种比较操作。 其他比较操作： IsAfter、 After、 IsGreaterThan、 GreaterThan 、IsGreaterThanEqual、 GreaterThanEqual IsBefore、 Before、 IsLessThan、 LessThan IsLessThanEqual、 LessThanEqual IsBetween、 Between IsNull、 Null、IsNotNull、 NotNull IsIn、 In、IsNotIn、 NotIn IsStartingWith、 StartingWith、 StartsWith、IsEndingWith、 EndingWith、 EndsWith IsContaining、 Containing、 Contains IsLike、 Like、IsNotLike、 NotLike IsTrue、 True、IsFalse、 False Is、 Equals、IsNot、 Not 要对比的属性值就是方法的参数。 完整的方法签名如下所示： 1List&lt;Spitter&gt; readByFirstnameOrLastname(String first, String last); 要处理String类型的属性时， 条件中可能还会包含IgnoringCase或IgnoresCase， 两者是同义的。例：忽略大小写 1List&lt;Spitter&gt; readByFirstnameIgnoringCaseOrLastnameIgnoringCase(String first, String last); 或者使用替代方案： 1List&lt;Spitter&gt; readByFirstnameOrLastnameAllIgnoringCase(String first, String last); 注意: 参数的名称是无关紧要的， 但是它们的顺序必须要与方法名称中的操作符相匹配。 我们还可以在方法名称的结尾处添加OrderBy， 实现结果集排序。 例如， 我们可以按照lastname属性升序排列结果集： 1List&lt;Spitter&gt; readByFirstnameOrLastnameOrderByLastnameAsc(String first, String last); 如果要根据多个属性排序的话， 只需将其依序添加到OrderBy中即可。 例如， 下面的样例中， 首先会根据lastname升序排列， 然后根据firstname属性降序排列： 1List&lt;Spitter&gt; readByFirstnameOrLastnameOrderByLastnameAscFirstnameDesc(String first, String last); 下面列出几个符合方法命名约定的方法签名： 123List&lt;Pet&gt; findPetbyBreedIn(List&lt;String&gt; breed);int countProductsByDiscontinuedTrue();List&lt;Order&gt; findByShippingDateBetween(Date start, Date end) 现在， 我们只需知道通过使用属性名和关键字构建Repository方法签名， 就能让Spring Data JPA生成方法实现， 完成几乎所有能够想象到的查询。 声明自定义查询当遇到方法名称表达预期的查询无法实现时，Spring Data能够让我们通过@Query注解来解决问题。例：查找E-mail地址是Gmail邮箱的Spitter 12@Query("select s from Spitter s where s.email like '%gmail.com' ")List&lt;Spitter&gt; findAllGmailSpitters(); 我们依然不需要编写findAllGmailSpitters()方法的实现， 只需提供查询即可， 让Spring Data JPA知道如何实现这个方法。 对于Spring Data JPA的接口来说， @Query是一种添加自定义查询的便利方式。 但是， 它仅限于单个JPA查询。 混合自定义的功能有些时候， 我们需要Repository所提供的功能是无法用Spring Data的方法命名约定来描述的， 甚至无法用@Query注解设置查询来实现。 可能需要我们按照传统的方式来编写Repository方法： 也就是直接使用EntityManager。 当Spring Data JPA为Repository接口生成实现的时候， 它还会查找名字与接口相同， 并且添加了Impl后缀的一个类。 如果这个类存在的话， Spring Data JPA将会把它的方法与Spring Data JPA所生成的方法合并在一起。 对于SpitterRepository接口而言， 要查找的类名为SpitterRepositoryImpl。 例：将活跃的Spitter用户升级为Elite状态的Repository方法： 12345678public class SpitterRepositoryImpl implements SpitterSweeper&#123; @PersistenceContext private EntityManager em; public int eliteSweep()&#123; String update= "UPDATE Spitter spitter set spitter.status= 'Elite' where spitter.status= 'Newbie' and spitter.id in (select s from spitter s where(select count(spittles)from s.spittles spittles) &gt; 10000 ) " return em.creataQuery(update).executeUpdate(); &#125;&#125; 注意， SpitterRepositoryImpl并没有实现SpitterRepository接口。 Spring Data JPA负责实现。SpitterRepositoryImpl（将它与Spring Data的Repository关联起来的是它的名字） 实现了SpitterSweeper接口， 它如下所示： 123public interface SpitterSweeper&#123; int eliteSweep();&#125; 我们还需要确保eliteSweep()方法会被声明在SpitterRepository接口中。 要实现这一点， 避免代码重复的简单方式就是修改SpitterRepository， 让它扩展SpitterSweeper： 123public interface SpitterRepository extends JpaRepository&lt;Spitter, Long&gt;, SpitterSweeper&#123; ...&#125; Spring Data JPA将实现类与接口关联起来是基于接口的名称。 但是， Impl后缀只是默认的做法， 如果你想使用其他后缀的话， 只需在配置@EnableJpa-Repositories的时候， 设置repositoryImplementationPostfix属性即可： 12@EnableJpaRepositories(basePackages="com.habuma.spittr.db",repositoryImplementationPostfix="Helper")/*我们将后缀设置成了Helper， Spring Data JPA将会查找名为SpitterRepository-Helper的类， 用它来匹配SpitterRepository接口。*/ 如果在XML中使用jpa:repositories元素来配置Spring DataJPA的话， 我们可以借助repository-impl-postfix属性指定后缀： 1&lt;jpa:repositories base-package="com.habum.spittr.db" repository-impl-postfix="Helper" /&gt;]]></content>
      <categories>
        <category>JAVA</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring访问数据库]]></title>
    <url>%2F2017%2F12%2F07%2Fspring%2FspringJDBC%2F</url>
    <content type="text"><![CDATA[介绍Spring自带了一组数据访问框架，集成了多种数据访问技术。不管是直接通过JDBC还是像Hibernate这样的对象关系映射（object-relational mapping，ORM）框架实现数据持久化，或是java持久化API（Java Persistence API，JPA），或是NoSQL数据库等。Spring都能够消除持久化代码中那些单调枯燥的数据访问逻辑。 Spring访问数据的原理Spring对数据库访问的支持也是遵循面向对象原则中的针对接口编程。为了避免持久化的逻辑分散到应用的各个组件中，Spring将数据访问的功能放到一个或多个专注于此项任务的组件中，这样的组件通常称为数据访问对象（data access object，DAO）或Repository。为了避免应用于特定的数据访问策略耦合在一起，编写良好的Repository应该以接口的方式暴露功能。如下图： 这里说明一点，尽管Spring鼓励使用接口，但并不是强制的，你也可以使用Spring将bean（DAO或其他类型）直接装配到另一个bean的某个属性中，而不需要一定通过接口注入。 Spring数据访问异常体系Spring提供多个数据访问异常，分别描述了它们抛出时所对应的问题。Spring所提供的持久化异常是与平台无关的，这意味着我们可以使用Spring抛出一致的异常，而不用关心所选择的持久化方案。Spring所提供的异常都继承自DataAccessException，这是一个非检查型异常。换句话说，没必要捕获Spring所抛出的数据访问异常。因为Spring认为触发异常的很多问题是不能再catch块中修复的，所以使用了非检查型异常，而不是强制开发人员编写catch块代码（里面经常是空的）。 数据访问模板为了利用Spring的数据访问异常，我们必须使用Spring所支持的数据访问模板。Spring将数据访问过程中固定的和可变的部分明确划分为两个不同的类：模板（template）和回调（callback）。模板管理过程中固定的部分，而回调处理自定义的数据访问代码。如下图： 如图所示，Spring的模板类处理数据访问的固定部分——事务控制、管理资源以及处理异常。 同时， 应用程序相关的数据访问——语句、绑定参数以及整理结果集——在回调的实现中处理。 针对不同的持久化平台， Spring提供了多个可选的模板 。 模板类（org.springframework.*） 用途 jca.cci.core.CciTemplate JCA CCI连接 jdbc.core.JdbcTemplate JDBC连接 jdbc.core.namedparam.NamedParameterJdbcTemplate 支持命名参数的JDBC连接 jdbc.core.simple.SimpleJdbcTemplate 通过java5简化的jdbc连接 orm.hibernate3.HibernateTemplate Hibernate 3.x以上的Session orm.ibatis.SqlMapClientTemplate IBATIS SqlMap客户端 orm.jdo.JdoTemplate java数据对象（Java Data Object）实现 orm.jpa.JpaTemplate java持久化API的实体管理器 配置数据源无论选择哪种数据访问方式， 都需要配置一个数据源的引用。 Spring提供了在Spring上下文中配置数据源bean的多种方式， 包括： 通过JDBC驱动程序定义的数据源； 通过JNDI查找的数据源； 连接池的数据源。 使用JNDI数据源Spring应用程序经常部署在Java EE应用服务器中， 如WebSphere、JBoss或甚至像Tomcat这样的Web容器中。 这些服务器允许你配置通过JNDI获取数据源。 这种配置的好处在于数据源完全可以在应用程序之外进行管理， 这样应用程序只需在访问数据库的时候查找数据源就可以了。 另外， 在应用服务器中管理的数据源通常以池的方式组织， 从而具备更好的性能， 并且还支持系统管理员对其进行热切换。 使用Spring bean将JNDI中数据源的引用装配到需要的类中： 1&lt;jee:jndi-lookup id="dataSource" jndi-name="/jdbc/SpitterDS" resource-ref="true" /&gt; 其中jndi-name属性用于指定JNDI中资源的名称。 如果只设置了jndi-name属性， 那么就会根据指定的名称查找数据源。 但是， 如果应用程序运行在Java应用服务器中， 你需要将resource-ref属性设置为true， 这样给定的jndi-name将会自动添加“java:comp/env/”前缀。 使用java配置： 12345678@Beanpublic JndiObjectFactoryBean dataSource()&#123; JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean(); jndiObjectFB.setJndiName("jdbc/SpitterDS"); jndiObjectFB.setResourceRef(true); jndiObjectFB.setProxyInterface(javax.sql.DataSource.class); return jndiObjectFB;&#125; 使用数据源连接池Spring没有提供数据源连接池实现，我们可以使用如下的开源实现： Apache Commons DBCP c3p0 BoneCP 例：配置DBCP BasicDataSource: 12345678910111213141516171819202122232425//xml配置&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" p:driverClassName="org.h2.Driver" p:url="jdbc:h2:tcp://localhost/~/spitter" p:username="sa" p:password="" p:initialSize="5" p:maxActive="10"/&gt;//java配置@Beanpublic BasicDataSource dataSource()&#123; BasicDataSource ds = new BasicDataSource(); ds.setDriverClassName("org.h2.Driver"); ds.setUrl("jdbc:h2:tcp://localhost/~/spitter"); ds.setUsername("sa") ds.setPassword(""); ds.setInitialSize(5); ds.setMaxActive(10); return ds;&#125;/*其中前四个属性是配置BasicDataSource所必需的，在示例中， 连接池启动时会创建5个连接； 当需要的时候， 允许BasicDataSource创建新的连接， 但最大活跃连接数为10*/ DBCP BasicDataSource的池配置属性： 池配置属性 所指定的内容 initialSize 池启动时创建的连接数量 maxActive 同一时间可从池中分配的最多的连接数。设置0表示无限制 maxIdle 池里被释放的最多空闲连接数。设置0表示无限制 maxOpenPreparedStatements 在同一时间能够从语句池中分配的预处理语句（prepared statement）的最大数量。设置0表示无限制 maxWait 在抛出异常前，池等待连接回收的最大时间。设置-1表示无限等待 minEvictableIdleTimeMillis 连接在池中保持空闲而不被回收的最大时间 minIdle 在不创建新连接的情况下，池中保持空闲的最小连接数 poolPreparedStatements 是否对预处理语句进行池管理 基于JDBC驱动的数据源Spring提供了三个这样的数据源类（ 均位于org.springframework.jdbc.datasource包中） 供选择： DriverManagerDataSource： 在每个连接请求时都会返回一个新建的连接。 与DBCP的BasicDataSource不同，由DriverManagerDataSource提供的连接并没有进行池化管理； SimpleDriverDataSource：与DriverManagerDataSource的工作方式类似， 但是它直接使用JDBC驱动， 来解决在特定环境下的类加载问题， 这样的环境包括OSGi容器； SingleConnectionDataSource： 在每个连接请求时都会返回同一个的连接。 尽管SingleConnectionDataSource不是严格意义上的连接池数据源， 但是你可以将其视为只有一个连接的池。 例：DriverManagerDataSource配置： 1234567891011121314151617181920//xml配置&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource" p:driverClassName="org.h2.Driver" p:url="jdbc:h2:tcp://localhost/~/spitter" p:username="sa" p:password=""/&gt;//java配置@Beanpublic BasicDataSource dataSource()&#123; DriverManagerDataSource ds = new DriverManagerDataSource(); ds.setDriverClassName("org.h2.Driver"); ds.setUrl("jdbc:h2:tcp://localhost/~/spitter"); ds.setUsername("sa") ds.setPassword(""); return ds;&#125;/*与具备池功能的数据源相比， 唯一的区别在于这些数据源bean都没有提供连接池功能， 所以没有可配置的池相关的属性*/ 局限性： 尽管这些数据源对于小应用或开发环境来说是不错的， 但是要将其用于生产环境， 你还是需要慎重考虑。 因为SingleConnectionDataSource有且只有一个数据库连接， 所以不适合用于多线程的应用程序， 最好只在测试的时候使用。而DriverManagerDataSource和SimpleDriverDataSource尽管支持多线程， 但是在每次请求连接的时候都会创建新连接， 这是以性能为代价的。 鉴于以上的这些限制，所以建议应该使用数据源连接池。 使用嵌入式的数据源嵌入式数据库（ embedded database）作为应用的一部分运行， 而不是应用连接的独立数据库服务器。 尽管在生产环境的设置中， 它并没有太大的用处， 但是对于开发和测试来讲， 嵌入式数据库都是很好的可选方案。 这是因为每次重启应用或运行测试的时候， 都能够重新填充测试数据。 使用jdbc命名空间配置嵌入式数据库： 123456789101112131415161718192021222324//xml配置&lt;beans xmlns:jdbc="http://www.springframework.org/schema/jdbc" xsi:schemaLocation="http://www.springframework.org/schema/jdbc &lt;jdbc:embedded-database id="dataSource" type="H2"&gt; &lt;jdbc:script location="com/habuma/spitter/db/jdbc/schema.sql" /&gt; &lt;jdbc:script location="com/habuma/spitter/db/jdbc/test-data.sql" /&gt; &lt;/jdbc:embedded-database&gt; /beans&gt;/* * 1. 将type属性设置为H2， 表明嵌入式数据库应该是H2数据库, 将type设置为DERBY，使用嵌入式的ApacheDerby数据库 * 2. &lt;jdbc:embedded-database&gt;元素还会暴露一个数据源， 我们可以像使用其他的数据源那样来使用它。在这里， id属性被 设置成了dataSource， 这也是所暴露数据源的bean ID。 因此， 当我们需要javax.sql.DataSource的时候， 就可 以注入dataSource bean。 */ //java配置@Beanpublic DataSource dataSource()&#123; return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build();&#125; 使用profile选择数据源对于开发期来说， jdbc:embedded-database元素是很合适的， 而在QA环境中， 你可能希望使用DBCP的BasicDataSource， 在生产部署环境下， 可能需要使用jee:jndi-lookup。借助Spring的profile特性能够在运行时选择数据源：取决于profile的激活状态 123456789101112131415161718192021222324252627282930//java配置@Configurationpublic class DataSourceConfiguration&#123; @profile("development") @Bean public DataSource embeddedDataSource()&#123; //开发数据源 &#125; @profile("qa") @Bean public DataSource BasicDataSource()&#123; //QA数据源 &#125; @profile("production") @Bean public DataSource JndiObjectFactoryBeanDataSource()&#123; //生产环境数据源 &#125;&#125;//xml配置&lt;beans profile="development" &lt;jdbc:embedded-database id="dataSource" type="H2"&gt; ... &lt;/jdbc:embedded-database&gt;/beans&gt;&lt;beans profile="qa" &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" ... /&gt;/beans&gt;&lt;beans profile="production" &lt;jee:jndi-lookup id="dataSource" jndi-name="/jdbc/SpitterDS" resource-ref="true" /&gt;/beans&gt; Spring中使用JDBCSpring为JDBC提供了三个模板类供选择： JdbcTemplate： 最基本的Spring JDBC模板， 这个模板支持简单的JDBC数据库访问功能以及基于索引参数的查询； NamedParameterJdbcTemplate： 使用该模板类执行查询时可以将值以命名参数的形式绑定到SQL中， 而不是使用简单的索引参数； SimpleJdbcTemplate： 该模板类利用Java 5的一些特性如自动装箱、 泛型以及可变参数列表来简化JDBC模板的使用。（spring3.1废弃，java 5特性转移到JdbcTemplate） 使用JdbcTemplate来操作数据在spring中配置JdbcTemplate： 1234@Beanpublic JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; return new JdbcTemplate(dataSource);&#125; 将jdbcTemplate装配到Repository中并使用它来访问数据库：例如， SpitterRepository使用了JdbcTemplate 12345678910111213141516171819/* * 1. JdbcSpitterRepository类上使用了@Repository注解， 这表明它将会在组件扫描的时候自动创建。 * 2. 它的构造器上使用了@Inject注解， 因此在创建的时候， 会自动获得一个JdbcOperations对象。 * 3. JdbcOperations是一个接口， 定义了JdbcTemplate所实现的操作。 通过注入JdbcOperations， 而不是具体的 * JdbcTemplate， 能够保证JdbcSpitterRepository通过JdbcOperations接口达到与JdbcTemplate保持松耦合。 */@Repositorypublic class JdbcSpitterRepository implements SpitterRepository&#123; private JdbcOperations jdbcOperations; @Inject public JdbcSpitterRepository(JdbcOperations jdbcOperations)&#123; this.jdbcOperations = jdbcOperations; &#125;&#125;//另外一种组件扫描和自动装配的方案， 将JdbcSpitterRepository显式声明为Spring中的bean@Beanpublic SpitterRepository spitterRepository(JdbcTemplate jdbcTemplate)&#123; return new JdbcSpitterRepository(jdbcTemplate);&#125; 在Repository中具备可用的JdbcTemplate后， 我们可以极大地简化JDBC操作数据库的代码。 例1：基于JdbcTemplate的addSpitter()方法 123456//样板代码被隐藏到JDBC模板类中了,Spring的数据访问异常都是运行时异常， 所以不必在addSpring ()方法中进行捕获public void addSpitter(Spitter spitter)&#123; jdbcOperations.update(INSERT_SPITTER, spitter.getUsername(), spitter.getPassword());&#125; 例2：使用JdbcTemplate查询Spitter 123456789101112131415161718//findOne()方法， 使用了JdbcTemplate的回调， 实现根据ID查询Spitter， 并将结果集映射为Spitter对象public Spitter findOne(long id)&#123; return jdbcOperations.queryForObject(SELECT_SQL,new SpitterRowMapper(),id);&#125;/* * 1. queryForObject()方法有三个参数： * 1. String对象， 包含了要从数据库中查找数据的SQL * 2. RowMapper对象， 用来从ResultSet中提取数据并构建域对象 * 3. 可变参数列表， 列出了要绑定到查询上的索引参数值 * 2. 对于查询返回的每一行数据，JdbcTemplate会调用RowMapper的mapRow()方法，并传入一个ResultSet和包含行号的整数 */private static final class SpitterRowMapper implements RowMapper&lt;Spitter&gt;&#123; public Spitter mapRow(ResultSet rs, int rowNum)throws SQLException&#123; return new Spitter(rs.getLong("id"), rs.getString("username"), rs.getString("password")); &#125;&#125; 在JdbcTemplate中使用Java 8的Lambda表达式因为RowMapper接口只声明了addRow()这一个方法， 因此它完全符合函数式接口（ functional interface） 的标准。如果使用Java 8来开发应用的话， 我们可以使用Lambda来表达RowMapper的实现， 而不必再使用具体的实现类了。如改写findOne()方法： 123456789//使用Java 8的Lambda表达式public Spitter findOne(long id)&#123; return jdbcOperations.queryForObject(SELECT_SQL, (rs, rowNum) -&amp;gt;&#123; return new Spitter(rs.getLong("id"), rs.getString("username"), rs.getString("password")); &#125;, id);&#125; 另外， 还可以使用Java 8的方法引用， 在单独的方法中定义映射逻辑： 12345678public Spitter findOne(long id)&#123; return jdbcOperations.queryForObject(SELECT_SQL,this::mapSpitter,id);&#125;private Spitter mapSpitter(ResultSet rs, int row)throws SQLException&#123; return new Spitter(rs.getLong("id"), rs.getString("username"), rs.getString("password"));&#125; 不管采用哪种方式， 我们都不必显式实现RowMapper接口， 但是与实现RowMapper类似， 我们所提供的Lambda表达式和方法必须要接受相同的参数， 并返回相同的类型。 使用命名参数命名参数可以赋予SQL中的每个参数一个明确的名字， 在绑定值到查询语句的时候就通过该名字来引用参数。声明NamedParameterJdbcTemplate： 1234@Beanpublic NamedParameterJdbcTemplate jdbcTemplate(DataSource dataSource)&#123; return new NamedParameterJdbcTemplate(dataSource);&#125; 将NamedParameterJdbcOperations（ NamedParameterJdbcTemplate所实现的接口） 注入到Repository中， 用它来替代JdbcOperations。 现在的addSpitter()方法如下所示： 1234567891011private static final String INSERT_SPITTER = "insert into Spitter(username,password) values(:username,:password)";public void addSpitter(Spitter spitter)&#123; //命名参数是通过java.util.Map来进行绑定的 Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); paramMap.put("username", spitter.getUsername()); paramMap.put("password", spitter.getPassword()); //绑定参数 jdbcOperations.update(INSERT_SPITTER, paramMap); //执行数据插入&#125;]]></content>
      <categories>
        <category>JAVA</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注入AspectJ切面]]></title>
    <url>%2F2017%2F12%2F07%2Fspring%2Faspectj%2F</url>
    <content type="text"><![CDATA[介绍]]></content>
      <categories>
        <category>JAVA</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring面向切面]]></title>
    <url>%2F2017%2F12%2F01%2Fspring%2FspringAOP%2F</url>
    <content type="text"><![CDATA[介绍在软件开发中，散布于应用中多处的功能被称为横切关注点（cross-cutting concern）。把这些横切关注点与业务逻辑相分离正是面向切面编程（AOP）所要解决的问题。DI有助于应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦。切面适用的场景包括日志、声明式事务、安全和缓存等。 面向切面基本原理切面能帮助我们模块化横切关注点。横切关注点可以被描述为影响应用多处的功能。横切关注点概念图： 切面提供了取代继承和委托的另一种要重用代码功能的可选方案。在使用切面时，我们仍然在一个地方定义通用功能（类似于辅助功能，辅助类），但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。这样做的两个好处： 每个关注点都集中在了一个地方，而不是分散在多处代码中； 服务模块更简洁，它们只包含关注点（或核心代码），而次要关注点的代码被转移到了切面中。 通过切点来选择连接点切点用于准确定位应该在什么地方应用切面的通知。在Spring AOP 中，使用AspectJ的切点表达式语言来定义切点。 重点是Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集，因为Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的。Spring AOP 所支持的AspectJ切点指示器： AspectJ指示器 描述 arg() 限制连接点匹配参数为指定类型的执行方法 @args() 限制连接点匹配参数由指定注解标注的执行方法 execution() 用于匹配是连接点的执行方法 this() 限制连接点匹配AOP代理的bean引用为指定类型的类 target 限制连接点匹配目标对象为指定类型的类 @target() 限制连接点匹配待定的执行对象这些对象对应的类要具有指定类型的注解 within() 限制连接点匹配指定的类型 @within() 限制连接点匹配指定注解所标注的类型（aop中，方法定义在由指定的注解所标注的类里） @annotation 限定匹配带有指定注解的连接点 在Spring中使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。 编写切点一个Performance接口： 1234package concert;public interface Performance&#123; public void perform();&#125; 使用AspectJ切点表达式来当perform方法执行时触发通知的调用： 1234567891011121314/* * 1. * 表示返回任意类型 * 2. concert.Performance.perform() 全限定的类名和方法名 * 3. .. 表示任意参数 */execution(* concert.Performance.perform(..))//限定仅匹配concert包execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*)/*&amp;在XML中有特殊含义，所以在Spring的XML配置里面描述切点可以用 and,or,not代替&amp;&amp;,||*/ //限定切点只匹配特定的bean,bean()使用bean ID或bean名称作参数execution(* concert.Performance.perform(..)) and bean('woodstock')execution(* concert.Performance.perform(..)) and !bean('woodstock') 使用注解创建切面使用注解来创建切面是AspectJ5所引入的关键特性。Spring使用AspectJ注解来声明通知方法： 注解 通知 @After 通知方法会在目标方法返回或抛出异常后调用 @AfterReturning 通知方法会在目标返回后调用 @AfterThrowing 通知方法会在目标方法抛出异常后调用 @Around 通知方法会将目标方法封装起来 @Before 通知方法会在目标方法调用之前执行 例：一个观看演出的切面： 1234567891011121314151617181920212223242526272829303132333435363738/** * 观众：观看演出的切面 * 使用@Pointcut注解定义可重用的切点 * @author guangguang_duan * */@Aspectpublic class AudienceUsePointcut &#123; @Pointcut("execution(** spring04.aop.Performance.perform(..))") public void performance()&#123; //没有实际操作的方法，供@Pointcut注解依附的标识 &#125; //表演之前 @Before("performance()") public void silenceCellPhones()&#123; System.out.println("Silencing cell phones"); &#125; //表演之前 @Before("performance()") public void takeSeats()&#123; System.out.println("Taking seats"); &#125; //表演之后 @AfterReturning("performance()") public void applause()&#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; //表演失败之后 @AfterThrowing("performance()") public void demandRefund()&#123; System.out.println("Demanding a refund"); &#125;&#125; 这样AudienceUsePointcut依然是一个POJO，能够像其他java类一样调用它的方法，也可以将它装配为spring中的bean： 1234@Beanpublic AudienceUsePointcut audience()&#123; return new AudienceUsePointcut();&#125; 它通过注解表明会作为切面使用，下面进行注解的解析，将它转换成一个切面。 在javaConfig中启用AspectJ注解的自动代理： 12345678910@Configuration@EnableAspectJAutoProxy //启用AspectJ自动代理@ComponentScanpublic class ConcertConfig &#123; @Bean public Audience audience()&#123; //声明Audience bean return new Audience(); &#125;&#125; 在XML中，通过Spring的aop命名空间启用AspectJ自动代理： 123&lt;context:component-scan base-package="spring04.aop" /&gt;&lt;aop:aspectj-autoproxy /&gt; &lt;!-- 启用AspectJ自动代理 --&gt;&lt;bean class="spring04.aop.Audience" /&gt; &lt;!-- 声明Audience bean --&gt; 不管使用何种方式，AspectJ自动代理都会为使用@Aspect注解的bean创建一个代理，这个代理会围绕着所有该切面的切点所匹配的bean。 需要记住的是，Spring的AspectJ自动代理仅仅使用@AspectJ作为创建切面的指导，切面依然是基于代理的。在本质上，它依然是spring基于代理的切面。这意味着尽管使用的是@AspectJ注解，但我们仍然限于代理方法的调用。如果想利用AspectJ的所有能力，我们必须在运行时使用AspectJ并且不依赖Spring来创建基于代理的切面。 环绕通知环绕通知是最强大的通知，它能让所编写的逻辑将被通知的目标方法完全包装起来，实际上就像在一个通知方法中同时编写前置通知和后置通知。 123456789101112131415161718public class AudienceUseAround &#123; @Pointcut("execution(** spring04.aop.Performance.perform(..))") public void performance()&#123; //没有实际操作的方法，供@Pointcut注解依附的标识 &#125; @Around("performance()") public void watchPerformance(ProceedingJoinPoint jp)&#123; try &#123; System.out.println("Silencing cell phones"); System.out.println("Taking seats"); jp.proceed(); System.out.println("CLAP CLAP CLAP!!!"); &#125; catch (Throwable e) &#123; System.out.println("Demanding a refund"); &#125; &#125;&#125; 可以看到这个通知所达到的效果与之前的前置通知和后置通知是一样的。它接受ProceedingJoinPoint作为参数，这个对象用来在通知中调用被通知的方法。如果不调用proceed()这个方法，那么通知实际上会阻塞对被通知方法的调用。也可以多次调用，这样做的一个场景就是重试逻辑，在通知方法失败后，进行重试尝试。 处理通知中的参数下面看一下切面所通知的方法带有参数的处理过程：记录每个磁道播放的次数。 12345678910111213141516171819202122@Aspectpublic class TrackCounter &#123; private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;Integer,Integer&gt;(); /* * 接受int类型参数，并使用args指定参数为trackNumber * args(trackNumber)限定符表明，传递给playTrack方法的int类型参数也会传递到通知中， * 参数的名称也与切点方法签名中的参数相匹配 */ @Pointcut("execution(* spring04.aop.playTrack(int))" + "&amp;&amp; args(trackNumber)") public void trackPlayed(int trackNumber)&#123;&#125; @Before("trackPlayed(trackNumber)") public void countTrack(int trackNumber)&#123; int currentCount = getPlayCount(trackNumber); trackCounts.put(trackNumber, currentCount + 1); &#125; public int getPlayCount(int trackNumber)&#123; return trackCounts.containsKey(trackNumber) ? trackCounts.get(trackNumber) : 0; &#125;&#125; 然后在Spring配置中，将BlankDisc和TrackCounter定义为bean，并启用AspectJ自动代理： 1234567891011121314151617181920212223@Configuration@EnableAspectJAutoProxy //启用AspectJ自动代理public class TrackCounterConfig &#123; @Bean public CompactDisc sgtPeppers()&#123; BlankDisc cd = new BlankDisc(); cd.setTitle("Sgt. Pepper's Lonely Hearts Club Band"); cd.setArtist("The Beatles"); List&lt;String&gt; tracks = new ArrayList&lt;String&gt;(); tracks.add("Love song"); tracks.add("sheng ri kuai le"); tracks.add("xiao chou"); tracks.add("ni jiu bu yao xiang qi wo"); cd.setTracks(tracks); return cd; &#125; @Bean public TrackCounter trackCounter()&#123; return new TrackCounter(); &#125;&#125; 测试并断言播放的数量： 123456789101112131415161718192021222324@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=TrackCounterConfig.class)public class TrackCounterTest &#123; @Autowired private BlankDisc cd; @Autowired private TrackCounter counter; @Test public void testTrackCounter()&#123; cd.playTrack(1); cd.playTrack(2); cd.playTrack(2); cd.playTrack(3); cd.playTrack(3); cd.playTrack(3); assertEquals(1, counter.getPlayCount(1)); assertEquals(2, counter.getPlayCount(2)); assertEquals(3, counter.getPlayCount(3)); &#125;&#125; 通过注解引入新功能在Spring中，切面只是实现了它们所包装bean相同接口的代理，除了实现这些接口，代理也能暴露新接口。下图展示Spring AOP 通过引入为Spring bean添加新方法： 当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。实际上，一个bean的实现被拆分到了多个类中。示例：为所有的Performance实现引入下面的Encoreable接口： 123public interface Encoreable &#123; void performEncore();&#125; 借助AOP引入功能，我们不必修改所有的实现让其都实现Encoreable接口，下面创建一个新的切面： 通过@DeclareParents注解将Encoreable接口引入到Performance bean中 1234567891011@Aspectpublic class EncoreableIntroducer &#123; /* * @DeclareParents注解由三个部分组成： * 1. value：指定了哪种类型的bean要引入该接口。+表示Performance的所有子类型，而不是Performance本身。 * 2. defaultImpl：指定了为引入功能提供实现的类。 * 3. @DeclareParents注解所标注的静态属性指定了要引入的接口。 */ @DeclareParents(value="spring04.aop.Performance+", defaultImpl=DefaultEncoreable.class) public static Encoreable encoreable;&#125; 和其他切面一样，我们需要在spring应用中将EncoreableIntroducer声明为一个bean： 1&lt;bean class="spring04.aop.EncoreableIntroducer" /&gt; Spring的自动代理机制将会获取到它的声明，当Spring发现一个bean使用了@Aspect注解时，Spring就会创建一个代理，然后将调用委托给被代理的bean或被引入的实现，这取决于调用的方法属于被代理的bean还是被引入的接口。 在Spring中，注解和自动代理提供了一种很便利的方式来创建切面。但面向注解的切面声明有一个明显的劣势就是，必须要有源码，才能为通知的类添加注解。所以当你没有源码，或者不想将AspectJ注解放到代码中时，就需要在Spring XML配置文件中声明切面。 在XML中声明切面在Spring的aop命名空间中，提供了多个元素用来在XML中声明切面。如下： AOP配置元素 用途 aop:advisor 定义AOP通知器 aop:after 定义AOP后置通知（不管被通知的方法是否执行成功） aop:after-returning 定义AOP返回通知 aop:after-throwing 定义AOP异常通知 aop:around 定义AOP环绕通知 aop:aspect 定义一个切面 aop:aspectj-autoproxy 启用@AspectJ注解驱动的切面 aop:before 定义一个AOP前置通知 aop:config 顶层的AOP配置元素 aop:declare-parents 以透明的方式为被通知的对象引入额外的接口 aop:pointcut 定义一个切点 12 声明前置和后置通知XML配置下的Audience类： 1234567891011121314151617public class Audience &#123; public void silenceCellPhones()&#123; System.out.println("Silencing cell phones"); &#125; public void takeSeats()&#123; System.out.println("Taking seats"); &#125; public void applause()&#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; public void demandRefund()&#123; System.out.println("Demanding a refund"); &#125;&#125; xml配置： 123456789101112131415161718192021&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;aop:pointcut id="performance" expression="execution(** spring04.aop.Performance.perform(..))"/&gt; &lt;aop:before pointcut-ref="performance" method="silenceCellPhones" /&gt; &lt;aop:before pointcut-ref="performance" method="takeSeats" /&gt; &lt;aop:after-returning pointcut-ref="performance" ethod="applause" /&gt; &lt;aop:after-throwing pointcut-ref="performance" method="demandRefund" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 如果想让定义的切点能够在多个切面使用，可以把aop:pointcut元素放在aop:config元素的范围内。 声明环绕通知假设除了进场关闭手机和表演结束鼓掌，我们还希望观众确保一直关注演出，并报告每个表演者的演出时间。使用前置通知和后置通知实现该功能的唯一方式是在前置通知中记录开始时间并在某个后置通知中报告表演耗费的时间。但这样的话必须在一个成员变量中保存开始时间。因为Audience是单例的，如果像这样保存状态的话，将会存在线程安全问题。这时可以环绕通知就很有优势。 XML配置下使用环绕通知的AudienceUseAround类： 123456789101112public class AudienceUseAround &#123; public void watchPerformance(ProceedingJoinPoint jp)&#123; try &#123; System.out.println("Silencing cell phones"); System.out.println("Taking seats"); jp.proceed(); System.out.println("CLAP CLAP CLAP!!!"); &#125; catch (Throwable e) &#123; System.out.println("Demanding a refund"); &#125; &#125;&#125; xml配置： 1234567891011&lt;aop:config&gt; &lt;aop:aspect ref="audienceUseAround"&gt; &lt;aop:pointcut id="performance" expression="execution(** spring04.aop.Performance.perform(..))"/&gt; &lt;aop:around pointcut-ref="performance" method="watchPerformance" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 为通知传递参数在XML中实现：记录每个磁道播放的次数。 无注解的TrackCounter： 12345678910public class TrackCounter &#123; private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;Integer,Integer&gt;(); public void countTrack(int trackNumber)&#123; int currentCount = getPlayCount(trackNumber); trackCounts.put(trackNumber, currentCount + 1); &#125; public int getPlayCount(int trackNumber)&#123; return trackCounts.containsKey(trackNumber) ? trackCounts.get(trackNumber) : 0; &#125;&#125; 在XML中将TrackCount配置为参数化的切面：声明TrackCount bean和BlankDisc bean，并将TrackCount转化为切面。 12345678910111213141516171819202122232425262728&lt;!-- 在XML中将TrackCount配置为参数化的切面 --&gt; &lt;!-- 声明TrackCounter bean和BlankDisc bean --&gt; &lt;bean id = "trackCounter" class = "spring04.aop.xml.TrackCounter" /&gt; &lt;bean id = "cd" class = "spring04.aop.BlankDisc"&gt; &lt;property name="title" value = "Sgt. Pepper's Lonely Hearts Club Band" /&gt; &lt;property name="artist" value = "The Beatles" /&gt; &lt;property name="tracks"&gt; &lt;list&gt; &lt;value&gt;Love song&lt;/value&gt; &lt;value&gt;sheng ri kuai le&lt;/value&gt; &lt;value&gt;xiao chou&lt;/value&gt; &lt;value&gt;ni jiu bu yao xiang qi wo&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 将TrackCount声明为切面 --&gt; &lt;aop:config&gt; &lt;aop:aspect ref="trackCounter"&gt; &lt;aop:pointcut id="trackPlayed" expression="execution(* spring04.aop.CompactDisc.playTrack(int)) and args(trackNumber)"/&gt; &lt;aop:before pointcut-ref="trackPlayed" method="countTrack" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 注意：在XML中切点表达式需要使用and、or、not，不要使用&amp;&amp;、||、!。 通过切面引入新的功能如下的XML代码与之前基于AspectJ的引入功能相同： 123456789101112131415&lt;aop:aspect&gt; &lt;aop:declare-parents types-matching="spring04.aop.Performance+" implement-interface="spring04.aop.Encoreable" default-impl="spring04.aop.DefaultEncoreable" /&gt; //Encoreable接口中的方法实现来源&lt;/aop:aspect&gt; //引入接口的实现还有另一种方式&lt;bean id="encoreableDelegate" class="spring04.aop.DefaultEncoreable" /&gt;&lt;aop:aspect&gt; &lt;aop:declare-parents types-matching="spring04.aop.Performance+" implement-interface="spring04.aop.Encoreable" delegate-ref="encoreableDelegate" /&gt; &lt;/aop:aspect&gt; 使用default-impl来直接标识委托和间接使用delegate-ref的区别在于后者是Spring bean，它本身可以被注入、通知或使用其他的Spring配置。]]></content>
      <categories>
        <category>JAVA</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring高级装配]]></title>
    <url>%2F2017%2F11%2F29%2Fspring%2Fseniorassembling%2F</url>
    <content type="text"><![CDATA[介绍根据Spring提供的多种技巧，实现更为高级的bean装配功能。 环境与profile配置profile bean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import javax.sql.DataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;import org.springframework.jndi.JndiObjectFactoryBean;@Configurationpublic class DataSourceConfig &#123; /* * 在开发环境下，使用的嵌入式数据库，预先加载数据 * 为dev profile装配的bean */ @Bean(destroyMethod = "shutdown") /* * @Profile()注解指定某个bean属于哪一个profile。 * 1. @Profile()注解可以使用在类上，也可以使用在方法级别上（3.2开始） * 2. @Profile()注解指定的dev profile激活才会创建相应的bean */ @Profile("dev") public DataSource embeddedDataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build(); &#125; /* * 生产环境，从JNDI容器中获取一个DataSource * 为prod profile装配bean */ @Bean @Profile("prod") public DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125; /* * 在QA环境，配置为Commons DBCP连接池 */// @Bean(destroyMethod = "close")// public DataSource dataSource()&#123;// BasicDataSource dataSource = new BasicDataSource();// dataSource.setUrl("jdbc:h2:tcp://dbserver/~/test");// dataSource.setDriverClassName("org.h2.Driver");// dataSource.setUserName("sa");// dataSource.setPassword("password");// dataSource.setInitialSize("20");// dataSource.setMaxActive(30);// // return dataSource;// &#125;&#125; 这三个版本的相同点是都会生成一个&lt;javax.sql.DataSource的bean&gt;。 XML中配置profile123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation=" http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- dev profile --&gt; &lt;beans profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource" type="H2"&gt; &lt;jdbc:script location="classpath:schema.sql" /&gt; &lt;jdbc:script location="classpath:test-data.sql" /&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;!-- prod profile --&gt; &lt;beans profile="prod"&gt; &lt;jee:jndi-lookup id="dataSource" lazy-init="true" jndi-name="jdbc/myDatabase" resource-ref="true" proxy-interface="javax.sql.DataSource" /&gt; &lt;/beans&gt; &lt;!-- qa profile --&gt; &lt;beans profile="qa"&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:url="jdbc:h2:tcp://dbserver/~/test" p:driverClassName="org.h2.Driver" p:userName="sa" p:password="password" p:initialSize="20" p:maxActive="30" /&gt; &lt;/beans&gt;&lt;/beans&gt; 这里有三个bean，类型都是&lt;javax.sql.DataSource&gt;，并且ID都是dataSource。但运行时只会创建激活状态的profile的bean。 激活profile激活需要依赖两个独立的属性： &lt;spring.profiles.active&gt; 先查找该文件，该文件的值就可以确定哪个profile的激活状态，如果该文件没有设置则查找default。 &lt;spring.profiles.default&gt; 一般两个属性组合使用。 @ActiveProfiles注解：指定要激活的profile 123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=TestConfig.class)@ActiveProfiles("dev")public class Test&#123; &#125; 条件化bean@Conditional注解：用在带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则，这个bean就会被忽略。例： 条件化配置bean 12345@Bean@Conditional(MagicExistsCondition.class)public MagicBean magicBean() &#123; return new MagicBean();&#125; 设置给@Conditional的类可以是任意实现了Condition接口的类型。实现matches方法，返回true或者false。 1234567public class MagicExistsCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment env = context.getEnvironment(); return env.containsProperty("magic"); &#125;&#125; 上面使用了ConditionContext接口： 1234567public interface ConditionContext&#123; BeanDefinitionRegistry getRegistry(); //检查bean定义 ConfigurableListableBeanFactory getBeanFactory(); //检查bean是否存在，探查bean属性 Environment getEnvironment(); //检查环境 变量是否存在以及它的值 ResourceLoader getResourceLoader(); //读取ResourceLoader所加载的资源 ClassLoader getClassLoader(); //加载并检查类是否存在&#125; AnnotatedTypeMetadata接口：检查带有@Bean注解的方法上还有什么其他的注解 123public interface ConditionContext&#123; boolean isAnnotated(String annotationType);&#125; @Profile注解实现从spring4开始，@Profile注解基于@Conditional和Condition实现。 @Profile注解如下所示： 1234567@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Documented@Conditional(ProfileCondition.class)public @interface Profile&#123; String[] value();&#125; @Profile注解使用了@Conditional注解，并且引用ProfileCondition作为Condition实现。 1234567891011121314151617public class ProfileCondition implements Condition&#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; if(context.getEnvironment() != null)&#123; MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if(attrs != null)&#123; for(Object value : attrs.get("value"))&#123; if(context.getEnvironment().acceptsProfiles(((String[]) value)))&#123; return true; &#125; &#125; return false; &#125; &#125; return false; &#125;&#125; ProfileCondition通过AnnotatedTypeMetadata得到了用于@Profile注解的所有属性。借助该信息，它会明确地检查value属性，该属性包含了bean的profile名称，然后，它根据通过ConditionContext得到的Environment来检查该profile是否处于激活状态。 处理自动装配的歧义性在自动装配时，如果有多个bean匹配结果时，这时就会产生自动装配歧义。Spring会抛出。Spring提供了多种方案解决这个问题，可以将可选bean中的某一个设为首选（primary）的bean，或者使用限定符（qualifier）将可选的bean范围缩小到只有一个bean。 标示首选的bean@Primary能够与@Component组合用在组件扫描的bean上，也可以与@Bean组合用在java配置的bean声明中。 1234567891011@Component@Primarypublic class IceCream implements Dessert&#123; &#125;@Bean@Primarypublic Dessert iceCream()&#123; return new iceCream();&#125; xml中使用： 1&lt;bean id="iceCream" class="com.desserteater.IceCream" primary="true" /&gt; 首选项标示多个也有可能产生歧义性。对于解决歧义性问题，限定符更强大。 限定自动装配的bean@Qualifier注解是使用限定符的主要方式，它可以与@Autowired和@Inject协同使用，在注入的时候指定想要注入进去的是哪一个bean。一般将beanID作为限定符。例： 123456@Autowired//iceCream参数是需要注入的bean的ID，缺点紧耦合，对类名（IceCream）改动容易导致限定符失效@Qualifier("iceCream") public void setDessert(Dessert dessert)&#123; this.dessert = dessert;&#125; 创建自定义限定符自定义限定符，最佳是为bean选择特性或描述性的术语。需要做的就是在bean声明上添加@Qualifier注解，可以与@Component注解组合使用，然后在注入的地方引用自定义限定符就可以。例： 12345678910111213//声明时指定限定符为“cold”@Component@Qualifier("cold")public class IceCream implements Dessert&#123; &#125;//注入时引用自定义限定符“cold”@Autowired@Qualifier("cold") public void setDessert(Dessert dessert)&#123; this.dessert = dessert;&#125; 当通过java配置显示定义bean时，@Qualifier可以与@Bean注解一起使用。例： 12345@Bean@Qualifier("cold")public Dessert iceCream()&#123; return new IceCream();&#125; 使用自定义的限定符自定义的面向特性的限定符要比基于beanID的限定符好一些。但如果自定义限定符存在多个的话也是会引起歧义的，而java不允许在同一条目上重复出现相同类型的多个注解（java8允许，只要这个注解本身在定义的时候带有@Repeatable注解就可以，但是Spring的@Qualifier注解并没有在定义时添加@Repeatable注解）。 解决方法是创建自定义限定符注解，它本身要使用@Qualifier注解来标注。例@Qualifier(“cold”)，我们使用自定义的@Cold注解，该注解定义为： 12345@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Cold&#123;&#125; 同样的，可以创建@Creamy注解 12345@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Creamy&#123;&#125; 使用时，在声明中添加上多个自定义限定符注解，注入时引用即可： 123456789101112131415161718192021//IceCream声明@Component@Cold@Creamypublic class IceCream implements Dessert&#123;&#125;//Popsicle声明@Component@Cold@Fruitypublic class Popsicle implements Dessert&#123;&#125;//注入@Autowired@Cold@Creamypublic void setDessert(Dessert dessert)&#123; this.dessert = dessert;&#125; bean的作用域在默认情况下，Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。但如果你使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。这种情况将class声明为单例是不合理的，因为对象会被污染。 Spring定义了多种作用域，可以基于这些作用域创建bean，包括： 作用域 描述 单例（Singleton） 在整个应用中，只创建bean的一个实例 原型（Prototype） 每次注入或者通过spring应用上下文获取，都会创建一个新的bean实例 会话（Session） 在Web应用中，为每个会话创建一个bean实例 请求（Request） 在Web应用中，为每个请求创建一个bean实例 可以使用@Scope注解设置bean的作用域。 组件扫描声明bean： 12345@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad&#123;&#125;//也可以使用@Scope("prototype"),这样容易出错，SCOPE_PROTOTYPE是类型安全的 java配置中声明bean 12345@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad() &#123; return new Notepad();&#125; xml配置中声明bean 1&lt;bean id="notepad" class="com.spring.Notepad" scope="prototype" /&gt; 使用会话和请求作用域就购物车bean来说，会话作用域最合适，它与给定的用户关联性最大。可以使用@Scope注解： 12345@Component@Scope(value=WebApplicationContext.SCOPE_SESSION, //将作用域设置成会话 proxyMode=ScopedProxyMode.INTERFFACES)public ShoppingCart cart()&#123;&#125; 上面@Scope注解还有用到一个属性proxyMode，表示作用域代理。理解下这个会话作用域。例： 1234567@Componentpublic class StoreService&#123; @Autowired public void setShoppingCart(ShoppingCart shoppingCart)&#123; this.shoppingCart = shoppingCart; &#125;&#125; 因为StoreService是一个单例的bean，会在spring应用上下文加载的时候创建。当它创建时，spring会试图将ShoppingCart注入到setShoppingCart()方法中。但是ShoppingCart bean是会话作用域的，此时并不存在，直到用户进入创建了会话才会出现ShoppingCart 的实例，此外，ShoppingCart 的实例有多个，我们不会让spring注入某个固定的ShoppingCart 的实例，我们希望注入的ShoppingCart 的实例恰好就是当前会话所对应的那一个。 Spring会注入一个ShoppingCart bean的代理，如下图： 这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为它就是一个购物车，但当StoreService调用ShoppingCart 的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。 理解了上面作用域，下面看下proxyMode这个属性： 这个属性解决了将会话或请求的bean注入到单例bean中所遇到的问题。 ScopedProxyMode.INTERFFACES：表明这个代理要实现ShoppingCart 接口，并将调用委托给实现bean。 如果ShoppingCart 是具体类的话，spring没办法创建基于接口的代理，它必须使用CGLib来生成基于类的代理。所以必须将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，表明要以生成目标类扩展的方式创建代理。 在xml中声明作用域代理在xml中设置代理模式，需要使用Spring aop命名空间的一个新元素： 12345&lt;bean id="cart" class="com.spring.ShoppingCart" scope="session"&gt; &lt;aop:scope-proxy /&gt; //作用同@Scope,默认情况下使用CGLib创建目标类的代理 //可以将proxy-target-class属性设置为false，进行基于接口的代理 &lt;aop:scope-proxy proxy-target-class="false" /&gt; &lt;/bean&gt; 使用aop:scope-proxy元素，需要在XML配置中声明Spring的aop命名空间： 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 运行时值注入为了避免硬编码，让硬编码的值在运行时再确定，Spring提供了两种运行时求值的方式： 属性占位符（Property placeholder） Spring表达式语言（SpEL） 属性占位符在Spring中，处理外部值最简单的方式就是声明属性源并通过Spring的Environment来检索属性。例：一个基本的Spring配置类： 1234567891011121314151617/* * 引入资源文件 */@Configuration@PropertySource("classpath:/com/spring/externals/app.properties") //声明属性源public class ExpressiveConfig&#123; @Autowired Environment env; @Bean public BlankDisc disc()&#123; return new BlankDisc( env.getProperty("disc.title"), env.getProperty("disc.artist") ); &#125;&#125; @PropertySource引用了一个app.properties文件： 12disc.title=Sgt. Peppers Lonely Hearts Club Banddisc.artist=The Beatles 这个属性文件会加载到Spring的Environment中，可以调用getProperty()方法得到属性值。 深入学习Spring的Environment123456789101112131415161718192021222324/* *getProperty()方法的四种重载形式： */String getProperty(String key);//属性没定义，获取到nullString getProperty(String key, String defaultValue);//默认值，例：env.getProperty("disc.title","hello")T getProperty(String key, Class&lt;T&gt; type);T getProperty(String key, Class&lt;T&gt; type, T defaultValue);//获取连接池中所维持的连接数量int connectionCount = env.getProperty("db.count", Integer.class, 30);/* *其他方法 */String getRequiredProperty(String key); //属性必须定义，否则抛IllegalStateException异常boolean containsProperty(String key); //检查某个属性是否存在//将属性解析为类。例：Class&lt;CompactDisc&gt; cdClass = env.getPropertyAsClass("disc.class",CompactDisc.class);/* *检查profile激活的方法 */String[] getActiveProfiles(); //返回激活profile名称的数组String[] getDefaultProfiles(); //返回默认profile名称的数组boolean acceptsProfiles(String profiles);//如果environment支持给定profile的话，就返回true 解析属性占位符在Spring装配中，占位符的形式为使用“${…}”包装的属性名称。例： XML中使用： 1234567891011121314/* * XML中配置并解析占位符 */&lt;bean id="sgtPeppers" class="com.spring.BlankDisc" c:_title="$&#123;disc.title&#125;" c:_artist="$&#123;disc.artist&#125;" /&gt; /* * 使用占位符 * 使用xml配置生成PropertySourcePlaceholderConfigurer bean */&lt;context:property-placeholder /&gt;//&lt;context:property-placeholder location="com/spring/app.properties" /&gt; 依赖组件扫描和自动装配： 1234567891011121314151617/* * java配置中配置并解析占位符 *///自动装配就没有指定占位符的配置文件或类，可以使用@Value注解public BlankDisc(@Value("$&#123;disc.title&#125;") String title, @Value("$&#123;disc.artist&#125;") String artist)&#123; this.title = title; this.artist = artist;&#125;/* * 使用占位符 * 必须配置一个PropertySourcePlaceholderConfigurer bean,它能够基于Spring的Environment及其属性源解析占位符。如下的@Bean方法在java中配置 */@Beanpublic static PropertySourcePlaceholderConfigurer placeholderConfigurer()&#123; return new PropertySourcePlaceholderConfigurer();&#125; Spring表达式语言Spring表达式语言（Spring Expression Language, SpEL），它能够以一种强大和简介的方式将值装配到bean属性和构造器参数中，这个表达式会在运行时计算得到值。SpEL拥有很多特性，包括： 使用bean的ID来引用bean； 调用方法和访问对象的属性； 对值进行算术、关系和逻辑运算； 正则表达式匹配； 集合操作。 SpEL样例SpEL表达式要放到#{…}之中，例： 12#&#123;1&#125; //数字常量，值为1#&#123;T(System).currentTimeMillis()&#125;//当前时间的毫秒数 SpEL表达式也可以引用其他bean或其他bean的属性。引用系统属性。例： 12#&#123;sgtPeppers.artist&#125;//ID为sgtPeppers的bean的artist属性#&#123;systemProperties['disc.title']&#125;//通过systemProperties对象引用系统属性 bean装配时使用表达式： 通过组件扫描bean，在注入属性和构造器参数时，使用@Value注解。例： 123456//从系统属性中获取专辑和艺术家名字public BlankDisc(@Value("#&#123;systemProperties['disc.title']&#125;") String title, @Value("#&#123;systemProperties['disc.artist']&#125;") String artist) &#123; this.title=title; this.artist=artist;&#125; 在XML中，将SpEL表达式传入或的value属性中，或者将其作为p-命名空间或c-命名空间条目的值。例： 1234&lt;bean id="sgtPeppers" class="com.spring.BlankDisc" c:_title="#&#123;systemProperties['disc.title']&#125;" c:_artist="#&#123;systemProperties['disc.artist']&#125;"/&gt; 下面学习SpEL所支持的基础表达式。 表示字面值SpEL不仅可以表示整数字面量，还可以表示浮点数、String值以及Boolean值。例： 1234#&#123;3.1415&#125; //浮点数#&#123;9.87E4&#125; //98700#&#123;'hello'&#125; //String#&#123;false&#125; //boolean 引用bean、属性和方法12345678910//引用bean-将一个bean装配到另外一个bean的属性中，使用bean ID作为表达式#&#123;sgtPeppers&#125;//引用bean属性#&#123;sgtPeppers.artist&#125;//引用bean方法#&#123;artistSelector.selectArtist()&#125;//名称大写，这样可能出现NullPointerException#&#123;artistSelector.selectArtist().toUpperCase()&#125;//类型安全的运算符，返回值不为null才调用toUpperCase(),否则返回null#&#123;artistSelector.selectArtist()?.toUpperCase()&#125; 在表达式中使用类型如果在SpEL中访问类作用域的方法和常量的话，要依赖T()这个关键运算符。T()运算符的结果表示一个Class对象。例： 123456//代表java.lang.Math类T(java.lang.Math)//将PI值装配到bean属性中T(java.lang.Math).PI//调用静态方法和常量T(java.lang.Math).random() SpEL运算符用来操作表达式值的SpEL运算符： 运算符类型 运算符 算术运算 +、-、*、/、%、^ 比较运算 &lt;、&gt;、==、&lt;=、&gt;=、it、gt、eq、le、ge 逻辑运算 and、or、not、\ 条件运算 ?: (ternary)、?: (Elvis) 正则表达式 matches 例： 123456789101112//计算circle bean所定义的圆的周长#&#123;2 * T(java.lang.Math).PI * circle.radius&#125;//计算圆面积#&#123;T(java.lang.Math).PI * circle.radius ^ 2&#125;//String类型使用 + 表示连接#&#123;disc.title + 'by' + disc.artist&#125;//比较运算符中和文本符号效果相同#&#123;counter.total == 100&#125;#&#123;counter.total eq 100&#125;//三元运算符检查null值#&#123;scoreboard.score &gt; 1000 ? "Winner" : "Loser"&#125;#&#123;disc.title ?: 'Hello'&#125; //默认替代null，如果disc.title为null，则表达式值为Hello 计算正则表达式SpEL通过matches运算符支持表达式中的模式匹配。例： 1#&#123;admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'&#125; 计算集合SpEL可以操作集合和数组。例： 引用列表中的一个元素： 1#&#123;jukebox.songs[4].title&#125; //计算集合中第五个元素 随机播放歌曲： 12//[]运算符用来从集合或数组中按照索引获取元素#&#123;jukebox.songs[T(java.lang.Math).random() * jukebox.songs.size()].title&#125; 从String中获取一个字符： 1#&#123;'This is a test'[3]&#125;//获得“s” 查询运算符（.?[]），对集合进行过滤，得到集合的一个子集： 12//得到jukebox中artist属性为Aerosmith的所有歌曲#&#123;jukebox.songs.?[artist eq 'Aerosmith']&#125; 查询运算符（.^[]）和（.$[]）分别用来在集合中查询第一个匹配项和最后一匹配项： 12//查找列表中第一个artist属性为Aerosmith的歌曲#&#123;jukebox.songs.^[artist eq 'Aerosmith']&#125; 投影运算符（.![]），从集合的每个成员中选择特定的属性放到另外一个集合中。例： 12//获得所有歌曲名称的集合，而不是所有歌曲对象的集合#&#123;jukebox.songs.![title]&#125; 实际上，投影运算符可以与其他任意的SpEL运算符一起使用。例：使用如下表达式获得Aerosmith所有歌曲的名称列表： 1#&#123;jukebox.songs.?[artist eq 'Aerosmith'].![title]&#125; ​]]></content>
      <categories>
        <category>JAVA</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring装配bean]]></title>
    <url>%2F2017%2F11%2F25%2Fspring%2Fspring01%2F</url>
    <content type="text"><![CDATA[介绍在Spring中，对象无需自己查找或创建与其所关联的其他对象，容器负责把需要相互协作的对象引用赋予各个对象。创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入的本质。Spring提供了四种主要的装配机制： 隐式的bean发现机制和自动装配 在java中进行显示配置（javaConfig） 在XML中进行显示配置 混合配置 例子程序中通用的接口CD接口： 123public interface CompactDisc &#123; void play();&#125; CDPlayer接口： 123public interface MediaPlayer &#123; void play();&#125; 自动化装配beanSpring从两个角度来实现自动化装配： 组件扫描（component scanning）：Spring 会自动发现应用上下文中创建的bean。 自动装配（autowiring）：Spring自动满足bean之间的依赖。 带有@Component注解的实现类 123456789101112131415161718/** @Component * 1. spring会为所有带@Component注解的类创建为bean* 2. 为组件扫描的bean命名：默认为类名第一个字母小写。例：sgtPeppers* 3. 为组件扫描的bean命名：@Component("rename"), @Named("rename")*/@Component public class SgtPeppers implements CompactDisc&#123; private String title = "Lonely Hearts"; private String artist = "The Beatles"; @Override public void play() &#123; System.out.println("Playing " + title + "by " + artist); &#125;&#125; @ComponentScan注解启用扫描组件 12345678910111213@Configuration/* * @ComponentScan* 1. 启用组件扫描,在spring中组件扫描默认不启用* 2. 如果没有其他配置，@ComponentScan会默认扫描与配置类相同的包,查找@Component * 3. 设置组件扫描基础包：@ComponentScan("spring02.assemble.automatic")* 3. 设置组件扫描基础包：@ComponentScan(basePackages="spring02.assemble.automatic")* 3. 设置组件扫描基础包：@ComponentScan(basePackages=&#123;"com.01", "com.02"&#125;)* 4. 设置组件类：@ComponentScan(basePackageClasses=&#123;SgtPeppers.class, CDPlayer.class&#125;)*/@ComponentScan("spring02.assemble.automatic") public class CDPlayerConfig &#123;&#125; @Autowired注解实现自动装配：让Spring自动满足bean依赖 123456789101112131415161718192021@Componentpublic class CDPlayer implements MediaPlayer&#123; private CompactDisc cd; /* * @Autowired * 1. @Autowired注解可以用在任意方法上 * 2. 如果找不到bean匹配则会抛出异常，可以将@Autowired的required属性设成false避免抛出异常 * 2. @Autowired(required=false)，匹配不上会让bean处于未装配状态 * 3. @Autowired注解的替代注解@Inject,后者同时定义了@Named注解 * 4. 多个bean匹配会产生自动装配的歧义性 */ @Autowired public CDPlayer(CompactDisc cd)&#123; this.cd = cd; &#125; @Override public void play() &#123; cd.play(); &#125;&#125; 验证自动装配 1234567891011121314151617181920212223242526272829303132333435/** @RunWith* @RunWith使用了Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文*/@RunWith(SpringJUnit4ClassRunner.class)/** @ContextConfiguration* @ContextConfiguration会告诉测试类要在CDPlayerConfig中加载配置，因为CDPlayerConfig包含了@ComponentScan*/@ContextConfiguration(classes=CDPlayerConfig.class)public class CDPlayerTest &#123; @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog(); @Autowired /*自动注解标识*/ private CompactDisc cd; @Autowired private MediaPlayer player; /* * 测试组件扫描能够发现CompactDisc */ @Test public void cdShouldNotBeNull()&#123; assertNotNull(cd); &#125; @Test public void play() &#123; player.play(); assertEquals("Playing Lonely Heartsby The Beatles\n", log.getLog()); &#125;&#125; 通过java代码装配bean创建配置类： 12345678910111213141516171819202122/** @Configuration* @Configuration表明这个类是配置类，该类应该包含在Spring应用上下文中如何创建bean的细节*/@Configurationpublic class CDPlayerConfig &#123; /* * @Bean * 1. @Bean注解会返回一个Spring应用上下文中的bean * 2. @Bean的ID默认与方法名同名，例：compactDisc * 2. 重新设置@Bean的名字：@Bean(name="rename") */ @Bean public CompactDisc compactDisc()&#123; return new SgtPeppers(); &#125; @Bean public CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc); &#125;&#125; 实现类和以及测试类同上。 通过XML装配beanXML配置规范： 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- configuration details go here--&gt;&lt;/beans&gt; 通用实现类和测试类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** 非字面量SgtPeppers实现类*/public class SgtPeppers implements CompactDisc &#123; private String title = "Sgt. Pepper's Lonely Hearts Club Band"; private String artist = "The Beatles"; public void play() &#123; System.out.println("Playing " + title + " by " + artist); &#125;&#125;/** * 测试字面量实现类 */public class BlankDisc implements CompactDisc &#123; private String title; private String artist; public BlankDisc(String title, String artist) &#123; this.title = title; this.artist = artist; &#125; public void play() &#123; System.out.println("Playing " + title + " by " + artist); &#125;&#125;/** * 测试集合实现类 * collections包下 */public class BlankDisc implements CompactDisc &#123; private String title; private String artist; private List&lt;String&gt; tracks; public BlankDisc(String title, String artist, List&lt;String&gt; tracks) &#123; this.title = title; this.artist = artist; this.tracks = tracks; &#125; public void play() &#123; System.out.println("Playing " + title + " by " + artist); for (String track : tracks) &#123; System.out.println("-Track: " + track); &#125; &#125;/** * 测试属性实现类 * properties包下 */public class BlankDisc implements CompactDisc &#123; private String title; private String artist; private List&lt;String&gt; tracks; public void setTitle(String title) &#123; this.title = title; &#125; public void setArtist(String artist) &#123; this.artist = artist; &#125; public void setTracks(List&lt;String&gt; tracks) &#123; this.tracks = tracks; &#125; public void play() &#123; System.out.println("Playing " + title + " by " + artist); for (String track : tracks) &#123; System.out.println("-Track: " + track); &#125; &#125;&#125; public class CDPlayer implements MediaPlayer&#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd)&#123;//cd构造器参数名 this.cd = cd; &#125; @Override public void play() &#123; cd.play(); &#125;&#125;/** * 测试属性实现类 * properties包下 */public class CDPlayer implements MediaPlayer &#123; private CompactDisc compactDisc; @Autowired public void setCompactDisc(CompactDisc compactDisc) &#123;//compactDisc属性名 this.compactDisc = compactDisc; &#125; public void play() &#123; compactDisc.play(); &#125;&#125; @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:springXML02/ConstructorArgReferenceTest-context.xml")public class ConstructorArgReferenceTest &#123; @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog(); @Autowired private MediaPlayer player; @Test public void play() &#123; player.play(); assertEquals("Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n", log.getLog()); &#125;&#125; 下面进行说明XML配置的几种情况： 构造器注入bean引用 12345&lt;bean id="compactDisc" class="spring02.assemble.xml.SgtPeppers" /&gt; &lt;bean id="cdPlayer" class="spring02.assemble.xml.CDPlayer"&gt; &lt;constructor-arg name = "compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; 将字面量注入到构造器中 12345678&lt;bean id="compactDisc" class="spring02.assemble.xml.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" /&gt; &lt;constructor-arg value="The Beatles" /&gt;&lt;/bean&gt; &lt;bean id="cdPlayer" class="spring02.assemble.xml.CDPlayer"&gt; &lt;constructor-arg ref="compactDisc" /&gt;&lt;/bean&gt; 通过构造器装配集合 12345678910111213141516171819202122232425&lt;bean id="compactDisc" class="spring02.assemble.xml.collections.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" /&gt; &lt;constructor-arg value="The Beatles" /&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She's Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I'm Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; &lt;bean id="cdPlayer" class="spring02.assemble.xml.CDPlayer"&gt; &lt;constructor-arg ref="compactDisc" /&gt;&lt;/bean&gt; 构造器注入bean引用 — c-命名模式 123456&lt;!-- c-命名模式：需要在beans中引入c --&gt; xmlns:c="http://www.springframework.org/schema/c"&lt;bean id="compactDisc" class="spring02.assemble.xml.SgtPeppers" /&gt;&lt;!-- c-命名模式：c指前缀,cd指构造器参数名,-ref指注入bean引用,value指要注入的ID --&gt; &lt;bean id="cdPlayer" class="spring02.assemble.xml.CDPlayer" c:cd-ref="compactDisc" /&gt; 将字面量注入到构造器中 — c-命名模式 1234567&lt;!-- c-命名模式：可以用占位符表示参数的位置，xml中不允许数字作为属性的第一个字符，所以加_前缀 --&gt; &lt;bean id="compactDisc" class="spring02.assemble.xml.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles"&gt;&lt;/bean&gt; &lt;!-- c-命名模式：当只有一个时可以只写_ --&gt; &lt;bean id="cdPlayer" class="spring02.assemble.xml.CDPlayer" c:_-ref="compactDisc" /&gt; 属性注入bean引用 12345678&lt;bean id="compactDisc" class="spring02.assemble.xml.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" /&gt; &lt;constructor-arg value="The Beatles" /&gt;&lt;/bean&gt; &lt;bean id="cdPlayer" class="spring02.assemble.xml.properties.CDPlayer"&gt; &lt;property name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; 将字面量注入到属性中 1234567891011121314151617181920212223242526&lt;bean id="compactDisc" class="spring02.assemble.xml.properties.BlankDisc"&gt; &lt;property name="title" value="Sgt. Pepper's Lonely Hearts Club Band" /&gt; &lt;property name="artist" value="The Beatles" /&gt; &lt;property name="tracks"&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She's Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I'm Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id="cdPlayer" class="spring02.assemble.xml.properties.CDPlayer" &lt;property name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; 属性注入bean引用 — p-命名模式（规则同c-命名模式） 123456789101112&lt;!-- p-命名模式：需要在beans中引入p --&gt; xmlns:p="http://www.springframework.org/schema/p" &lt;bean id="compactDisc" class="spring02.assemble.xml.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" /&gt; &lt;constructor-arg value="The Beatles" /&gt;&lt;/bean&gt; &lt;!-- p-命名模式：p指前缀,compactDisc指属性名,-ref指注入bean引用,value指要注入的ID --&gt; &lt;bean id="cdPlayer" class="spring02.assemble.xml.properties.CDPlayer" p:compactDisc-ref="compactDisc"&gt;&lt;/bean&gt; 将字面量注入到属性中 — p-命名模式 12345678910111213141516171819202122232425&lt;bean id="compactDisc" class="spring02.assemble.xml.properties.BlankDisc" p:title="Sgt. Pepper's Lonely Hearts Club Band" p:artist="The Beatles"&gt; &lt;property name="tracks"&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She's Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I'm Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id="cdPlayer" class="spring02.assemble.xml.properties.CDPlayer" p:compactDisc-ref="compactDisc"&gt;&lt;/bean&gt; 将字面量注入到属性中 — util-命名模式 123456789101112131415161718192021222324&lt;bean id="compactDisc" class="spring02.assemble.xml.properties.BlankDisc" p:title="Sgt. Pepper's Lonely Hearts Club Band" p:artist="The Beatles" p:tracks-ref="trackList"&gt;&lt;/bean&gt;&lt;util:list id="trackList"&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She's Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I'm Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt;&lt;/util:list&gt;&lt;bean id="cdPlayer" class="spring02.assemble.xml.properties.CDPlayer" p:compactDisc-ref="compactDisc" /&gt;&lt;/bean&gt; Spring util-命名空间中的元素 | 元素 | 描述 || :——————–: | :——————————–: || util:constant | 引用某个类型的public static域，并将其暴露为bean || util:list | 创建一个java.util.List类型的bean，其中包含值或引用 || util:map | 创建一个java.util.Map类型的bean，其中包含值或引用 || util:properties | 创建一个java.util.Properties类型的bean || util:properties-path | 引用一个bean的属性（或内嵌属性），并将其暴露为bean || util:set | 创建一个java.util.Set类型的bean，其中包含值或引用 | 导入和混合配置通用实现类： 123456789101112131415161718192021222324252627282930public class BlankDisc implements CompactDisc &#123; private String title; private String artist; private List&lt;String&gt; tracks; public BlankDisc(String title, String artist, List&lt;String&gt; tracks) &#123; this.title = title; this.artist = artist; this.tracks = tracks; &#125; public void play() &#123; System.out.println("Playing " + title + " by " + artist); for (String track : tracks) &#123; System.out.println("-Track: " + track); &#125; &#125;&#125;public class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; public void play() &#123; cd.play(); &#125;&#125; javaConfig中引入XML配置 配置类： 123456789101112131415161718/** CDPlayer采用javaConfig方式* xml需要将cd引进来*/@Configurationpublic class CDPlayerConfig &#123; @Bean public CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc); &#125;&#125;@Configuration@Import(CDPlayerConfig.class)@ImportResource("classpath:springXML02/ImportXmlConfigTest-config.xml")public class SoundSystemConfig &#123;&#125; 测试类： 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=SoundSystemConfig.class)public class ImportXmlConfigTest &#123; @Autowired private MediaPlayer player; @Test public void play() &#123; player.play(); &#125;&#125; xml文件： 123456789101112131415&lt;!-- xm需要将cd引进来 --&gt;&lt;bean id="compactDisc" class="spring02.assemble.mixdconfig.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;!-- ...other tracks omitted for brevity... --&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; XML配置中引入javaConfig 配置类： 12345678910/** CDConfig在XML文件中被引入进来*/@Configurationpublic class CDConfig &#123; @Bean public CompactDisc compactDisc() &#123; return new SgtPeppers(); &#125;&#125; 测试类： 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:springXML02/ImportJavaConfigSystemTest-config.xml")public class ImportJavaConfigSystemTest &#123; @Autowired private MediaPlayer player; @Test public void play() &#123; player.play(); &#125;&#125; xml文件： 12345678910&lt;!-- 使用第三方配置文件将两个组合起来，在xml中引入javaConfig --&gt; &lt;bean class="spring02.assemble.mixdconfig.CDConfig" /&gt;&lt;import resource="ImportJavaConfigTest-config.xml" /&gt; &lt;!-- 第三方配置文件需要引入的xml文件ImportJavaConfigTest-config.xml --&gt; &lt;bean id="cdPlayer" class="spring02.assemble.mixdconfig.CDPlayer" c:cd-ref="compactDisc" /&gt; ​]]></content>
      <categories>
        <category>JAVA</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring概述]]></title>
    <url>%2F2017%2F11%2F25%2Fspring%2Fspring00%2F</url>
    <content type="text"><![CDATA[介绍Spring是一个开源框架，是一个轻量级的控制反转（IoC）和面前切面（AOP）的容器框架。创建Spring主要是为了解决企业级应用开发的复杂性，简化java开发。为了降低开发的复杂性，Spring采取了以下4种关键策略： 基于POJO的轻量级和最小侵入性编程； 通过依赖注入和面向接口实现松耦合； 基于切面和惯例进行声明式编程； 通过切面和模板减少样板式代码。 spring允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发，并且包含并管理应用对象的生命周期。 Spring作用 容器 提供了对多种技术的支持 JMS MQ支持 UnitTest …等 AOP（事务管理、日志等） 提供了众多方便应用的辅助类（JDBC Template等） 对主流框架（Hibernate等）提供了良好的支持 构建企业级应用（SpringMVC+Spring+Hibernate/MyBatis） Spring框架Spring官网上给出的框架由6个定义良好的模块分类组成： Spring核心容器管理着Spring应用中bean的创建、配置和管理。在该模块中包括了Spring bean工厂和Spring应用上下文的实现。所有的Spring模块都构建于核心容器之上。 Spring的AOP模块在AOP模块中，Spring对面向切面编程提供了丰富的支持。 数据访问与集成Spring基于模板的数据抽象简化样板代码；包含了在JMS之上构建的Spring抽象层，支持消息以异步的方式与其他应用集成；此外，本模块会使用SpringAOP模块为Spring应用中的对象提供事务管理服务。 WEB与远程调用构建web应用的MVC模式；提供了多种构建与其他应用交互的远程调用方案。 InstrumentationSpring的Instrumentation模块提供了为JVM添加代理（agent）的功能。 测试Spring应用的测试。Spring为使用JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象实现；对于集成测试，该模块为加载Spring应用上下文中的bean集合以及与Spring上下文中的bean进行交互提供了支持。 Spring容器容器是Spring框架的核心。Spring容器负责创建对象，装配对象，配置对象并管理对象的整个生命周期。Spring容器使用DI管理构成应用的组件，创建相互协作的组件之间的关联。Spring自带了多个容器实现，可以归为两种不同的类型： bean工厂bean工厂由&lt;org.springframework.beans.factory.eanFactory&gt;接口定义，是最简单得容器，提供最基本的DI支持。 bean的生命周期： 上图是bean在Spring容器中从创建到销毁经历的若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。 bean容器初始化 基础：两个包 &lt;org.springframework.beans&gt; BeanFactory提供配置结构和基本功能，加载并初始化Bean &lt;org.springframework.context&gt; ApplicationContext保存了Bean对象并在Spring中被广泛使用 方式-ApplicationContext 本地文件 12FileSystemXmlApplicationContext context = new FileSystemXmlApplicationContext("F:/workspace/appcontext.xml"); Classpath 12ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring-context.xml"); Web应用中依赖servlet或Listener 12345678&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 应用上下文应用上下文由&lt;org.springframework.context.ApplicationContext&gt;接口定义，基于BeanFactory构建，并提供应用框架级别的服务。Spring自带了多种类型的应用上下文： 从一个或多个基于java的配置类中加载Spring应用上下文。 从一个或多个基于java的配置类中加载Spring Web应用上下文。 从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。 从文件系统下的一个或多个XML配置文件中加载上下文定义。 从Web应用下的一个或多个XML配置文件中加载上下文定义。 IOC控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。（获得依赖对象的过程被反转了） DI：依赖注入是其一种实现方式。目的是创建对象并且组装对象之间的关系。通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系。DI能够让相互协作的软件保持松散耦合。 Spring常用的注入方式： 设值注入-从set方法自动获取 12345&lt;bean id="cdPlayer" class="spring02.assemble.xml.properties.CDPlayer"&gt; &lt;property name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; &lt;bean id="compactDisc" class="spring02.assemble.xml.BlankDisc"&gt;&lt;/bean&gt; 构造注入-从构造器中自动获取 12345&lt;bean id="cdPlayer" class="spring02.assemble.xml.CDPlayer"&gt; &lt;constructor-arg name = "compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; &lt;bean id="compactDisc" class="spring02.assemble.xml.SgtPeppers"&gt;&lt;/bean&gt; AOP面向切面编程（aspect-oriented-programming）：把遍布应用各处的功能分离出来形成可重用的组件。]]></content>
      <categories>
        <category>JAVA</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序应用]]></title>
    <url>%2F2017%2F11%2F20%2Falgorithm%2Fsortapplication%2F</url>
    <content type="text"><![CDATA[介绍 排序之所以很有用是因为在一个有序的数组中查找一个元素要比在一个无序的数组中查找简单得多。 二分查找法算法使用两个变量lo和hi，并保证如果该键在数组中则它一定在a[lo…hi]中，方法在循环中不断将数组的中间键（索引为mid）和被查找的键比较，如果被查找的键等于a[mid]，则返回mid，否则算法就将查找范围缩小一半。 1234567891011121314151617181920212223242526272829303132333435363738public class BinarySearch &#123; private BinarySearch() &#123; &#125; public static int rank(int key, int[] a) &#123; return indexOf(a, key); &#125; public static int indexOf(int[] a, int key) &#123; int lo = 0; int hi = a.length - 1; while (lo &lt;= hi) &#123; // Key is in a[lo..hi] or not present. int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) hi = mid - 1; else if (key &gt; a[mid]) lo = mid + 1; else return mid; &#125; return -1; &#125; public static void main(String[] args) &#123; // read the integers from a file In in = new In(args[0]); int[] whitelist = in.readAllInts(); // sort the array Arrays.sort(whitelist); // read integer key from standard input; print if not in whitelist while (!StdIn.isEmpty()) &#123; int key = StdIn.readInt(); if (BinarySearch.indexOf(whitelist, key) == -1) StdOut.println(key); &#125; &#125;&#125; 多种排序方法 Comparable接口 实现Comparable接口只需要定义一个compareTo()方法并在其中定义该数据类型的中大小关系即可。 Comparator接口 比较器Comparator接口允许我们在一个类中实现多种排序方法。它只有一个compare()方法来比较两个对象。如果一种数据类型实现了这个接口，我们就可以将将另一个实现了Comparator接口的对象传递给sort()方法，sort()方法再传递给less()方法。 Comparator接口允许我们为任意数据类型定义多种排序方法。用Comparator接口来替代Comparable接口能够更好地将数据类型的定义和两个该类型的对象应该如何比较的定义区分开来。 一个元素的多种属性都可能被用作排序的键。例如： 使用了Comparator的插入排序123456789101112131415161718public static void sort(Object[] a, Comparator comparator) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1], comparator); j--) &#123; exch(a, j, j-1); &#125; &#125;&#125;private static boolean less(Object v, Object w, Comparator comparator) &#123; return comparator.compare(v, w) &lt; 0;&#125;private static void exch(Object[] a, int i, int j) &#123; Object swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 使用比较器实现优先队列sort()方法每次比较中都会回调Transaction类中用例指定的compare()方法，为了避免每次排序都会创建一个新的Comparator对象，使用final来定义这些比较器。 12345678910111213141516171819202122232425262728293031323334public class Transaction &#123; //... private final String who; // customer private final Date when; // date private final double amount; // amount //... public static class WhoOrder implements Comparator&lt;Transaction&gt; &#123; @Override public int compare(Transaction v, Transaction w) &#123; return v.who.compareTo(w.who); &#125; &#125; public static class WhenOrder implements Comparator&lt;Transaction&gt; &#123; @Override public int compare(Transaction v, Transaction w) &#123; return v.when.compareTo(w.when); &#125; &#125; public static class HowMuchOrder implements Comparator&lt;Transaction&gt; &#123; @Override public int compare(Transaction v, Transaction w) &#123; if(v.amout &lt; w.amout) return -1; if(v.amout &gt; w.amout) return 1; return 0; &#125; &#125;&#125; 要将Transaction对象的数组按照时间排序可以调用： Insertion.sort(a, new Transaction.WhenOrder()); 或者按照金额排序： Insertion.sort(a, new Transaction.HowMuchOrder()); 稳定性如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是稳定的。从另一个键上排序的稳定性如图： 各种排序算法的性能特定 取决于输入元素的排列情况；2. 运行效率由概率提供保证 快速排序是最快的通用排序算法。在大多数实际情况中，快速排序是最佳选择，但如果稳定性很重要而空间又不是问题，归并排序可能是最好的。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2017%2F11%2F19%2Falgorithm%2Fheapsort%2F</url>
    <content type="text"><![CDATA[介绍堆排序可以分为两个阶段。在堆的构造阶段中，我们将原始数组重新组织安排进一个堆中；然后在下沉排序阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。在排序中将直接使用swim（）和sink（）操作，这样在排序时就可以将需要排序的数组本身作为堆，因此不需要任何额外空间。 堆的构造由N个给定的元素构造一个堆，我们可以在NlogN成正比的时间内完成这项任务，只需要从左至右遍历数组，用swim（）保证扫描指针左侧的所有元素已经是一颗堆有序的完全树即可，就像连续向优先队列中插入元素一样。 另一个更聪明高效的方法是从右至左用sink（）函数构造子堆。数组的每个位置都已经是一个子堆的根结点了，sink（）对于这些子堆也适用。如果一个结点的两个子结点都已经是堆了，那么在该结点上调用sink（）可以将它们变成一个堆。这个过程会递归地建立起堆的秩序。堆的构造和下沉排序图： 说明：用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换。 证明：例如构造一个127个元素的堆，我们会处理32个大小为3的堆，16个大小为7的堆，8个大小为15的堆，4个大小为31的堆，2个大小为63的堆和1个大小为127的堆，因此最坏情况下需要32 1 + 16 2 + 8 3 + 4 4 + 2 5 + 1 6 = 120次交换，以及两倍的比较。 堆排序下沉排序主要思想：将堆中的最大元素删除，然后放入堆缩小后数组中空出来的位置。这个过程和选择排序类似（按照降序取出所有元素），但所需的比较要少得多，因为对提供了一种从未排序部分找到最大元素的有效方法。 这段代码完整实现了这些思想，也是经典的堆排序算法。用sink（）方法将a[1]到a[N]的元素排序。for循环构造了堆，然后while循环将最大的元素a[1]和a[N]交换并修复了堆，如此重复直到堆变空。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Heap &#123; private Heap() &#123; &#125; public static void sort(Comparable[] pq) &#123; int n = pq.length; //构造堆 for (int k = n/2; k &gt;= 1; k--) &#123; sink(pq, k, n); &#125; //下沉排序中销毁堆 while (n &gt; 1) &#123; exch(pq, 1, n--); sink(pq, 1, n); &#125; &#125; private static void sink(Comparable[] pq, int k, int n) &#123; while (2*k &lt;= n) &#123; int j = 2*k; if (j &lt; n &amp;&amp; less(pq, j, j+1)) &#123; j++; &#125; if (!less(pq, k, j)) &#123; break; &#125; exch(pq, k, j); k = j; &#125; &#125; private static boolean less(Comparable[] pq, int i, int j) &#123; return pq[i-1].compareTo(pq[j-1]) &lt; 0; &#125; private static void exch(Object[] pq, int i, int j) &#123; Object swap = pq[i-1]; pq[i-1] = pq[j-1]; pq[j-1] = swap; &#125; private static void show(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; StdOut.println(a[i]); &#125; &#125; public static void main(String[] args) &#123; String[] a = StdIn.readAllStrings(); Heap.sort(a); show(a); &#125;&#125; 说明：将N个元素排序，堆排序只需少于（2NlgN+2N）次比较（以及一半次数的交换）。 证明：2N来自于堆的构造，2NlgN项来自于每次下沉操作最大可能需要2lgN次比较。 堆排序的轨迹（每次下沉后的数组内容）： 先下沉后上浮大多数在下沉排序期间重新插入堆的元素会被直接加入到堆底，所以我们正好可以通过免去检查元素是否到达正确的位置来节省时间。在下沉重总是直接提升较大的子结点直至到达堆底，然后使元素上浮到正确的位置。这个想法几乎可以将比较次数减少一半，接近了归并排序所需的比较次数。这种方法需要额外的空间，因此在实际应用中只有当比较操作代价较高时才有用，例如：当为我们在将字符串或者其他键值较长类型的元素进行排序时。 总结堆排序在排序复杂性的研究中有着重要的地位，因为它是我们所知的唯一能够同时最优地利用空间和时间的方法，在最坏的情况下它也能保证使用~2NlgN次比较和恒定的额外空间。在空间十分紧张的时候（例如嵌入式系统或低成本的移动设备中）很流行。但现代系统的许多应用中很少使用它，因为它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法，如快速排序、归并排序，甚至是希尔排序。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引优先队列]]></title>
    <url>%2F2017%2F11%2F18%2Falgorithm%2Findexpq%2F</url>
    <content type="text"><![CDATA[介绍在很多应用中，允许用例引用已经进入优先队列中的元素是必要的。做到这一点的一种简单方法是给每个元素一个索引。另外一种常见的情况是用例已经有了总量为N的多个元素，而且可能还同时使用了多个（平行）数组来存储这些元素的信息。此时，其他无关的用例代码可能已经在使用一个整数索引来引用这些元素了。 关联索引的泛型优先队列的API： public class IndexMinPQ&lt;Item extends Comparable&gt; IndexMinPQ(int maxN) 创建一个最大容量为maxN的优先队列 void insert(int k, Item item) 插入一个元素，将它和索引k相关联 void change(int k, Item item) 将索引为k的元素设为item boolean contains(int k) 是否存在索引为k的元素 void delete(int k) 删去索引k及其相关联的元素 Item minKey() 返回最小元素 int minIndex() 返回最小元素的索引 int delMin() 删除最小元素并返回它的索引 boolean isEmpty() 优先队列是否为空 int size() 优先队列的元素数量 这种数据结构可以理解成：它能够快速访问数组的一个特定子集中的最小元素。换句话说，可以将pq的IndexMinPQ类优先队列看做数组pq[0…N-1]中的一部分元素的代表。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168public class IndexMinPQ&lt;Key extends Comparable&lt;Key&gt;&gt; implements Iterable&lt;Integer&gt; &#123; private int maxN; // maximum number of elements on PQ private int n; // number of elements on PQ private int[] pq; // binary heap using 1-based indexing private int[] qp; // inverse of pq - qp[pq[i]] = pq[qp[i]] = i private Key[] keys; // keys[i] = priority of i public IndexMinPQ(int maxN) &#123; if (maxN &lt; 0) throw new IllegalArgumentException(); this.maxN = maxN; n = 0; keys = (Key[]) new Comparable[maxN + 1]; // make this of length maxN?? pq = new int[maxN + 1]; qp = new int[maxN + 1]; // make this of length maxN?? for (int i = 0; i &lt;= maxN; i++) qp[i] = -1; &#125; public boolean isEmpty() &#123; return n == 0; &#125; public boolean contains(int i) &#123; if (i &lt; 0 || i &gt;= maxN) throw new IllegalArgumentException(); return qp[i] != -1; &#125; public int size() &#123; return n; &#125; public void insert(int i, Key key) &#123; if (i &lt; 0 || i &gt;= maxN) throw new IllegalArgumentException(); if (contains(i)) throw new IllegalArgumentException("index is already in the priority queue"); n++; qp[i] = n; pq[n] = i; keys[i] = key; swim(n); &#125; public int delMin() &#123; if (n == 0) throw new NoSuchElementException("Priority queue underflow"); int min = pq[1]; exch(1, n--); sink(1); assert min == pq[n+1]; qp[min] = -1; // delete keys[min] = null; // to help with garbage collection pq[n+1] = -1; // not needed return min; &#125; public void changeKey(int i, Key key) &#123; if (i &lt; 0 || i &gt;= maxN) throw new IllegalArgumentException(); if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue"); keys[i] = key; swim(qp[i]); sink(qp[i]); &#125; public void change(int i, Key key) &#123; changeKey(i, key); &#125; public void delete(int i) &#123; if (i &lt; 0 || i &gt;= maxN) throw new IllegalArgumentException(); if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue"); int index = qp[i]; exch(index, n--); swim(index); sink(index); keys[i] = null; qp[i] = -1; &#125; public int minIndex() &#123; if (n == 0) throw new NoSuchElementException("Priority queue underflow"); return pq[1]; &#125; public Key minKey() &#123; if (n == 0) throw new NoSuchElementException("Priority queue underflow"); return keys[pq[1]]; &#125; private boolean greater(int i, int j) &#123; return keys[pq[i]].compareTo(keys[pq[j]]) &gt; 0; &#125; private void exch(int i, int j) &#123; int swap = pq[i]; pq[i] = pq[j]; pq[j] = swap; qp[pq[i]] = i; qp[pq[j]] = j; &#125; private void swim(int k) &#123; while (k &gt; 1 &amp;&amp; greater(k/2, k)) &#123; exch(k, k/2); k = k/2; &#125; &#125; private void sink(int k) &#123; while (2*k &lt;= n) &#123; int j = 2*k; if (j &lt; n &amp;&amp; greater(j, j+1)) j++; if (!greater(k, j)) break; exch(k, j); k = j; &#125; &#125; public Iterator&lt;Integer&gt; iterator() &#123; return new HeapIterator(); &#125; private class HeapIterator implements Iterator&lt;Integer&gt; &#123; // create a new pq private IndexMinPQ&lt;Key&gt; copy; // add all elements to copy of heap // takes linear time since already in heap order so no keys move public HeapIterator() &#123; copy = new IndexMinPQ&lt;Key&gt;(pq.length - 1); for (int i = 1; i &lt;= n; i++) copy.insert(pq[i], keys[pq[i]]); &#125; public boolean hasNext() &#123; return !copy.isEmpty(); &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Integer next() &#123; if (!hasNext()) throw new NoSuchElementException(); return copy.delMin(); &#125; &#125; public static void main(String[] args) &#123; // insert a bunch of strings String[] strings = &#123; "it", "was", "the", "best", "of", "times", "it", "was", "the", "worst" &#125;; IndexMinPQ&lt;String&gt; pq = new IndexMinPQ&lt;String&gt;(strings.length); for (int i = 0; i &lt; strings.length; i++) &#123; pq.insert(i, strings[i]); &#125; // delete and print each key while (!pq.isEmpty()) &#123; int i = pq.delMin(); StdOut.println(i + " " + strings[i]); &#125; StdOut.println(); // reinsert the same strings for (int i = 0; i &lt; strings.length; i++) &#123; pq.insert(i, strings[i]); &#125; // print each key using the iterator for (int i : pq) &#123; StdOut.println(i + " " + strings[i]); &#125; while (!pq.isEmpty()) &#123; pq.delMin(); &#125; &#125;&#125; 含有N个元素的基于堆的索引优先队列所有操作在最坏情况下的成本： 操作 比较次数的增长数量级 insert() logN change() logN contains() 1 delete() logN minKey() 1 minIndex() 1 delMin() logN 使用索引优先队列的多向归并将多个有序的输入流归并成一个有序的输出流。 1234567891011121314151617181920212223242526272829public class Multiway &#123; private static void merge(In[] streams) &#123; int n = streams.length; IndexMinPQ&lt;String&gt; pq = new IndexMinPQ&lt;String&gt;(n); for (int i = 0; i &lt; n; i++) &#123; if (!streams[i].isEmpty()) &#123; pq.insert(i, streams[i].readString()); &#125; &#125; while (!pq.isEmpty()) &#123; StdOut.print(pq.minKey() + " "); int i = pq.delMin(); if (!streams[i].isEmpty()) &#123; pq.insert(i, streams[i].readString()); &#125; &#125; StdOut.println(); &#125; public static void main(String[] args) &#123; int n = args.length; In[] streams = new In[n]; for (int i = 0; i &lt; n; i++) &#123; streams[i] = new In(args[i]); &#125; merge(streams); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆优先队列]]></title>
    <url>%2F2017%2F11%2F17%2Falgorithm%2Fheap%2F</url>
    <content type="text"><![CDATA[介绍数据结构二叉堆能够很好地实现优先队列的基本操作。在二叉堆数组中，每个元素都要保证大于等于另两个特定位置的元素。 堆的定义堆有序：当一个二叉树的每个结点都大于等于它的两个子节点时，称为堆有序。根结点是堆有序的二叉树中的最大结点。 完全二叉树：在根结点下一层一层地由上向下、从左至右，在每个结点的下方连接两个更小的结点，直至将N个结点全部连接完毕。一棵堆有序的完全二叉树如图： 树的高度：一棵大小为N的完全二叉树的高度为lgN。 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。具体方法就是将二叉树的节点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，子结点的子结点分别在位置4,5,6和7… 在一个堆中，位置k的结点的父结点的位置为[k/2]，而它的两个子结点的位置则分别为2k和2k+1。这样可以通过计算数组的索引在树中上下移动：从a[k]向上一层就令k等于k/2，向下一层则令k等于2k或2k+1。堆的表示如图： 堆的算法用长度为N+1的私有数组pq[]表示堆，堆元素放在pq[1]至pq[N]中，在排序算法中只通过私有辅助函数less（）和exch（）来访问元素。接下来堆操作不再将数组作为参数传递。 123456789private boolean less(int i, int j)&#123; return pq[i].compareTo(pq[j]) &lt; 0;&#125;private void exch(int i, int j)&#123; Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;&#125; 堆的有序化（reheapifying）堆的操作会首先进行一些简单地改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。这个过程叫做堆的有序化。有序化过程中的两种情况： 当某个结点的优先级上升（或是在堆底加入一个新的元素）时，我们需要由下至上恢复堆的顺序； 当某个结点的优先级下降（例如，将根结点替换为一个较小的元素）时，我们需要由上至下恢复堆的顺序。 由下至上的堆有序化（上浮）如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们需要通过交换它和他的父节点来修复堆。交换后，这个结点仍然可能比它现在的父节点大，我们一遍一遍地用同样的方法恢复秩序，将这个结点不断向上移动直到遇到了一个比它大的父结点。只需要记住位置k的结点的父结点的位置是[k/2]。swim（）方法中循环可以保证只有位置k上的结点大于它的父结点时堆的有序状态才会打破，因此只要该结点不再大于它的父结点，堆的有序状态就恢复了。 123456private void swim(int k)&#123; while(k &gt; 1 &amp;&amp; less(k/2, k))&#123; exch(k/2, k); k = k/2; &#125;&#125; 由下至上的堆有序化示意图： 由上至下的堆有序化（下沉）如果堆的有序状态因为某个结点变得比它两个子结点或是其中之一更小了而被打破，那么我们可以通过将它和它的两个子结点中的较大者交换来恢复堆。同样，不断用相同的方法将其修复。位置k的结点的子结点位于2k和2k+1。 12345678910111213private void sink(int k)&#123; while(2*k &lt;= N)&#123; int j = 2*k; if(j &lt; N &amp;&amp; less(j, j+1))&#123; j++; &#125; if(!less(k, j))&#123; break; &#125; exch(k, j); k = j; &#125;&#125; 由上至下的堆有序化示意图： 堆的操作插入元素：将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置。 删除最大元素：从数组顶端删除去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适位置。 堆操作示意图： 基于堆的优先队列根据堆的算法实现优先队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;&#123; private Key[] pq;//基于堆的完全二叉树 private int N = 0;//存储于pq[1...N]中，pq[0]没有使用 public MaxPQ(int maxN) &#123; pq = (Key[]) new Comparable[maxN + 1]; &#125; public boolean isEmpty() &#123; return N == 0; &#125; public int size() &#123; return N; &#125; public void insert(Key x) &#123; if (n == pq.length - 1) &#123; resize(2 * pq.length); &#125; pq[++n] = x; swim(n); &#125; public Key delMax() &#123; if (isEmpty()) &#123; throw new NoSuchElementException("Priority queue underflow"); &#125; Key max = pq[1]; //从根结点得到最大元素 exch(1, n--); //将其和最后一个结点交换 pq[n+1] = null; //防止对象游离 sink(1); //恢复堆的有序性 if ((n &gt; 0) &amp;&amp; (n == (pq.length - 1) / 4)) &#123; resize(pq.length / 2); &#125; return max; &#125; /*************************************************************************** * Helper functions to restore the heap invariant. * 动态调整数组大小，其他辅助函数省略 ***************************************************************************/ private void resize(int capacity) &#123; assert capacity &gt; n; Key[] temp = (Key[]) new Comparable[capacity]; for (int i = 1; i &lt;= n; i++) &#123; temp[i] = pq[i]; &#125; pq = temp; &#125;&#125; 说明： 对于一个含有N个元素的基于堆的优先队列，插入元素操作只需要不超过（lgN+1）次比较，删除最大元素的操作需要不超过2lgN次比较。 证明：两种操作都需要在根结点和堆底之间移动元素，而路径的长度不超过lgN。对于路径上的每个结点，删除最大元素需要两次比较（除了堆底元素），一次用来找出较大的子结点，一次用来确定该子结点是否需要上浮。 使用有序或是无序数组的优先队列的初级实现总是需要线性时间来完成其中一种操作，但基于堆的实现则能保证在对数时间内完成它们。 多叉堆 基于用数组表示的完全三叉堆：对于数组中1至N的N个元素，位置k的结点大于等于位于3k-1、3k、3k+1的结点，小于等于位于(k+1)/3的结点。 调整数组大小 同前面动态调整数组大小。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列]]></title>
    <url>%2F2017%2F11%2F16%2Falgorithm%2Fpq%2F</url>
    <content type="text"><![CDATA[介绍优先队列是一种抽象数据类型，表示了一组值和对这些值的操作。优先队列最重要的操作就是删除最大元素和插入元素。泛型优先队列的API： public class MaxPQ&lt;key extends Comparable&gt; MaxPQ 创建一个优先队列 MaxPQ（int max） 创建一个初识容量为max的优先队列 MaxPQ（key[] a） 用a[]中的元素创建一个一个优先队列 void insert（） 向优先队列中插入一个元素 key max（） 返回最大元素 key delMax（） 删除并返回最大元素 boolean isEmpty（） 返回队列是否为空 int size（） 返回优先队列中的元素个数 优先队列的调用示例： 问题：从输入的N个字符串中找出M个最大元素，前提是输入量非常巨大。 构造一个用数字作为键的优先队列，当优先队列的大小超过M时就删掉其中最小的元素。处理完所有交易。优先队列中存放的以降序排列的最大的M个交易，然后将该段代码放在一个栈中，遍历这个栈以颠倒它们顺序，从而将它们按降序打印出来。 12345678910111213141516171819202122public class TopM &#123; public static void main(String[] args) &#123; //打印输入流中最大的M行 int M = Integer.parseInt(args[0]); MinPQ&lt;Transaction&gt; pq = new MinPQ&lt;Transaction&gt;(M+1); while(StdIn.hasNextLine())&#123; //为下一行输入创建一个元素并放入优先队列中 pq.insert(new Transaction(StdIn.readLine())); if(pq.size() &gt; M)&#123; pq.delMin();//如果队列中存在M+1个元素则删除其中最小的元素。 &#125; &#125;//最大的M个元素都在优先队列中 Stack&lt;Transaction&gt; stack = new Stack&lt;Transaction&gt;(); while(!pq.isEmpty())&#123; stack.push(pq.delMin()); &#125; for(Transaction t : stack)&#123; System.out.println(t); &#125; &#125;&#125; 实现下面使用有序和无序的数组以及链表实现优先队列。 数组实现（无序）insert（）方法的代码和栈的push（）方法一样。实现删除最大元素，添加一段类似选择排序的内循环的代码，将最大元素和边界元素交换然后删除它，和栈的pop（）方法实现一样。同样，可以添加调整数组大小的代码来保证数据结构中至少含有四分之一的元素而永远不会溢出。（详见栈）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 无序数组实现优先队列 * @author guangguang_duan * */public class UnorderedArrayMaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private Key[] pq; private int n; public UnorderedArrayMaxPQ(int capacity)&#123; pq = (Key[]) new Comparable[capacity]; n = 0; &#125; public boolean isEmpty()&#123; return n == 0; &#125; public int size()&#123; return n; &#125; public void insert(Key x)&#123; pq[n++] = x; &#125; public Key delMax()&#123; int max = 0; for (int i = 1; i &lt; n; i++)&#123; if (less(max, i))&#123; max = i; &#125; &#125; exch(max, n-1); return pq[--n]; &#125; /*************************************************************************** * Helper functions ***************************************************************************/ private boolean less(int i, int j) &#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125; private void exch(int i, int j) &#123; Key swap = pq[i]; pq[i] = pq[j]; pq[j] = swap; &#125; /*************************************************************************** * Test routine(测试程序,routine-常规) ***************************************************************************/ public static void main(String[] args) &#123; UnorderedArrayMaxPQ&lt;String&gt; pq = new UnorderedArrayMaxPQ&lt;String&gt;(10); pq.insert("this"); pq.insert("is"); pq.insert("a"); pq.insert("test"); while (!pq.isEmpty()) StdOut.println(pq.delMax()); &#125;&#125; 数组实现（有序）在insert（）方法中添加代码，将所有较大的元素向右边移动一格以使数组保持有序（和插入排序一样）。这样，最大的元素总会在数组的一边，优先队列的删除最大元素操作就和栈的pop（）操作一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 有序数组实现优先队列 * @author guangguang_duan * */public class OrderedArrayMaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private Key[] pq; private int n; public OrderedArrayMaxPQ(int capacity) &#123; pq = (Key[]) (new Comparable[capacity]); n = 0; &#125; public boolean isEmpty()&#123; return n == 0; &#125; public int size()&#123; return n; &#125; public Key delMax()&#123; return pq[--n]; &#125; public void insert(Key key) &#123; int i = n-1; while (i &gt;= 0 &amp;&amp; less(key, pq[i])) &#123; pq[i+1] = pq[i]; i--; &#125; pq[i+1] = key; n++; &#125; /*************************************************************************** * Helper functions ***************************************************************************/ private boolean less(Key v, Key w) &#123; return v.compareTo(w) &lt; 0; &#125; /*************************************************************************** * Test routine. ***************************************************************************/ public static void main(String[] args) &#123; OrderedArrayMaxPQ&lt;String&gt; pq = new OrderedArrayMaxPQ&lt;String&gt;(10); pq.insert("this"); pq.insert("is"); pq.insert("a"); pq.insert("test"); while (!pq.isEmpty()) StdOut.println(pq.delMax()); &#125;&#125; 链表实现可以用基于链表的下压栈的代码实现，然后可以选择修改pop（）来找到并返回最大元素，或是修改push（）来保证所有元素为逆序并与pop（）来删除并返回链表的首元素（最大元素）。 总结使用无序序列实现优先队列是惰性方法，使用有序序列实现优先队列是积极方法。 实现栈或是队列与实现优先队列的最大不同在于对性能的要求。对于栈和队列，我们的实现能在常数时间内完成所有操作；而对于优先队列，上面的初级实现，插入元素和删除最大元素这两个操作之一在最坏情况下需要线性时间完成。 优先队列的各种实现在最坏情况下运行时间的增长数量级： 数据结构 插入元素 删除最大元素 有序数组 N 1 无序数组 1 N 堆 logN logN 理想情况 1 1]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2017%2F11%2F16%2Falgorithm%2Fquick%2F</url>
    <content type="text"><![CDATA[介绍快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序，当两个子数组都有序时整个数组也就有序了。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序。归并排序将一个数组等分成两半，递归调用发生在处理整个数组之前；快速排序切分（partition）的位置取决于数组的内容，递归调用发生在处理整个数组之后。快速排序示意图： 快速排序12345678910111213public static void sort(Comparable[] a)&#123; StdIn.shuffle(a);//消除对输入的依赖 sort(a, 0, a.length-1);&#125;private static void sort (Comparable[] a, int lo, int hi)&#123; if(hi &lt;= lo)&#123; return; &#125; int j = partition(a, lo, hi);//切分 sort(a, lo, j-1);//将左半部分a[lo...j-1]排序 sort(a, j+1, hi);//将右半部分a[j+1...hi]排序&#125; 快速排序递归地将子数组a[lo…hi]排序，先用partition（）方法将a[j]放到一个合适位置，然后再用递归调用将其他位置的元素排序。该方法的关键在于切分，这个过程使得数组满足下面三个条件： 对于某个j，a[j]已经排定； a[lo]到a[j-1]中的所有元素都不大于a[j]； a[j+1]到a[hi]中的所有元素都不小于a[j]。 快速排序的结果轨迹： 切分要实现快速排序，需要实现切分方法。一般策略是先随意地取a[lo]作为切分元素，然后从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素显然是没有排定的，因此交换它们的位置。如此继续，就可以保证左指针i的左侧元素都不大于切分元素，右指针j的右侧元素都不小于切分元素。当两个指针相遇时，只需要将切分元素a[lo]和左子数组最右侧的元素a[j]交换后返回j即可。切分方法的大致过程如图： 快速排序的切分： 123456789101112131415161718192021222324private static int partition(Comparable[] a, int lo, int hi)&#123; //将数组切分为a[lo...i-1],a[i],a[i+1...hi] int i = lo, j = hi+1;//左右扫描指针 Comparable v = a[lo];//切分元素 while(true)&#123; //扫描左右，检查扫描是否结束并交换元素 while(less(a[++i],v))&#123; if(i == hi)&#123; break; &#125; &#125; while(less(v,a[--j]))&#123; if(j == lo)&#123; break; &#125; &#125; if(i &gt;= j)&#123; break; &#125; exch(a, i, j); &#125; exch(a, lo, j);//将v = a[j]放入正确的位置 return j; //a[lo...j-1] &lt;= a[j] &lt;= a[j+1...hi]达成&#125; 说明： 这段代码按照a[lo]的值v进行切分。当指针i和j相遇时主循环退出。在循环中，a[i]小于v时增大i，a[j]大于v时减小j，然后交换a[i]和a[j]来保证i左侧的元素都不大于v，j右侧的元素都不小于v。当指针相遇时交换a[lo]和a[j]，切分结束（切分值留在a[j]中）。 切分的轨迹： 性能特点： 优点一：快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较。内循环很简介。 优点二：比较次数很少。最多需要N^2/2次比较，平均需要~2NlnN次比较。 缺点：在切分不平衡时效率极低。解决方法是排序前数组随机乱序。 上面算法与归并排序比较是：快速排序更快（快速排序比归并排序比较次数多，但移动数据次数少） 算法改进切换到插入排序和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点： 对于小数组，快速排序比插入排序慢； 因为递归，快速排序的sort方法在小数组中也会调用自己。因此在排序小数组时应该切换到插入排序。 123456789101112131415private static void sort (Comparable[] a, int lo, int hi)&#123; /* if(hi &lt;= lo)&#123; return; &#125; */ //在排序小数组时切换到插入排序,M的最佳值与系统有关，但是5~15之间的任意值在大多数情况下令人满意 if(hi &lt;= lo + M)&#123; Insertion.sort(a, lo, hi); return; &#125; int j = partition(a, lo, hi);//切分 sort(a, lo, j-1);//将左半部分a[lo...j-1]排序 sort(a, j+1, hi);//将右半部分a[j+1...hi]排序&#125; 三向切分的快速排序它从左到右遍历数组一次，维护一个指针It使得a[lo…It-1]中的元素都小于v，一个指针gt使得a[gt+1…hi]中的元素都大于v，一个指针i使得a[it…i-1]中的元素都等于v，a[i…gt]中的元素还未确定。一开始i和lo相等，我们使用Comparable接口（而非less()）对a[i]进行三向比较直接处理下面情况： a[i]小于v，将a[It]和a[i]交换，将It和i加1； a[i]大于v，将a[gt]和a[i]交换，将gt减1； a[i]等于v，将i加1。 除非和切分元素相等，其他元素都会被交换。 三向切分示意图： 三向切分的快速排序 12345678910111213141516171819202122232425public static void sort(Comparable[] a)&#123; StdIn.shuffle(a);//消除对输入的依赖 sort3way(a, 0, a.length-1); //三向切分的快速排序&#125;private static void sort3way(Comparable[] a, int lo, int hi)&#123; if(hi &lt;= lo)&#123; return; &#125; int it = lo, i = lo+1, gt = hi; Comparable v = a[lo]; while(i &lt;= gt)&#123; int cmp = a[i].compareTo(v); if(cmp &lt; 0)&#123; exch(a, it++, i++); &#125;else if(cmp &gt; 0)&#123; exch(a, i, gt--); &#125;else&#123; i++; &#125; &#125;//现在a[lo...it-1] &lt; v = a[it...gt] &lt; a[gt+1...hi]成立 sort3way(a, lo, it-1); sort3way(a, gt+1, hi);&#125; 说明： 这段代码的切分能够将和切分元素相等的元素归位，这样它们就不会被包含在递归调用处理的子数组中，对于存在大量重复元素的数组，这种方法比标准的快速排序效率高很多。 三向切分的快速排序的轨迹： 总结： 对于只有若干不同主键的随机数组，归并排序的时间复杂度是线性对数的，而三向切分快速排序则是线性的。 对于大小为N的数组，三向切分的快速排序需要~（2ln2）NH次比较。H为由主键值出现频率定义的香浓信息量。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2017%2F11%2F15%2Falgorithm%2Fmerge%2F</url>
    <content type="text"><![CDATA[介绍归并：将两个有序的数组归并成一个更大的有序数组。归并排序：排序一个数组，先递归地将它分成两半分别排序，然后将结果归并起来。归并排序的优点是能够保证将任意长度为N的数组排序所需时间和NlogN成正比；主要缺点是它需要的额外空间和N成正比。 原地归并的抽象方法实现归并的一种方法是将两个不同的有序数组归并到第三个大数组中，两个子数组的元素都应该实现了Comparable接口。但当归并排序一个大数组时，需要很多次归并，每次归并都会创建一个新数组来存储排序结果会有问题。所以这里引入原地归并排序方法，可以先将前半部分排序，再将后半部分排序，然后再数组中移动元素而不需要使用额外的空间。 1234567891011121314151617181920public static void merge(Comparable[] a, int lo, int mid, int hi)&#123; //将a[lo...mid] 和 a[mid+1...hi]归并 int i = lo, j = mid + 1; //将a[lo...hi]复制到aux[lo...hi] for(int k = lo; k &lt;= hi; k++)&#123; aux[k] = a[k]; &#125; //归并回到a[lo...hi] for(int k = lo; k &lt;= hi; k++)&#123; if(i &gt; mid)&#123; a[k] = aux[j++]; &#125;else if(j &gt; hi)&#123; a[k] = aux[i++]; &#125;else if(less(aux[j], aux[i]))&#123; a[k] = aux[j++]; &#125;else&#123; a[k] = aux[i++]; &#125; &#125;&#125; 说明： 该方法先将元素复制到aux[]中，然后再归并回a[]中。方法在归并时进行了4个条件判断： 左半边用尽：取右半边的元素； 右半边用尽：取左半边的元素； 右半边的当前元素小于左半边的当前元素：取右半边的元素； 右半边的当前元素大于等于左半边的当前元素：取左半边的元素。 原地归并的轨迹： 自顶向下的归并排序自顶向下的归并排序是基于原地归并的抽象实现的另一种递归归并，这是应用高效算法设计中分治思想的最典型的一个例子。这段递归代码是归纳证明算法能够正确地将数组排序的基础：如果它能将两个子数组排序，它就能通过归并两个子数组来将整个数组排序。 123456789101112131415public static void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; //一次性分配空间 sort(a, 0, a.length-1);&#125;private static void sort(Comparable[] a, int lo, int hi)&#123; //将数组a[lo...hi]排序 if(hi &lt;= lo)&#123; return; &#125; int mid = lo + (hi - lo)/2; sort(a, lo, mid); //将左半边排序 sort(a, mid+1, hi);//将右半边排序 merge(a, lo, mid, hi);//归并排序&#125; 说明： aux[]数组最好的处理方式是设为sort方法的局部变量，将它作为参数传给merge方法。 对数组a[lo…hi]进行排序，先将它分为a[lo…mid]和a[mid+1…hi]两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。 自顶向下的归并排序的调用轨迹 如图2.2.2中的轨迹所示。要将a[0…15]排序，sort方法会调用自己将a[0…7]排序，再在其中调用自己将a[0…3]和a[0…1]排序。在将a[0]和a[1]分别排序之后，终于才会开始将a[0]和a[1]归并（轨迹中把对单个元素的数组进行排序的调用省略了）。第二次归并是a[2]和a[3]，然后是a[0…1]和a[2…3]，以此类推。从这段轨迹可以看到，sort方法的作用其实在于安排多次merge方法调用的正确顺序。 对于长度为N的任意数组，自顶向下的归并排序需要1/2NlgN至NlgN次比较。用树状图说明： 每个节点都表示一个sort方法通过merge方法归并而成的子数组这棵树正好有N层。对于0到N-1之间的任意k，自顶向下的第k层有2^k个子数组，每个数组的长度为2^(n-k)，归并最多需要2^(n-k)次比较。因此每层的比较次数为2^k * 2^(n-k)等于2^n，n层总共需要n2^n等于NlgN。 对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组6NlgN次。证明：每次归并最多需要访问数组6N次（2N次用来复制，2N次用来将排好序的元素移动回去，另外最多比较2N次），由上面一条可得。 自顶向下的归并轨迹： 改进： 用不同的方法处理小规模问题能改进大多数递归算法的性能。对排序来说，插入排序和选择排序可能在小数组上比归并排序更快。使用插入排序处理小规模的子数组（比如长度小于15）一般可以将归并排序的运行时间缩短10%~15%。 添加一个判断条件，如果a[mid]小于等于a[mid+1]，我们就认为数组已经是有序的并跳过merge方法。 可以节省将数组复制到用于归并的辅助数组所用的时间。要做到这一点需要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数据从辅助数组排序到输入数组。 总结： 归并排序所需的时间和NlgN成正比，这表明只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序。可以用归并排序处理数百万甚至更大规模的数组，这是插入排序或者选择排序做不到的。归并排序的主要缺点是辅助数组所使用的额外空间和N的大小成正比。 自底向上的归并排序实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到将整个数组归并在一起。首先是两两归并（把每个元素想象成大小为1的数组），然后是四四归并，然后是八八归并… 12345678910public static void sortfromdown(Comparable[] a)&#123; //进行lgN次两两归并 int N = a.length; aux = new Comparable[N]; for(int sz = 1; sz &lt; N; sz = sz+sz)&#123;//sz子数组大小 for(int lo = 0; lo &lt; N-sz; lo += sz+sz)&#123;//lo：子数组索引 merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1)); &#125; &#125;&#125; 说明： aux[]数组最好的处理方式是设为sortfromdown方法的局部变量，将它作为参数传给merge方法。 自底向上的归并排序会多次遍历整个数组，根据子数组的大小进行两两归并。子数组的大小sz的初始值为1，每次加倍。 对于长度为N的任意数组，自底向上的归并排序需要1/2NlgN至NlgN次比较，最多访问数组6NlgN次。 当数组长度为2的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。 自底向上的归并排序比较适合用链表组织的数据（只需要重新组织链表链接就能将链表原地排序，不需要创建任何新的链表结点）。 自底向上的归并轨迹： 排序算法的复杂度 没有任何基于比较的算法能够保证使用小于lg（N!）~ NlgN次比较将长度为N的数组排序； 由上归并排序是一种渐进最优的基于比较排序的算法； 归并排序的空间复杂度不是最优的。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2017%2F11%2F14%2Falgorithm%2Fshellsort%2F</url>
    <content type="text"><![CDATA[介绍希尔排序是一种基于插入排序的快速的排序算法。插入排序对于大规模的乱序数组效率很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序数组排序。 希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组称为h有序数组。在进行排序时，如果h很大，就能将元素移动到很远的地方，为实现更小的h有序创造方便。用这种方式，对于任意以1结尾的h序列，都能将数组排序。一个h有序数组即一个由h个有序子数组组成的数组： 希尔排序实现希尔排序的一种方法是对于每个h，用插入排序将h个子数组独立地排序。但因为子数组是相互独立地，一个更简单地方法是在h-子数组中将每个元素交换到比它大的元素之前去，只需要在插入排序的代码中将移动元素的距离由1改为h即可。 123456789101112131415161718public static void shellSort(Comparable[] a)&#123; //将a[]按升序排列 int N = a.length; int h = 1; while(h &lt; N/3)&#123; h = 3*h + 1;//1, 4, 13, 40, 121, 364... &#125; while(h &gt;= 1)&#123; //将数组变为h有序 for(int i = h; i &lt; N; i++)&#123; //将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中 for(int j = i; j &gt; h &amp;&amp; less(a[j],a[j-h]); j -= h)&#123; exch(a,j,j-h); &#125; &#125; h = h/3; &#125;&#125; 说明： 上面算法使用了序列1/2（3^k-1），从N/3开始递减至1，这个序列称为递增序列。 希尔排序更高效的原因是它权衡了子数组的规模和有序性。子数组规模小，部分有序，这两种情况很适合插入排序。 希尔排序与插入排序对比，希尔排序可以用于大型数组。 上面算法的性能，运行时间达不到平方级别（结论）。 希尔排序的轨迹：]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序和插入排序]]></title>
    <url>%2F2017%2F11%2F14%2Falgorithm%2Fselsort%2F</url>
    <content type="text"><![CDATA[介绍排序就是将一组对象按照某种逻辑顺序重新排列的过程。排序算法的目标是将所有元素的主键按照某种方式排列。在java中，元素通常都是对象，对主键的描述则是通过一种内置的机制—Comparable接口。 排序算法类的模板： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 排序算法类的模板 * @author guangguang_duan * */public class SortExample &#123; public static void sort(Comparable[] a)&#123; //各种排序算法 &#125; private static boolean less(Comparable v, Comparable w)&#123; return v.compareTo(w) &lt; 0; &#125; private static void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; private static void show(Comparable[] a)&#123; //单行中打印数组 for(int i = 0; i &lt; a.length; i++)&#123; System.out.print(a[i] + " "); &#125; System.out.println(); &#125; public static boolean isSorted(Comparable[] a)&#123; //测试数组元素是否有序 for(int i = 1; i &lt; a.length; i++)&#123; if(less(a[i],a[i-1]))&#123; return false; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; //从标准输入读取字符串，将他们排序并输出 String[] a = StdIn.readStrings(); sort(a); assert isSorted(a);//确认排序后数组元素都是有序的 show(a); &#125;&#125; 可比较的数据类型： java中封装了许多数据类型例：Integer、Double、String、File、URL等都实现了Comparable接口，具有比较方法。在创建自己的数据类型是，我们只要实现Comparable接口就能保证用例代码可以将其排序，再实现一个compareTo方法来定义目标数据类型的自然次序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 定义可比较的数据类型 * @author guangguang_duan * */public class DateCompareto implements Comparable&lt;DateCompareto&gt;&#123; private final int day; private final int month; private final int year; public DateCompareto(int d, int m, int y)&#123; day = d; month = m; year = y; &#125; public int day()&#123; return day; &#125; public int month()&#123; return month; &#125; public int year()&#123; return year; &#125; @Override public int compareTo(DateCompareto that) &#123; if(this.year &gt; that.year) return 1; if(this.year &lt; that.year) return -1; if(this.month &gt; that.month) return 1; if(this.month &gt; that.month) return -1; if(this.day &gt; that.day) return 1; if(this.day &gt; that.day) return -1; return 0; &#125; public String toString()&#123; return month + "/" + day + "/" + year; &#125;&#125; 排序的成本模型： 在研究排序算法时，我们需要计算比较和交换的数量，对于不交换元素的算法，我们会计算访问数组的次数。 选择排序选择排序：先找到数组中最小的那个元素，将它和数组的第一个元素交换位置，然后在剩下的元素中找到最小的元素，将它和数组的第二个元素交换位置，如此反复，直到将整个数组排序。 12345678910111213public static void selectSort(Comparable[] a)&#123; //将a[]按升序排列 int N = a.length; for(int i = 0; i &lt; N; i++)&#123; int min = i; //最小元素索引 for(int j = i+1; j &lt; N; j++)&#123; if(less(a[j],a[min]))&#123; min = j; &#125; &#125; exch(a,i,min); &#125;&#125; 说明： 运行时间和输入无关。选择排序会一遍遍扫描数组，一个有序数组和无序数组用选择排序时间一样 数据移动是最少的。对于长度为N的数组，选择排序需要大约N^2/2次比较和N次交换。交换次数和数组大小是线性关系 该算法在第I个元素排好序后，I前面的元素不会再被访问（数组扫描）。 算法的时间效率取决于比较的次数。 选择排序的轨迹： 插入排序插入排序：将每个元素插入到合适的位置，我们需要在插入元素时将其余所有元素向右移动一位。与选择排序一样，当前索引左边的所有元素都是有序的，当索引到达数组的右端时，数组排序就完成了。和选择排序不同的是，插入排序所需要的时间取决于输入中元素的初识位置。 12345678910public static void insertSort(Comparable[] a)&#123; //将a[]按升序排列 int N = a.length; for(int i = 1; i &lt; N; i++)&#123; for(int j = i; j &gt; 0 &amp;&amp; less(a[j],a[j-1]); j--)&#123; exch(a,j,j-1); &#125; &#125;&#125; 说明： 插入排序对部分有序数组很有效，选择排序则都一样。 对于有序数组，插入排序能够立即发现每个元素都已经在合适的位置上，它的运行时间是线性的。 对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要~N^2/4次比较以及~N^2/4次交换；最坏情况下需要~N^2/2次比较和~N^2/2次交换；最好情况下需要N-1次比较和0次交换。 大幅度提高插入排序的速度，只需要在内循环中将较大的元素都向右移动而不总是交换。 插入排序轨迹： 两种排序算法比较插入排序不会访问索引右侧的元素，选择排序不会访问索引左侧的元素。两种算法的可视轨迹图： 比较两种排序算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 排序算法比较 * @author guangguang_duan * */public class SortCompare &#123; //针对输入，为该算法计时 public static double time(String alg, Double[] a)&#123; CuurentTime timer = new CuurentTime(); if(alg.equals("Insertion")) Insertion.sort(a); if(alg.equals("Selection")) Selection.sort(a); if(alg.equals("Shell")) Shell.sort(a); if(alg.equals("Merge")) Merge.sort(a); if(alg.equals("Quick")) Quick.sort(a); if(alg.equals("Heap")) Heap.sort(a); return timer.endTime(); &#125; public static double timeRandomInput(String alg, int N, int T)&#123; //使用算法alg将T个长度为N的数组排序 double total = 0.0; Double[] a = new Double[N]; for(int t = 0; t &lt; T; t++)&#123; //生成一个数组并排序 for(int i = 0; i &lt; N; i++)&#123; a[i] = StdRandom.uniform(); &#125; total += time(alg, a); &#125; return total; &#125; public static void main(String[] args) &#123; String alg1 = args[0]; String alg2 = args[1]; int N = Integer.parseInt(args[2]); int T = Integer.parseInt(args[3]); double t1 = timeRandomInput(alg1, N, T); double t2 = timeRandomInput(alg2, N, T); System.out.println("t2/t1 :" + t2/t1); &#125; // % java SortCompare Insertion Selection 1000 100&#125; 说明： 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union-Find算法]]></title>
    <url>%2F2017%2F11%2F12%2Falgorithm%2Funionfind%2F</url>
    <content type="text"><![CDATA[介绍输入一系列整数对，其中每个整数都表示一个某种类型的对象，一对整数p和q可以理解成“p和q是相连的”。我们假设“相连”是一种等价关系，这意味着它具有： 自反性：p和p是相连的； 对称性：如果p和q是相连的，那么q和p也是相连的； 传递性：如果p和q是相连的且q和r是相连的，那么p和r也是相连的。 当程序从输入中读取了整数对p,q时，如果已知的所有整数对都不能说明p和q是相连的，则将这对整数写到输出，如果已知的数据可以说明p和q是相连的，则忽略这对整数对继续处理下一对整数对。要求程序能够判断给定的整数对是否相连。 我们程序限定为网络问题，所以使用网络方面的术语：将对象称为触点，将整数对称为连接，将等价类称为连通分量。 union-find算法的API： public class UF UF（int N） 以整数标识（0到N-1初始化N个触点） void union（int p, int q） 在p和q之间建立连接，合并分量 int find（int p） p所在的分量的标识符 boolean connected（int p, int q） 如果p和q存在于同一个分量中则返回true int count（） 连通分量的数量 Union-Find的实现数据结构和算法设计API已经说明触点和分量都会用int值表示，所以我们用一个以触点为索引的数组id[]作为基本数据结构来表示所有分量，所以每个分量都是由它的触点之一所表示。一开始我们有N个分量，每个触点都构成了一个只包含有它自己的分量，因此我们将id[i]的值初始化为i，其中i在0到N-1之中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class UF&#123; private int[] a;//分量id，以触点作为索引 private int count;//分量数量 public UF(int N)&#123; //初始化分量id数组 count = N; id = new int[N]; for(int i = 0; i &lt; N; i++)&#123; id[i] = i; &#125; &#125; //返回给定触点所在的连通分量的标识符 public int find(int p)&#123; &#125; //将两个分量归并 public void union(int p, int q)&#123; &#125; //返回所有连通分量的数量 public int count()&#123; return count; &#125; //判断两个触点是否存在于同一个分量之中 public boolean connected(int p, int q)&#123; return find(p) == find(q); &#125; public static void main(String[] args)&#123; int N = StdIn.readInt();//读取触点数量 UF uf = new UF(N);//初始化N个分量 while(!StdIn.isEmpty())&#123; int p = StdIn.readInt(); int q = StdIn.readInt();//读取整数对 if(uf.connected(p,q))&#123; continue;//如果已经连通则忽略 &#125; uf.union(p,q);//归并分量 StdOut.println(p + " " + q); &#125; StdOut.println(uf.count + "components"); &#125;&#125; 这个实现维护了一个整形数组id[]，使得find（）方法对于处在同一个连通分量中的触点均返回相同的整数值，union（）方法来保证这一点。这样，问题就变成了实现find（）和union（）方法。 Quick-Find算法保证当且仅当id[p]等于id[q]时p和q是连通的。也就是，在同一个连通分量中的所有触点在id[]中的值必须全部相同。为了调用union（p，q）确保这一点，必须将两个集合中所有触点所对应的id[]元素变为同一个值。 12345678910111213141516171819202122public int find(int p)&#123; return id[p]&#125;public void union(int p, int q)&#123; //将p和q归并到相同的分量中 int pID = find(p); int qID = find(q); //如果p和q已经在相同的分量中，则忽略 if(pID == qID)&#123; reutrn; &#125; //将p的分量重命名为q的名称 for(int i = 0; i &lt; id.length; i++)&#123; if(id[i] == pID)&#123; id[i] = qID &#125; &#125; count--;&#125; quick-find算法概述： quick-find分析： find（）操作速度很快，因为它只需要访问id[]数组一次。而归并两个分量的union（）操作访问数组的次数在(N+3)到(2N+1)之间。但quick-find算法一般无法处理大型问题，因为对于每一对输入union（）都需要扫描整个id[]数组。假设我们使用该算法解决动态连通性问题并且最后只得到一个连通分量，那么至少调用N-1次union（），即至少(N+3)(N-1)~N^2次数组访问。 Quick-Union算法该算法用来提高union（）方法的速度。每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称（也可能是它自己），我们将这种联系称为链接。在实现find（）方法时，我们从给定的触点开始，由它的链接得到另一个触点，如此继续直到到达一个根触点，即链接指向自己的触点。当且仅当分别由两个触点开始的这个过程到达了同一个根触点时它们存在于同一个连通分量。需要union（p，q）保证这一点。它的实现就简单了：由p和q的链接分别找到它们的根触点，然后只需要将一个根触点链接到另一个即可将一个分量命名为另一个分量。 1234567891011121314151617181920private int find(int p)&#123; //找出分量的名称 while(p != id[p])&#123;//while循环中经过编译的代码对id[p]的第二次访问一般都不会访问数组 p = id[p] &#125; return p;&#125;public void union(int p, int q)&#123; //将p和q的根节点统一 int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot)&#123; return; &#125; id[pRoot] = qRoot; count--;&#125; 森林的表示： 用节点表示触点，用从一个节点到另一个节点的箭头表示链接，由此得到一个树的结构。在数组被初始化之后，每个节点的链接都指向自己，如果在某次union（）操作之前这条性质成立，那么操作之后也必然成立，因此find（）方法能够返回根节点所对应的触点的名称。这样，connected（）才能判断两个触点是否在同一树上。 quick-union算法分析： quick-union算法可以看做是quick-find算法的一种改良，因为它解决了quick-find算法中最主要的问题，union（）操作总是线性级别的。quick-union算法中的find（）方法访问数组的次数为1加上给定触点所对应的节点的深度的两倍。union（）和connected（）访问数组的次数为两次find（）操作（如果union（）中给定的两个触点分别存在于不同的树中则还需要加1） 。这样我们得到quick-union算法最坏的情况：假设输入的整数对是有序的0-1、0-2、0-3等，N-1对之后N个触点将全部处于相同的集合之中，且由quick-union算法得到的树的高度为N-1，其中0链接到1,1链接到2…由上面黑体可知对于整数对0-i，union（）操作访问数组的次数为2i+1（触点为0的深度为i-1，触点i的深度为0）。因此处理N对整数所需要的所有find（）操作访问数组的总次数为3+5+7+…+（2N-1）~ N^2。 加权quick-union算法对quick-union算法进行改进：之前union（）随意将一棵树连接到另一棵树上，现在我们会记录每一棵树的大小并总是将较小的树连接到较大的树上。加权quick-union: 这项改动需要添加一个数组和一些代码来记录树中的节点数，但它能大大改进算法的效率，称为加权quick-union算法。该算法构造的树的高度远远小于未加权的版本所构造的树的高度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class WeightedQuickUnionUF &#123; private int[] id;//父链接数组（由触点索引） private int[] sz;//各个根节点所对应的分量的大小 private int count;//连通分量的数量 public WeightedQuickUnionUF(int N)&#123; count = N; id = new int[N]; sz = new int[N]; for(int i = 0; i &lt; N; i++)&#123; id[i] = i; sz[i] = 1; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p, int q)&#123; return find(p) == find(q); &#125; public int find(int p)&#123; //跟随链接找到根节点 while(p != id[p])&#123; p = id[p]; &#125; return p; &#125; public void union(int p, int q)&#123; int i = find(p); int j = find(q); if(i == j)&#123; return; &#125; //将小树的根节点连接到大树的根节点 if(sz[i] &lt;sz[j])&#123; id[i] = j; sz[j] += sz[i]; &#125;else&#123; id[j] = i; sz[i] += sz[j]; &#125; count--; &#125;&#125; 加权quick-union算法分析： 上面显示了加权quick-union算法的最坏情况。其中将要被归并的树的大小总是相等的（且总是2的幂）。这些树均含有2^n个节点，因此高度正好是n。当要归并两个含有2^n个节点的树时，得到的树含有2^n+1个节点，由此将树的高度增加到n+1。由此推广可以证明加权quick-union算法能够保证对数级别的性能。对于N个触点，加权quick-union算法构造的森林中的任意节点的深度最多为lgN。对于加权quick-union算法和N个触点，在最坏情况下find（）、connected（）和union（）的成本的增长数量级为logN。对于动态连通性问题，加权quick-union算法是三种算法中唯一可以用于解决大型实际问题的算法。 路径压缩的加权quick-union算法路径压缩的加权quick-union算法是每个节点都直接链接到它的根节点上。要实现它只需要为find（）添加一个循环，将在路径上遇到的节点都直接链接到根节点上。这样得到的结果是几乎完全扁平化的树，它和quick-union算法理想情况下所得到的树非常接近。但实际上已经不大可能对加权quick-union算法进行任何改进。 总结union-find成本模型数组的访问次数。 union-find算法的性能特点 算法 存在N个触点时成本的增长数量级（最坏情况） 构造函数 union（） find（） quick-find算法 N N 1 quick-union算法 N 树的高度 树的高度 加权quick-union算法 N lgN lgN 使用路径压缩的加权quick-union算法 N 非常非常接近1 均摊成本 理想情况 N 1 1 算法中的增长数量级 描述 增长的数量级 典型的代码 说明 举例 常数级别 1 a = b + c 普通语句 将两个数相加 对数级别 logN 二分查找 二分策略 二分查找 线性级别 N for(int i = 0; i &lt; N; i++) 循环 找出最大元素 线性对数级别 NlogN 归并排序 分治 归并排序 平方级别 N^2 双层循环 双层循环 检查所有元素对 立方级别 N^3 三层循环 三层循环 检查所有三元组 指数级别 2^N 穷举查找 穷举查找 检查所有子集]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表（Linked List）]]></title>
    <url>%2F2017%2F11%2F09%2Falgorithm%2Flinked%2F</url>
    <content type="text"><![CDATA[介绍定义：链表是一种递归的数据结构，它或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。 结点是一个可能包含任意类型数据的抽象实体，它所包含的指向结点的应用显示了它在构造链表之中的作用。 结点1234private class Node&#123; Item item; Node next;&#125; 一个Node对象含有两个实例变量，类型分别为Item（参数类型）和Node。 Item是一个占位符，表示我们希望用链表处理的任意数据类型； Node类型的实例变量显示了这种数据结构的链式本质，调用的结果是一个指向Node对象的引用。 构造链表根据递归定义，我们需要一个Node类型的变量就能表示一条链表，只要保证它的值是null或者指向另一个Node对象并且该对象的next域指向了另一条链表即可。用链接构造一条链表如下图： 例：构造一条含有元素：to、be和or的链表： 1234567891011//首先为每个元素创造一个结点Node first = new Node();Node second = new Node();Node third = new Node();//将每个结点的item域设为所需的值first.item = "to";second.item = "be";third.item = "or";//设置next域来构造链表first.next = second;second.next = third; //注：third.next = null first，second，third都是一条链表，都是对应的一个结点的引用，third该结点指向null，是一个空链表。 在表头插入结点先将first保存在oldfirst中，再将一个新结点赋予first，并将它的item设为将要添加的值，next域设为oldfirst。在链表的开头插入一个新结点如图： 例：给链表开头插入字符串not： 1234567//先将first保存在oldfirst中Node oldfirst = first;//再将一个新结点赋予firstfirst = new Node();//设置新结点的实例变量first.item = "not";first.next = "oldfirst"; 在链表开头插入一个结点只需要几行赋值语句，所以它所需的时间和链表的长度无关。 从表头删除结点执行要将first指向first.next即可。删除链表的首结点如图： 例：删除链表的首结点： 12//只需将first指向first.nextfirst = first.next; 该操作只含有一条赋值语句，因此运行时间和链表的长度无关。删除链表首结点有可能改变指向链表尾结点的引用，因为当链表中只有一个结点时，它既是首结点，又是尾结点。 在链表尾部插入结点先将last保存在oldlast中，再将一个新结点赋予last，并将它的item设为将要添加的值，再将oldlast的next域设为last。在链表尾部插入新结点如图： 例：在链表尾部插入结点： 12345678//保存指向尾结点的链接Node oldlast = last;//创建新的尾结点last = new Node();//设置新的尾结点的实例变量last.item = "not";//将尾链接指向新的尾结点oldlast.next = last; 这段代码无法处理链表为空的情况，它会使用空链接，所以修改链表的操作需要添加检查。 其他操作 删除指定的结点； 在指定结点前插入一个新结点等。 这些情况就不那么容易，例如删除链表的尾结点，现有的解决方法就是遍历整条链表，找到指向尾结点的结点链接，将它的值设为null。该操作所需的时间与链表的长度成正比。实现任意插入和删除操作的标准解决方案是使用双向链表。 链表遍历将循环的索引变量x初始化为链表的首结点，然后通过x.item访问和x相关联的元素，并将x设为x.next来访问链表中的下一个结点，直到x为null为止。 123for(Node x = first; x != null; x = x.next)&#123; //处理x.item;&#125; 链表实现栈将栈保存为一条链表，栈的顶部即为表头，实例变量first指向栈顶，当push（）压入一个元素，将该元素添加在表头，当pop（）删除一个元素时，将该元素从表头删除。该链表的使用达到最优的设计目标： 它可以处理任意类型的数据； 所需的空间总是和集合的大小成正比； 操作所需的时间总是和集合的大小无关。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//链表实现下压栈public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;&#123; private Node first; private int N; //定义了结点的内嵌类 private class Node&#123; Item item; Node next; &#125; public boolean isEmpty()&#123; return first == null;//或：N == 0； &#125; public int size()&#123; return N; &#125; public void push(Item item)&#123; //向栈顶添加元素 Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; &#125; public Item pop()&#123; //从栈顶删除元素 Item item = first.item; first = first.next; N--; return item; &#125; public Iterator&lt;Item&gt; iterator()&#123; return new ListIterator(); &#125; public class ListIterator implements Iterator&lt;Item&gt;&#123; private Node current = first; public boolean hasNext()&#123; return current != null; &#125; public Item next()&#123; Item item = current.item; current = current.next; return item; &#125; public void remove()&#123; &#125; &#125;&#125; 这份泛型的Stack实现的基础是链表数据结构，它可以用于创建任意数据类型的栈，并支持迭代。 链表实现队列将队列表示为一条从最早插入元素到最近插入的元素的链表，first指向队列的开头，last指向队列的结尾，入列操作enqueue（）将元素添加到表尾（当链表为空时，需要将first和last都指向新结点），出列操作dequeue（）将表头元素删除（只是当链表为空时需要更新last的值）。同栈一样，也达到了最优设计目标。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//链表实现队列public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt;&#123; private Node first;//指向最早添加的结点的链接 private Node last;//指向最近添加的结点的链接 private int N; //定义了结点的内嵌类 private class Node&#123; Item item; Node next; &#125; public boolean isEmpty()&#123; return first == null;//或：N == 0； &#125; public int size()&#123; return N; &#125; public void enqueue(Item item)&#123; //向表尾添加元素 Node oldlast = last; last = new Node(); last.item = item; last.next = null; if(isEmpty())&#123; first = last; &#125;else&#123; oldlast.next = last; &#125; N++; &#125; public Item dequeue()&#123; //从表头删除元素 Item item = first.item; first = first.next; if(isEmpty())&#123; last = null; &#125; N--; return item; &#125; public Iterator&lt;Item&gt; iterator()&#123; return new ListIterator(); &#125; public class ListIterator implements Iterator&lt;Item&gt;&#123; private Node current = first; public boolean hasNext()&#123; return current != null; &#125; public Item next()&#123; Item item = current.item; current = current.next; return item; &#125; public void remove()&#123; &#125; &#125;&#125; 这份泛型的Queue实现的基础是链表数据结构，它可以用于创建任意数据类型的队列，并支持迭代。 链表实现背包用链表实现背包只需将栈的push（）改名为add（），并去掉pop（）方法即可。 1234567891011121314151617181920212223242526272829303132333435363738394041//链表实现下压栈public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt;&#123; private Node first; private int N; //定义了结点的内嵌类 private class Node&#123; Item item; Node next; &#125; public boolean isEmpty()&#123; return first == null;//或：N == 0； &#125; public int size()&#123; return N; &#125; public void add(Item item)&#123; //向包中添加元素 Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; &#125; public Iterator&lt;Item&gt; iterator()&#123; return new ListIterator(); &#125; public class ListIterator implements Iterator&lt;Item&gt;&#123; private Node current = first; public boolean hasNext()&#123; return current != null; &#125; public Item next()&#123; Item item = current.item; current = current.next; return item; &#125; public void remove()&#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈（Stack）]]></title>
    <url>%2F2017%2F11%2F08%2Falgorithm%2Fstack%2F</url>
    <content type="text"><![CDATA[介绍栈是一种基于后进先出（LIFO）策略的集合类型。在应用程序中使用栈迭代器的一个典型原因是在用集合保存元素的同时颠倒它们的顺序。栈的一个典型用例：把标准输入的所有整数逆序排列。 12345678910111213public class StackOfType &#123; public static void main(String[] args) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); while(!StdIn.isEmpty())&#123; stack.push(StdIn.readInt()); &#125; for(int i : stack)&#123; System.out.println(i); &#125; &#125;&#125; API泛型可迭代的栈API： public class Stack implements Iterable Stack() 创建一个空栈 void push(Item item) 添加一个元素 Item pop() 删除最近添加的元素 boolean isEmpty() 栈是否为空 int size() 栈中元素数量 Dijkstra的双栈算术表达式求值算法求表达式：（1 + （（ 2 + 3 ） （ 4 5 ）））。用两个栈，一个用于保存运算符，一个用于保存操作数实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Evaluate&#123; public static void main(String[] args)&#123; Stack&lt;String&gt; ops = new Stack&lt;String&gt;(); Stack&lt;Double&gt; vals = new Stack&lt;Double&gt;(); while(!StdIn.isEmpty())&#123; //读取字符，如果是运算符则压入运算符栈 String s = StdIn.readString(); if(s.equals("("))&#123; &#125;else if(s.equals("+"))&#123; ops.push(s); &#125;else if(s.equals("-"))&#123; ops.push(s); &#125;else if(s.equals("*"))&#123; ops.push(s); &#125;else if(s.equals("/"))&#123; ops.push(s); &#125;else if(s.equals("sqrt"))&#123; ops.push(s); &#125;else if(s.equals(")"))&#123; //如果字符为")"，弹出运算符和操作数，计算结果并压入栈 String op = ops.pop(); double v = vals.pop(); if(op.equals("+"))&#123; v = vals.pop() + v; &#125;else if(op.equals("-"))&#123; v = vals.pop() - v; &#125;else if(op.equals("*"))&#123; v = vals.pop() * v; &#125;else if(op.equals("/"))&#123; v = vals.pop() / v; &#125;else if(op.equals("sqrt"))&#123; v = Math.sqrt(v); &#125; vals.push(v); &#125;else&#123; //如果字符既不是运算符，也不是括号，则将它作为double值压入操作数栈 vals.push(Double.parseDouble(s)); &#125; &#125; system.out.println(vals.pop()); &#125;&#125; 表达式由括号、运算符和操作数组成，所以上面代码的处理过程是： 将操作数压入操作数栈； 将运算符压入运算符栈； 忽略左括号； 在遇到右括号时，弹出一个运算符弹出所需数量的操作数并将运算符和操作数的运算结果压入操作数栈。 定容栈一种表示容量固定的的字符串栈的抽象数据类型。该定容栈的实现： 1234567891011121314151617181920212223public class FixedCapacityStackOfString&#123; private String[] a;//保存栈中的元素的数组 private int N; //栈中元素的数量 public FixedCapacityStackOfString(int cap)&#123; a = new String[cap]; &#125; public boolean isEmpty()&#123; return N == 0; &#125; public int size()&#123; return N; &#125; public void push(String item)&#123; a[N++] = item; &#125; public String pop()&#123; return a[--N]; &#125;&#125; 该栈的第一个缺点是只能处理String对象，而java不允许创建泛型数组，为了解决这个问题，下面实现一个泛型栈 1234567891011121314151617181920212223public class FixedCapacityStack&lt;Item&gt;&#123; private Item[] a;//保存栈中的元素的数组 private int N; //栈中元素的数量 public FixedCapacityStackOfString(int cap)&#123; a = (Item[])new Object[cap]; &#125; public boolean isEmpty()&#123; return N == 0; &#125; public int size()&#123; return N; &#125; public void push(Item item)&#123; a[N++] = item; &#125; public Item pop()&#123; return a[--N]; &#125;&#125; 选择用数组表示栈内容，因为数组一旦创建，其大小是无法改变的，所以栈使用的空间只能是这个数组大小的一部分。为了能够使栈保存所有元素，又不浪费空间，我们需要一个能动态调整栈大小，并支持迭代的栈。 动态调整大小的栈实现能够动态调整数组大小，并支持迭代的栈的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Iterator;public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt;&#123; private Item[] a = (Item[]) new Object[1];//栈元素，初始数量为1 private int N = 0; public boolean isEmpty()&#123; return N == 0; &#125; public int size()&#123; return N; &#125; private void resize(int max)&#123; //将栈移动到一个大小为max的新数组 Item[] temp = (Item[]) new Object[max]; for(int i = 0; i &lt; N; i++)&#123; temp[i] = a[i] &#125; a = temp; &#125; public void push(Item item)&#123; //将元素添加到栈顶 if(N == a.length)&#123; //当没有多余空间，将数组长度加倍 resize(2*a.length); &#125; a[N++] = item; &#125; public Item pop()&#123; //从栈顶删除元素 Item item = a[--N]; a[N] = null;//避免对象游离 //调减的条件是：栈的大小是否小于数组的四分之一，这样在数组长度被减半之后，它的状态为半满， //在下次调整数组大小前仍然能够进行多次push()和pop()操作 if(N &gt; 0 &amp;&amp; N == a.length/4)&#123; resize(a.length/2); &#125; return item; &#125; public Iterator&lt;Item&gt; iterator()&#123; return new ReverseArrayIterator(); &#125; private class ReverseArrayIterator implements Iterator&lt;Item&gt;&#123; //支持后进先出的迭代 private int i = N; public boolean hasNext()&#123; return i &gt; 0; &#125; public Item next()&#123; return a[--i]; &#125; public void remove()&#123; //避免在迭代中穿插能够修改数据结构的操作 &#125; &#125;&#125; 这份泛型的可迭代的Stack API的实现是所有集合类抽象数据类型实现的模板，它将所有元素保存在数组中，支持按照后进先出的顺序迭代访问所有栈元素，并动态调整数组的大小以保持数组大小和栈的大小之比小于一个常数。该实现达到了任意集合类数据类型的实现的最佳性能： 每项操作的用时都与集合大小无关； 空间需求总是不超过集合大小乘以一个常数 缺点是push()和pop()操作可能会调整数组的大小，这项操作的耗时和栈的大小成正比。 对象游离java的垃圾收集策略是回收所有无法被访问的对象的内存。在上面对pop()的实现中，被弹出的元素的引用仍然存在于数组中，这个元素实际上已经不会再被访问了，但java的垃圾收集器没法知道这一点，除非改引用被覆盖。这种保存一个不需要的对象的引用称为游离。 避免游离只需将被弹出的数组元素的值设为null，这将覆盖无用的引用并使系统可以在用例使用完被弹出的元素后回收它的内存。 迭代12345Iterator&lt;String&gt; i = collection.iterator();while(i.hasNext())&#123; String s = i.next(); system.out.println(s);&#125; 这段代码展示了任意可迭代的集合数据类型中需要实现的东西： 集合数据类型必须实现一个iterator()方法并返回一个iterator对象； Iterstor类必须包含两个方法：hasNext()和next()。 要是一个类可迭代，第一步就是在它的声明中加入：implements Iterable，对应的接口是： 123public interface Iterable&lt;Item&gt;&#123; Iterator&lt;Item&gt; iterator();&#125; 然后在类中添加一个方法iterator()并返回一个迭代器Iterator，上面的实现： 123public Iterator&lt;Item&gt; iterator()&#123; return new ReverseArrayIterator();&#125; 迭代器是一个实现了hasNext()和next()方法的类的对象，由Iterator接口定义： 12345public interface Iterator&lt;Item&gt;&#123; boolean hasNext(); Item next(); void remove();&#125; 对于上面的迭代器，它的实现在栈的一个嵌套类中： 12345678910111213private class ReverseArrayIterator implements Iterator&lt;Item&gt;&#123; private int i = N; public boolean hasNext()&#123; return i &gt; 0; &#125; public Item next()&#123; return a[--i]; &#125; public void remove()&#123; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列（Queue）]]></title>
    <url>%2F2017%2F11%2F08%2Falgorithm%2Fqueue%2F</url>
    <content type="text"><![CDATA[介绍队列是一种基于先进先出（FIFO）策略的集合类型。按照任务产生的顺序来完成它们的策略。在应用程序中使用队列的主要原因是在用集合保存元素的同时保存它们的相对顺序：入列顺序和出列顺序相同。队列的一个典型用例： 1234567891011121314151617181920public class QueueOfTyoe &#123; public static int[] readInts(String name) &#123; StdIn in = new StdIn(name); Queue&lt;Integer&gt; q = new Queue&lt;Integer&gt;(); while(!in.isEmpty())&#123; q.enqueue(in.readInt()); &#125; int N = q.size(); int[] a = new int[N]; for(int i=0; i&lt;N; i++)&#123; a[i] = q.dequeue(); &#125; return a; &#125;&#125; API泛型可迭代的队列API： public class Queue implements Iterable Queue() 创建空队列 void enqueue(Item item) 添加一个元素 Item dequeue() 删除最早添加的元素 boolean isEmpty() 队列是否为空 int size() 队列中的元素数量 实现网站上关于队列的一个实现：动态可调整数组大小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class ResizingArrayQueue&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Item[] q; // queue elements private int n; // number of elements on queue private int first; // index of first element of queue private int last; // index of next available slot public ResizingArrayQueue() &#123; q = (Item[]) new Object[2]; n = 0; first = 0; last = 0; &#125; public boolean isEmpty() &#123; return n == 0; &#125; public int size() &#123; return n; &#125; private void resize(int capacity) &#123; assert capacity &gt;= n; Item[] temp = (Item[]) new Object[capacity]; for (int i = 0; i &lt; n; i++) &#123; temp[i] = q[(first + i) % q.length]; &#125; q = temp; first = 0; last = n; &#125; public void enqueue(Item item) &#123; // double size of array if necessary and recopy to front of array if (n == q.length) resize(2*q.length); // double size of array if necessary q[last++] = item; // add item if (last == q.length) last = 0; // wrap-around n++; &#125; public Item dequeue() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underflow"); Item item = q[first]; q[first] = null; // to avoid loitering n--; first++; if (first == q.length) first = 0; // wrap-around // shrink size of array if necessary if (n &gt; 0 &amp;&amp; n == q.length/4) resize(q.length/2); return item; &#125; public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underflow"); return q[first]; &#125; /** * Returns an iterator that iterates over the items in this queue in FIFO order. * @return an iterator that iterates over the items in this queue in FIFO order */ public Iterator&lt;Item&gt; iterator() &#123; return new ArrayIterator(); &#125; // an iterator, doesn't implement remove() since it's optional private class ArrayIterator implements Iterator&lt;Item&gt; &#123; private int i = 0; public boolean hasNext() &#123; return i &lt; n; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = q[(i + first) % q.length]; i++; return item; &#125; &#125; public static void main(String[] args) &#123; ResizingArrayQueue&lt;String&gt; queue = new ResizingArrayQueue&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals("-")) queue.enqueue(item); else if (!queue.isEmpty()) StdOut.print(queue.dequeue() + " "); &#125; StdOut.println("(" + queue.size() + " left on queue)"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包（Bag）]]></title>
    <url>%2F2017%2F11%2F08%2Falgorithm%2Fbag%2F</url>
    <content type="text"><![CDATA[介绍许多基础数据类型都和对象的集合有关，具体来说，数据类型的值就是一组对象的集合，所有操作都是关于添加、删除或是访问集合中的对象。背包、队列和栈这三种数据类型，不同之处在于删除或者访问对象的顺序不同。 背包是一种不支持从中删除元素的集合数据类型，它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素，迭代的顺序不确定切与用例无关。背包的典型用例： 计算标准输入中的所有double值的平均值和样本标准差。样本标准差为每个值和平均值之差的平方之和除以N-1之后的平方根。 1234567891011121314151617181920212223242526public class BagOfType &#123; public static void main(String[] args) &#123; Bag&lt;Double&gt; numbers = new Bag&lt;Double&gt;(); while(!StdIn.isEmpty())&#123; numbers.add(StdIn.readDouble()); &#125; int N = numbers.size(); double sum = 0.0; for(double x : numbers)&#123; sum += x; &#125; double mean = sum/N; sum = 0.0; for(double x : numbers)&#123; sum += (x-mean)*(x-mean); &#125; double std = Math.sqrt(sum/(N-1)); System.out.println("Mean: " + mean); System.out.println("Std: " + mean); &#125;&#125; API泛型可迭代的背包API： public class Bag implements Iterable Bag() 创建一个空背包 void add(Item item) 添加一个元素 boolean isEmpty() 背包是否为空 int size() 背包中的元素数量 实现网站上关于背包的一个实现：用数组实现的可动态调整数组大小的背包实现，后面学习链表会给出一个链表实现的背包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ResizingArrayBag&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Item[] a; // array of items private int n; // number of elements on bag public ResizingArrayBag() &#123; a = (Item[]) new Object[2]; n = 0; &#125; public boolean isEmpty() &#123; return n == 0; &#125; public int size() &#123; return n; &#125; private void resize(int capacity) &#123; assert capacity &gt;= n; Item[] temp = (Item[]) new Object[capacity]; for (int i = 0; i &lt; n; i++) temp[i] = a[i]; a = temp; &#125; public void add(Item item) &#123; if (n == a.length) resize(2*a.length); // double size of array if necessary a[n++] = item; // add item &#125; public Iterator&lt;Item&gt; iterator() &#123; return new ArrayIterator(); &#125; private class ArrayIterator implements Iterator&lt;Item&gt; &#123; private int i = 0; public boolean hasNext() &#123; return i &lt; n; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); return a[i++]; &#125; &#125; public static void main(String[] args) &#123; ResizingArrayBag&lt;String&gt; bag = new ResizingArrayBag&lt;String&gt;(); bag.add("Hello"); bag.add("World"); bag.add("how"); bag.add("are"); bag.add("you"); for (String s : bag) StdOut.println(s); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-深入分析HashMap]]></title>
    <url>%2F2017%2F11%2F08%2Falgorithm%2Fdeep-hashMap%2F</url>
    <content type="text"><![CDATA[HashMap概述]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求两个正整数的最大公约数]]></title>
    <url>%2F2017%2F10%2F28%2Falgorithm%2Fcommondivisor%2F</url>
    <content type="text"><![CDATA[题目求两个正整数的最大公约数，要求尽可能保证性能。 方法一：暴力枚举法123456789101112131415161718public static int getGreatestCommonDivisor(int numA, int numB)&#123; int samllNum = numA &lt; numB ? numA : numB; int bigNum = numA &gt; numB ? numA : numB; if(bigNum % samllNum)&#123; return samllNum; &#125; int greatestCommonDivisor = 1; for(int i = 2; i &lt;= samllNum/2; i++)&#123; if(numA % i == 0 &amp;&amp; numB &amp; i == 0)&#123; greatestCommonDivisor = i; &#125; &#125; return greatestCommonDivisor;&#125; 暴力枚举的效率比较低，如果传入10000和10001，则需要循环4900次。 方法二：辗转相除法辗转相除法， 又名欧几里得算法（Euclidean algorithm），目的是求出两个正整数的最大公约数。这条算法基于一个定理：两个正整数a和b（a&gt;b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。使用递归的方法来把问题逐步简化： 12345678910111213141516171819public static int getGreatestCommonDivisor(int numA, int numB)&#123; int result = 1; if(numA &gt; numB)&#123; result = gcd(numA, numB); &#125;else&#123; result = gcd(numB, numA); &#125; return result&#125;//递归计算最大公约数private static int gcd(int a, int b)&#123; if(a%b == 0)&#123; return b; &#125;else&#123; return gcd(b, a%b); &#125; &#125; 注：当两个整型数较大时，做a%b取模运算性能会比较低。 方法三：更相减损术更相减损术， 出自于中国古代的《九章算术》，他的原理更加简单：两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数。 12345678910private static int gcd(int a, int b)&#123; if(a == b)&#123; return a; &#125; if(a &lt; b)&#123; return gcd(b-a, a); &#125;else&#123; return gcd(a-b, b); &#125;&#125; 更相减损术避免了大整数取模的性能问题。但是更相减损术依靠两数求差的方式递归，当两数相差悬殊时，比如计算10000和1，就要递归9999次。有什么办法既可以避免大整数取模，又能尽可能减少运算次数？ 方法四：移位运算众所周知，移位运算的性能非常快。对于给定的正整数a和b，不难得到如下的结论。其中gcb(a,b)的意思是a,b的最大公约数函数： 当a和b均为偶数，gcb(a,b) = 2gcb(a/2, b/2) = 2gcb(a&gt;&gt;1, b&gt;&gt;1) 当a为偶数，b为奇数，gcb(a,b) = gcb(a/2, b) = gcb(a&gt;&gt;1, b) 当a为奇数，b为偶数，gcb(a,b) = gcb(a, b/2) = gcb(a, b&gt;&gt;1) 当a和b均为奇数，利用更相减损术运算一次，gcb(a,b) = gcb(b, a-b)， 此时a-b必然是偶数，又可以继续进行移位运算。 比如计算10和25的最大公约数的步骤如下： 整数10通过移位，可以转换成求5和25的最大公约数 利用更相减损法，计算出25-5=20，转换成求5和20的最大公约数 整数20通过移位，可以转换成求5和10的最大公约数 整数10通过移位，可以转换成求5和5的最大公约数 利用更相减损法，因为两数相等，所以最大公约数是5 在两数比较小的时候，暂时看不出计算次数的优势，当两数越大，计算次数的节省就越明显。 1234567891011121314151617181920public static int gcd(int numA, int numB)&#123; if(numA == numB)&#123; return numA; &#125; if(numA &lt; numB)&#123; //保证参数A大于参数B，减少代码量 return gcd(numB, numA); &#125;else&#123; //和1做按位与运算，判断奇偶 if((numA&amp;1) == 0 &amp;&amp; (numB&amp;1) == 0)&#123; //a和b均为偶数 return gcd(numA &gt;&gt; 1, numB &gt;&gt; 1) &lt;&lt; 1; &#125;else if((numA&amp;1) == 0 &amp;&amp; (numB&amp;1) != 0)&#123; //a为偶数,b为奇数 return gcd(numA &gt;&gt; 1, numB); &#125;else if((numA&amp;1) != 0 &amp;&amp; (numB&amp;1) == 0)&#123; //a为奇数,b为偶数 return gcd(numA, numB &gt;&gt; 1); &#125;else&#123; //a和b均为奇数 return gcd(numA, numA - numB); &#125; &#125; &#125; 总结 暴力枚举法：时间复杂度是O(min(a, b)))。 辗转相除法：时间复杂度不太好计算，可以近似为O(log(max(a, b)))，但是取模运算性能较差。 更相减损术：避免了取模运算，但是算法性能不稳定，最坏时间复杂度为O(max(a, b)))。 更相减损术与移位结合：不但避免了取模运算，而且算法性能稳定，时间复杂度为O(log(max(a, b)))。 如果两数都是偶数，计算差值之前会首先让两个数都折半，使得计算次数更少。这种方法做到了部分优化，但一奇一偶的情况也是可以优化的。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算：判断2的乘方]]></title>
    <url>%2F2017%2F10%2F26%2Falgorithm%2Fbitwise%2F</url>
    <content type="text"><![CDATA[题目实现一个方法，判断一个正整数是否是2的乘方（比如16是2的4次方，返回True；18不是2的乘方，返回False）。要求性能尽可能高。 解法一：创建一个中间变量Temp，初始值是1。然后进入一个循环，循环中每次让Temp和目标整数比较，如果相等，则说明目标整数是2的乘方；如果不相等，则让Temp增大一倍，继续循环比较。当Temp大于目标整数时，说明目标整数不是2的乘方。 如果目标整数的大小是N，则此方法的时间复杂度是O（LogN）。 123456789101112public static boolean isPowerOf2(int number)&#123; int temp = 1; while(temp &lt;= number)&#123; if(temp == number)&#123; return true; &#125; //temp = temp * 2; //优化点：乘以2操作改成左移1位 temp = temp &lt;&lt; 1; &#125; return false;&#125; 解法二：因为2的乘方都符合一个规律，即 N&amp;N-1 等于 0，所以直接用这个规律判断即可。该算法时间复杂度是O（1）。 123public static boolean isPowerOf2(int number)&#123; return (number &amp; number -1) == 0; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle高级查询之分组查询]]></title>
    <url>%2F2017%2F10%2F06%2FdataBase%2Fsql-groupby%2F</url>
    <content type="text"><![CDATA[一、常用分组函数1234567SQL&gt; select avg(sal),sum(sal),max(sal),min(sal) from emp; select count() from emp; --计数 select count(distinct deptno) from emp; --vm_concat：行转列 select deptno 部门号,vm_concat(ename) 部门中员工的姓名 from emp group by deptno; set linesize 200; --设置行列的宽度 二、分组函数与空值分组函数会自动忽略空值，NVL函数使分组函数无法忽略空值： 1SQL&gt; select count(*),count(nvl(coum,0)) from emp; 三、group by子句 多个列分组 oracle中在select列表中所有未包含在组函数中的列都应该包含在group by子句中。例： 1SQL&gt; select a,b,c,avg(d) from emp group by a,b,c; --错误代码：ORA-00937 包含在group by中的列不必包含在select列表中 group by语句的增强 用于报表，小计，总计时，group by rollup(a,b)等价于： group by a,b group by a group by null 1234567SQL&gt; select deptno,job,sum(sal) from emp group by deptno,job;--按照部门，职位统计工资总额 + select deptno,sum(sal) from emp group by deptno;--按照部门统计工资总额 --小计 + select sum(sal) from emp; --统计工资总额 --总计 || select deptno,job,sum(sal) from emp group by rollup(deptno,job); 页面显示设置 12SQL&gt; break on deptno skip 2;--部门号只显示一次，不同部门号之间空两行 set pagesize 30;--设置页面大小，每页显示30条记录 四、having子句过滤分组。例：求平均工资大于2000的部门： 1SQL&gt; select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000; where 与having区别： where后不可以使用分组函数，having可以，当不使用分组函数时，两者相同 having 先分组，再过滤 where先过滤，再分组，效率高，使分组记录数大大降低 SQL优化：通用时使用where 五、order by子句可以按照列、别名、表达式、序号进行排序，desc降序，asc升序，通常在sql语句最后。 六、分组函数的嵌套求部门平均工资的最大值： 1SQL&gt; select max(avg(sal)) from emp group by deptno; 七、SQL*PLUS的报表功能1234SQL&gt; title col 15 '我的报表' col 35 sql.pno;--title设置表名称，col 35表示空35个列，sql.pno表示报表页码 col deptno heading 部门号;--设置报表别名 break on deptno skip 1; --部门号分隔，相隔一行--注：如果在select语句中设置，则只针对本次查询有效，单独设置，则本次会话有效 八、 案例三张表：学生表、课程表、成绩表。如下： 问题1：列出有两门（含）以上不及格课程的学生名单及其平均成绩 123456789101112131415--主要思想是按照学生分组，使用case when搜索函数SELECT s.sid,s.sn,avg(sc.score) 平均成绩 FROM s,sc where s.sid = sc.sid group by s.sid,s.sn having count(case when sc.score &lt; 60 then 1 end) &gt;= 2--case when用法：--简单Case函数CASE sexWHEN '1' THEN '男'WHEN '2' THEN '女'ELSE '其他' END--Case搜索函数CASE WHEN sex = '1' THEN '男'WHEN sex = '2' THEN '女'ELSE '其他' END 问题2：1号课程比2号课程成绩高的所有学生名单 123456--主要思想是用成绩表自身做一次连接，一张使用科目1，另一张使用科目2SELECT sid,sn FROM s where sid in( SELECT sc1.sid FROM sc sc1 LEFT JOIN sc sc2 on sc1.sid = sc2.sid where sc1.cid = 1 and sc2.cid = 2 and sc1.score &gt; sc2.score)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle高级查询之子查询]]></title>
    <url>%2F2017%2F10%2F06%2FdataBase%2Fsql-childselect%2F</url>
    <content type="text"><![CDATA[介绍查询工资比scott高的员工： 1SQL&gt; select * from emp where sal &gt; (select sal from emp where ename = 'scott'); 一、可以使用子查询的位置 select select 后的子查询只能是单行子查询，只有一条返回记录 1SQL&gt; select empno,ename,sal,(select job from emp where empno = 7839) 第四列 from emp; having 12SQL&gt; select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; (select max(sal) from emp where deptno = 30) from 1SQL&gt; select * from (select empno,ename,sal from emp); 不可以使用子查询的位置：group by 二、子查询和多表查询主查询与子查询不是同一张表。例：查询部门名称是sales的员工： 12345--子查询SQL&gt; select * from emp where deptno = (select deptno from dept where dname = 'sales');--多表查询SQL&gt; select e.* from emp e, dept d where e.deptno = d.deptno and d.name = 'sales'; sql优化：理论上采用多表查询好，只访问一次数据库 三、子查询的排序问题top-n分析问题。例：排到员工表中工资最高的前三名： 123SQL&gt; select rownum,empno,ename,sal --rownum表示伪列 from (select * from emp order by sal desc) where rownum &lt;= 3;--行号只能用&lt;,&lt;=，不能使用&gt;,&gt;=(因为行号都是从1开始) 四、主查询和子查询的执行顺序一般先子查询，后主查询，但相关子查询例外。例：找到员工表中薪水大于本部门平均水平的员工： 1234SQL&gt; select empno,ename,sal, (select avg(sal) from emp where deptno = e.deptno) avgsal from emp e where sal &gt; (select avg(sal) from emp where deptno = e.deptno); 五、子查询中的null值 单行子查询中null值问题 查询条件一直为false，所以查询不到 多行子查询中null值 a not in (1,2,null) a != 1 and a != 2 and a != null 子查询中增加不是空值的条件：coum is not null 六、分页显示分页查询显示员工信息：显示员工号、姓名、月薪：1.每页显示四条记录 2.显示第二页的员工信息（5-8）3.按照月薪降序排列 123456SQL&gt; select r,empno,ename,sal from (select rownum r,empno,ename,sal from(select rownum, --此时这个r理解为e2表的第一列（e1表的行号） empno,ename,sal from emp order by sal desc) e1 where rownum &lt;= 8) e2 where r &gt;= 5; 七、sql执行计划 执行计划：explain plan for sql语句; 查看该执行计划：select * from table(dbms_xplan.display); 判断标准：cost(%cpu)–消耗的系统资源。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle高级查询之多表查询]]></title>
    <url>%2F2017%2F10%2F04%2FdataBase%2Fsql-join%2F</url>
    <content type="text"><![CDATA[SQL表连接多表查询分为 内连接、外连接和交叉连接。现在有表A和表B： TableA TableB id name id age 1 n1 1 18 2 n2 2 20 4 n4 3 19 一、外连接外连接分为左连接（left join 或left outer join）、右连接（right join 或者 right outer join）、和全外部连接 （full join 或者 full outer join） 1. 左外连接左连接的结果就是left join子句中的左表的所有行，而不仅仅是连接列所匹配的行，如果左表中的某行在右表中没有匹配，则在相关联的结果行中右表的所有选择列均为空值（NULL） 1select * from TableA left join TableB on TableA.id = TableB.id; 结果：TableA(基表)都显示，TableB(外表)第三行条件不匹配，都为null id name id age 1 n1 1 18 2 n2 2 20 4 n4 null null 2. 右外连接右连接就是和左连接相反 1select * from TableA right join TableB on TableA.id = TableB.id; 结果：TableB(基表)都显示，TableA(外表)第三行条件不匹配，都为null id name id age 1 n1 1 18 2 n2 2 20 null null 3 19 3. 全外连接显示左右表中的所有行，当某一个表中没有匹配的行时，则另一个表的选择列表列显示空值（NULL）如果有则显示全部数据 1select * from TableA full join TableB on TableA.id = TableB.id; 结果：TableA和TableB都显示，条件不匹配的都为null id name id age 1 n1 1 18 2 n2 2 20 null null 3 19 4 n4 null null 二、内连接内连接（join 或者inner join）是用比较运算符比较要连接的列的值，不匹配的行不被显示 1select * from TableA join TableB on TableA.id = TableB.id; 结果：只返回条件匹配的行 id name id age 1 n1 1 18 2 n2 2 20 等价于： 1select * from TableA,TableB where TableA.id = TableB.id; 12select * from TableA cross join TableB where TableA.id = TableB.id;--cross join 后只能用where不能用on 三、交叉连接交叉连接（cross join）没有where条件的交叉连接产生连接表的笛卡尔积 1select * from TableA cross join TableB; 结果：返回笛卡儿积 id name id age 1 n1 1 18 2 n2 1 18 4 n4 1 18 1 n1 2 20 2 n2 2 20 4 n4 2 20 1 n1 3 19 2 n2 3 19 4 n4 3 19 等价于： 1select * from TableA,TableB; 四、合并合并（union和union all）用于合并多个select语句的结果集 union：消除重复行 union all：不消除重复行 注：使用union时，两张表查询的结果有相同的列，并且列的类型相同 五、自然连接自然连接（natural join）也叫相等连接，两张表通过natural join连接的时候，相当于有个隐含的WHERE子句，对两张表中同名的对应列相比较看是否相等 1select * from TableA natural join TableB; 等价于： 1select * from TableA , TableB where TableA.depno = TableB.depno; 六、不相等连接两个表中的相关的两列进行不等连接，比较符号一般为&gt;,&lt;,…，BETWEEN.. AND.. 1SELECT EMPNO,ENAME,SAL,GRADE FROM SALGRADE,EMP WHERE EMP.SAL BETWEEN LOSAL AND HISAL; 七、自连接自连接是数据库中经常要用的连接方式，使用自连接可以将自身表的一个镜像当作另一个表来对待，从而能够得到一些特殊的数据 例：有一个学生表Table，里面有学号、功课编号和学生成绩三个字段。用一个SQL查询语句得出每门功课成绩最好的前两名 学号nnum 功课编号pnum 成绩score 1 1 99 2 1 98 3 1 100 4 2 88 5 2 87 6 2 88 7 3 99 8 3 88 9 3 100 1234567SELECT DISTINCT Table1.*FROM Table Table1 INNER JOIN Table Table2 ON Table1.nnum IN(SELECT TOP 2 Table.nnumFROM TableWHERE Table.pnum = Table1.pnumORDER BY score DESC) 八、自连接存在的问题自连接会产生笛卡儿积，不适合操作大表。如：查询员工姓名和员工老板的姓名： 123SQL&gt; select e.ename 员工姓名, b.ename 老板姓名 from emp e, emp b where e.mgr = b.empno --员工的老板号等于老板的员工号 解决方法：层次查询（单表查询）： 12345SQL&gt; select level,empno,ename,sal,mgr --level是伪例 from emp connect by prior empno = mgr --上一层的员工号等于老板号，prior是关键字，表示上一层 start with mgr is null --开始条件，只有根节点可以这样表示，start with empno = 7839 order by level; --按照level排序 自连接和层次查询优缺点： 自连接得到的结果直观，不适合操作大表 层次查询是单表查询，不会得到笛卡尔积。得到结果不直观 九、SQL连接和多表查询的区别无区别，写法不同而已 十、on 和 where 的区别基本没区别，在执行顺序上on比where先执行]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（二十三）解释器模式（Interpreter）]]></title>
    <url>%2F2017%2F09%2F17%2FdesignPattern%2Finterpreter%2F</url>
    <content type="text"><![CDATA[介绍解释器模式(Interpreter Pattern) ：定义语言的文法，并且建立一个解释器来解释该语言中的句子，这里的语言意思是使用规定格式和语法的代码，它是一种类行为型模式。 解释器模式一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。 关系图： Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现。 接口： 123public interface Expression &#123; public int interpret(Context context); &#125; 实现类： 123456public class Plus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()+context.getNum2(); &#125; &#125; 123456public class Minus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()-context.getNum2(); &#125; &#125; 上下文类： 12345678910111213141516171819202122public class Context &#123; private int num1; private int num2; public Context(int num1, int num2) &#123; this.num1 = num1; this.num2 = num2; &#125; public int getNum1() &#123; return num1; &#125; public void setNum1(int num1) &#123; this.num1 = num1; &#125; public int getNum2() &#123; return num2; &#125; public void setNum2(int num2) &#123; this.num2 = num2; &#125; &#125; 测试类： 123456789public class Test &#123; public static void main(String[] args) &#123; // 计算9+2-8的值 int result = new Minus().interpret((new Context(new Plus() .interpret(new Context(9, 2)), 8))); System.out.println(result); &#125; &#125; //输出：3 扩展1. 模式动机 如果在系统中某一特定类型的问题发生的频率很高，此时可以考虑将这些问题的实例表述为一个语言中的句子，因此可以构建一个解释器，该解释器通过解释这些句子来解决这些问题。 解释器模式描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发的编译器中。 2. 模式结构 解释器模式包含如下角色： AbstractExpression: 抽象表达式 TerminalExpression: 终结符表达式 NonterminalExpression: 非终结符表达式 Context: 环境类 Client: 客户类 3. 模式分析 解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。 文法规则实例： expression ::= value | symbol symbol ::= expression ‘+’expression | expression ‘-‘ expression value ::= an integer //一个整数值 在文法规则定义中可以使用一些符号来表示不同的含义，如使用|表示或，使用{和}表示组合，使用*表示出现0次或多次等，其中使用频率最高的符号是表示或关系的|。 除了使用文法规则来定义一个语言，在解释器模式中还可以通过一种称之为抽象语法树(Abstract Syntax Tree, AST)的图形方式来直观地表示语言的构成，每一棵抽象语法树对应一个语言实例。 抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符和非终结符类。 在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一个语法规则，使得系统具有较好的扩展性和灵活性。 典型的抽象表达式类代码： 123public abstract class AbstractExpression &#123; public abstract void interpret(Context ctx);&#125; 典型的终结符表达式类实现代码： 12345public class TerminalExpression extends AbstractExpression &#123; public void interpret(Context ctx) &#123; //对于终结符表达式的解释操作 &#125;&#125; 典型的非终结符表达式类实现代码： 1234567891011121314public class NonterminalExpression extends AbstractExpression &#123; private AbstractExpression left; private AbstractExpression right; public NonterminalExpression(AbstractExpression left,AbstractExpression right) &#123; this.left=left; this.right=right; &#125; public void interpret(Context ctx) &#123; //递归调用每一个组成部分的interpret()方法 //在递归调用时指定组成部分的连接方式，即非终结符的功能 &#125; &#125; 典型的环境类实现代码： 123456789public class Context &#123; private HashMap map = new HashMap(); public void assign(String key, String value) &#123; //往环境类中设值 &#125; public String lookup(String key) &#123; //获取存储在环境类中的值 &#125;&#125; 4. 适用场景 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 一些重复出现的问题可以用一种简单的语言来进行表达。 文法较为简单。 效率不是关键问题。 5. 模式应用 解释器模式在使用面向对象语言实现的编译器中得到了广泛的应用，如Smalltalk语言的编译器。 目前有一些基于Java抽象语法树的源代码处理工具，如在Eclipse中就提供了Eclipse AST，它是Eclipse JDT的一个重要组成部分，用来表示Java语言的语法结构，用户可以通过扩展其功能，创建自己的文法规则。 可以使用解释器模式，通过C++、Java、C#等面向对象语言开发简单的编译器，如数学表达式解析器、正则表达式解析器等，用于增强这些语言的功能，使之增加一些新的文法规则，用于解释一些特定类型的语句。 6. 模式扩展数学表达式解析器： 在实际项目开发中如果需要解析数学公式，无须再运用解释器模式进行设计，可以直接使用一些第三方解析工具包，它们可以统称为数学表达式解析器(Math Expression Parser, MEP)，如Expression4J、Jep、JbcParser、Symja、Math Expression String Parser(MESP)等来取代解释器模式，它们可以方便地解释一些较为复杂的文法，功能强大，且使用简单，效率较好。 Expression4J是一个基于Java的开源框架，它用于对数学表达式进行操作，是一个数学公式解析器，在Expression4J中可以将数学表达式存储在字符串对象中。Expression4J是高度定制的，用户可以自定义文法，其主要功能包括实数和复数的基本数学运算，支持基本数学函数、复杂函数以及用户使用Java语言自定义的函数和文法，还可以定义函数目录（函数集）、支持XML配置文件等。 Jep是一个用于解析和求解数学表达式的Java类库。通过使用Jep提供的包，我们可以输入一个以字符串表示的任意数学公式，然后立即对其进行求解。Jep支持用户自定义变量、常量和自定义函数，同时还包含了大量通用的数学函数和常量。 7. 模式优缺点 优点 易于改变和扩展文法。 易于实现文法。 增加了新的解释表达式的方式。 缺点 对于复杂文法难以维护。 执行效率较低。 应用场景很有限。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（二十二）中介者模式（Mediator）]]></title>
    <url>%2F2017%2F09%2F17%2FdesignPattern%2Fmediator%2F</url>
    <content type="text"><![CDATA[介绍中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。 中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。 关系图： User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护。 接口： 1234public interface Mediator &#123; public void createMediator(); public void workAll(); &#125; 实现类： 123456789101112131415161718192021222324public class MyMediator implements Mediator &#123; private User user1; private User user2; public User getUser1() &#123; return user1; &#125; public User getUser2() &#123; return user2; &#125; @Override public void createMediator() &#123; user1 = new User1(this); user2 = new User2(this); &#125; @Override public void workAll() &#123; user1.work(); user2.work(); &#125; &#125; 抽象类： 12345678910111213public abstract class User &#123; private Mediator mediator; public Mediator getMediator()&#123; return mediator; &#125; public User(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void work(); &#125; 实现类1： 12345678910public class User1 extends User &#123; public User1(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println("user1 exe!"); &#125; &#125; 实现类2： 12345678910public class User2 extends User &#123; public User2(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println("user2 exe!"); &#125; &#125; 测试类： 123456789101112public class Test &#123; public static void main(String[] args) &#123; Mediator mediator = new MyMediator(); mediator.createMediator(); mediator.workAll(); &#125; &#125; //输出/*user1 exe!user2 exe!*/ 扩展1. 模式动机 在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的责。 对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式。 2. 模式结构 中介者模式包含如下角色： Mediator: 抽象中介者 ConcreteMediator: 具体中介者 Colleague: 抽象同事类 ConcreteColleague: 具体同事类 3. 模式分析中介者承担两方面的职责： 中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。 协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。 典型的抽象中介者类代码： 12345678public abstract class Mediator &#123; protected ArrayList colleagues; public void register(Colleague colleague) &#123; colleagues.add(colleague); &#125; public abstract void operation();&#125; 典型的具体中介者类代码： 1234567public class ConcreteMediator extends Mediator &#123; public void operation() &#123; //...... ((Colleague)(colleagues.get(0))).method1(); //...... &#125;&#125; 典型的抽象同事类代码： 1234567891011public abstract class Colleague &#123; protected Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator=mediator; &#125; public abstract void method1(); public abstract void method2();&#125; 典型的具体同事类代码： 12345678910111213public class ConcreteColleague extends Colleague &#123; public ConcreteColleague(Mediator mediator) &#123; super(mediator); &#125; public void method1() &#123; //...... &#125; public void method2() &#123; mediator.operation1(); &#125;&#125; 4. 适用场景 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类。 5. 模式应用 中介者模式在事件驱动类软件中应用比较多，在设计GUI应用程序时，组件之间可能存在较为复杂的交互关系，一个组件的改变将影响与之相关的其他组件，此时可以使用中介者模式来对组件进行协调。 MVC是Java EE 的一个基本模式，此时控制器Controller 作为一种中介者，它负责控制视图对象View和模型对象Model之间的交互。如在Struts中，Action就可以作为JSP页面与业务对象之间的中介者。 6. 模式扩展 中介者模式与迪米特法则 在中介者模式中，通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。 中介者模式与GUI开发 中介者模式可以方便地应用于图形界面(GUI)开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系。 对于这些复杂的交互关系，有时候我们可以引入一个中介者类，将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。 7. 模式优缺点 优点 简化了对象之间的交互。 将各同事解耦。 减少子类生成。 可以简化各同事类的设计和实现。 缺点 在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（二十一）访问者模式（Visitor）]]></title>
    <url>%2F2017%2F09%2F17%2FdesignPattern%2Fvisitor%2F</url>
    <content type="text"><![CDATA[介绍访问者模式(Visitor Pattern)：表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。 简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。 关系图： Visitor接口：存放要访问的对象 123public interface Visitor &#123; public void visit(Subject sub); &#125; 实现类： 123456public class MyVisitor implements Visitor &#123; @Override public void visit(Subject sub) &#123; System.out.println("visit the subject："+sub.getSubject()); &#125; &#125; Subject接口：accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性 1234public interface Subject &#123; public void accept(Visitor visitor); public String getSubject(); &#125; 实现类： 1234567891011public class MySubject implements Subject &#123; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; @Override public String getSubject() &#123; return "love"; &#125; &#125; 测试类： 12345678public class Test &#123; public static void main(String[] args) &#123; Visitor visitor = new MyVisitor(); Subject sub = new MySubject(); sub.accept(visitor); &#125; &#125; //输出：visit the subject：love 该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情： 新功能会不会与现有功能出现兼容性问题？ 以后会不会再需要添加？ 如果类不允许修改代码怎么办？ 面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦 扩展1. 模式动机 在实际使用时，对同一集合对象的操作并不是唯一的，对相同的元素对象可能存在多种不同的操作方式。而且这些操作方式并不稳定，可能还需要增加新的操作，以满足新的业务需求。此时，访问者模式就是一个值得考虑的解决方案。 访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式。 2. 模式结构 访问者模式包含如下角色： Vistor: 抽象访问者 ConcreteVisitor: 具体访问者 Element: 抽象元素 ConcreteElement: 具体元素 ObjectStructure: 对象结构 3. 模式分析 访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。 访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素。 相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性 典型的抽象访问者类代码： 1234567public abstract class Visitor &#123; public abstract void visit(ConcreteElementA elementA); public abstract void visit(ConcreteElementB elementB); public void visit(ConcreteElementC elementC) &#123; //元素ConcreteElementC操作代码 &#125;&#125; 典型的具体访问者类代码： 12345678public class ConcreteVisitor extends Visitor &#123; public void visit(ConcreteElementA elementA) &#123; //元素ConcreteElementA操作代码 &#125; public void visit(ConcreteElementB elementB) &#123; //元素ConcreteElementB操作代码 &#125;&#125; 典型的抽象元素类代码： 123public interface Element &#123; public void accept(Visitor visitor);&#125; 具体元素类代码： 123456789public class ConcreteElementA implements Element &#123; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public void operationA() &#123; //业务方法 &#125;&#125; 典型的对象结构类代码： 12345678910111213141516public class ObjectStructure &#123; private ArrayList list=new ArrayList(); public void accept(Visitor visitor) &#123; Iterator i=list.iterator(); while(i.hasNext()) &#123; ((Element)i.next()).accept(visitor); &#125; &#125; public void addElement(Element element) &#123; list.add(element); &#125; public void removeElement(Element element) &#123; list.remove(element); &#125;&#125; 4. 适用场景 一个对象结构包含很多类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作污染这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 5. 模式应用 在一些编译器的设计中运用了访问者模式，程序代码是被访问的对象，它包括变量定义、变量赋值、逻辑运算、算术运算等语句，编译器需要对代码进行分析，如检查变量是否定义、变量是否赋值、算术运算是否合法等，可以将不同的操作封装在不同的类中，如检查变量定义的类、检查变量赋值的类、检查算术运算是否合法的类，这些类就是具体访问者，可以访问程序代码中不同类型的语句。在编译过程中除了代码分析外，还包含代码优化、空间分配和代码生成等部分，也可以将每一个不同编译阶段的操作封装到了跟该阶段有关的一个访问者类中。 在常用的Java XML处理技术DOM4J中，可以通过访问者模式的方式来读取并解析XML文档，VisitorSupport是DOM4J提供的Visitor接口的默认适配器，具体访问者只需继承VisitorSupport类即可。 12345678public class MyVisitor extends VisitorSupport &#123; public void visit(Element element) &#123; System.out.println(element.getName()); &#125; public void visit(Attribute attr) &#123; System.out.println(attr.getName()); &#125;&#125; 6. 模式扩展 与其他模式联用 由于访问者模式需要对对象结构进行操作，而对象结构本身是一个元素对象的集合，因此访问者模式经常需要与迭代器模式联用，在对象结构中使用迭代器来遍历元素对象。 在访问者模式中，元素对象可能存在容器对象和叶子对象，因此可以结合组合模式来进行设计。 访问者模式以一种倾斜的方式支持开闭原则，增加新的访问者方便，但是增加新的元素很困难。 7. 模式优缺点 优点 使得增加新的访问操作变得很容易。 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散到一个个的元素类中。 可以跨过类的等级结构访问属于不同的等级结构的元素类。 让用户能够在不修改现有类层次结构的情况下，定义该类层次结构的操作。 缺点 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了开闭原则的要求。 破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（二十）状态模式（State）]]></title>
    <url>%2F2017%2F09%2F17%2FdesignPattern%2Fstate%2F</url>
    <content type="text"><![CDATA[介绍状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对外看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。 核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点： 可以通过改变状态来获得不同的行为。 你的好友能同时看到你的变化。 关系图： State类是个状态类，Context类可以实现切换。 状态类： 12345678910111213141516171819public class State &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public void method1()&#123; System.out.println("execute the first opt!"); &#125; public void method2()&#123; System.out.println("execute the second opt!"); &#125; &#125; 切换类： 1234567891011121314151617181920212223 public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; &#125; public void method() &#123; if (state.getValue().equals("state1")) &#123; state.method1(); &#125; else if (state.getValue().equals("state2")) &#123; state.method2(); &#125; &#125; &#125; 测试类： 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; State state = new State(); Context context = new Context(state); //设置第一种状态 state.setValue("state1"); context.method(); //设置第二种状态 state.setValue("state2"); context.method(); &#125; &#125; //输出：/*execute the first opt!execute the second opt!*/ 根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。 扩展1. 模式动机 一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的 (stateful)对象。 2. 模式结构 状态模式包含如下角色： Context: 环境类 State: 抽象状态类 ConcreteState: 具体状态类 3. 模式分析 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。 状态模式的关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。 房间入住用状态模式改进的例子 需求： 流程代码： 123456789101112131415161718if(state=="空闲") &#123; if(预订房间) &#123; 预订操作; state="已预订"; &#125;else if(住进房间) &#123; 入住操作; state="已入住"; &#125;&#125;else if(state=="已预订") &#123; if(住进房间) &#123; 入住操作; state="已入住"; &#125;else if(取消预订) &#123; 取消操作; state="空闲"; &#125;&#125; 状态模式： 12345678//重构之后的“空闲状态类”示例代码if(预订房间) &#123; //预订操作; context.setState(new 已预订状态类());&#125;else if(住进房间) &#123; //入住操作; context.setState(new 已入住状态类());&#125; 在状态模式结构中需要理解环境类与抽象状态类的作用： 环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。 抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件：这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。 4. 适用场景 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。 5. 模式应用 状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。 在目前主流的RPG（Role Play Game，角色扮演游戏）中，使用状态模式可以对游戏角色进行控制，游戏角色的升级伴随着其状态的变化和行为的变化。对于游戏程序本身也可以通过状态模式进行总控，一个游戏活动包括开始、运行、结束等状态，通过对状态的控制可以控制系统的行为，决定游戏的各个方面，因此可以使用状态模式对整个游戏的架构进行设计与实现。 6. 模式扩展 共享状态 在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Switch &#123; private static State state,onState,offState; private String name; public Switch(String name) &#123; this.name=name; onState=new OnState(); offState=new OffState(); state=onState; &#125; public void setState(State state) &#123; this.state=state; &#125; public void on() &#123; System.out.print(name); state.on(this); &#125; public void off() &#123; System.out.print(name); state.off(this); &#125; public static State getState(String type) &#123; if(type.equalsIgnoreCase("on")) &#123; return onState; &#125;else &#123; return offState; &#125; &#125;&#125;abstract class State &#123; public abstract void on(Switch s); public abstract void off(Switch s);&#125;class OnState extends State &#123; public void on(Switch s) &#123; System.out.println("已经打开！"); &#125; public void off(Switch s) &#123; System.out.println("关闭！"); s.setState(Switch.getState("off")); &#125;&#125;class OffState extends State &#123; public void on(Switch s) &#123; System.out.println("打开！"); s.setState(Switch.getState("on")); &#125; public void off(Switch s) &#123; System.out.println("已经关闭！"); &#125;&#125;class Client &#123; public static void main(String args[]) &#123; Switch s1,s2; s1=new Switch("开关1"); s2=new Switch("开关2"); s1.on(); s2.on(); s1.off(); s2.off(); s2.on(); s1.on(); &#125;&#125; 简单状态模式与可切换状态的状态模式： 简单状态模式是指状态都相互独立，状态之间无须进行转换的状态模式，这是最简单的一种状态模式。对于这种状态模式，每个状态类都封装与状态相关的操作，而无须关心状态的切换，可以在客户端直接实例化状态类，然后将状态对象设置到环境类中。如果是这种简单的状态模式，它遵循“开闭原则”，在客户端可以针对抽象状态类进行编程，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。 大多数的状态模式都是可以切换状态的状态模式，在实现状态切换时，在具体状态类内部需要调用环境类Context的setState()方法进行状态的转换操作，在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的setState()方法实现状态的切换。在这种可以切换状态的状态模式中，增加新的状态类可能需要修改其他某些状态类甚至环境类的源代码，否则系统无法切换到新增状态。 7. 模式优缺点 优点 封装了转换规则。 枚举可能的状态，在枚举状态之前需要确定状态种类。 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点 状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十九）备忘录模式（Memento）]]></title>
    <url>%2F2017%2F09%2F17%2FdesignPattern%2Fmemento%2F</url>
    <content type="text"><![CDATA[介绍备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。 关系图： Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。 原始类： 1234567891011121314151617181920212223public class Original &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public Original(String value) &#123; this.value = value; &#125; public Memento createMemento()&#123; return new Memento(value); &#125; public void restoreMemento(Memento memento)&#123; this.value = memento.getValue(); &#125; &#125; 备忘录类： 123456789101112131415public class Memento &#123; private String value; public Memento(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; 存储类： 123456789101112131415public class Storage &#123; private Memento memento; public Storage(Memento memento) &#123; this.memento = memento; &#125; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125; &#125; 测试类： 123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args) &#123; // 创建原始类 Original origi = new Original("egg"); // 创建备忘录 Storage storage = new Storage(origi.createMemento()); // 修改原始类的状态 System.out.println("初始化状态为：" + origi.getValue()); origi.setValue("niu"); System.out.println("修改后的状态为：" + origi.getValue()); // 回复原始类的状态 origi.restoreMemento(storage.getMemento()); System.out.println("恢复后的状态为：" + origi.getValue()); &#125; &#125; //输出：/*初始化状态为：egg修改后的状态为：niu恢复后的状态为：egg*/ 扩展1. 模式动机 在应用软件的开发过程中，很多时候我们都需要记录一个对象的内部状态。 在具体实现过程中，为了允许用户取消不确定的操作或从错误中恢复过来，需要实现备份点和撤销机制，而要实现这些机制，必须事先将状态信息保存在某处，这样才能将对象恢复到它们原先的状态。 现在大多数软件都有撤销(Undo)的功能，快捷键一般都是Ctrl+Z。备忘录模式是一种给我们的软件提供后悔药的机制，通过它可以使系统恢复到某一特定的历史状态。 2. 模式结构 备忘录模式包含如下角色： Originator: 原发器 Memento: 备忘录 Caretaker: 负责人 3. 模式分析 由于在备忘录中存储的是原发器的中间状态，因此需要防止原发器以外的其他对象访问备忘录。 为了实现对备忘录对象的封装，需要对备忘录的调用进行控制： 对于原发器而言，它可以调用备忘录的所有信息，允许原发器访问返回到先前状态所需的所有数据。 对于负责人而言，只负责备忘录的保存并将备忘录传递给其他对象。 对于其他对象而言，只需要从负责人处取出备忘录对象并将原发器对象的状态恢复，而无须关心备忘录的保存细节。 理想的情况是只允许生成该备忘录的那个原发器访问备忘录的内部状态。 典型的原发器类代码： 123456789101112131415161718public class Originator &#123; private String state; public Originator()&#123;&#125; // 创建一个备忘录对象 public Memento createMemento()&#123; return new Memento(this); &#125; // 根据备忘录对象恢复原发器状态 public void restoreMemento(Memento m) &#123; state = m.state; &#125; public void setState(String state) &#123; this.state=state; &#125; public String getState() &#123; return this.state; &#125;&#125; 典型的备忘录类代码： 123456789101112class Memento &#123; private String state; public Memento(Originator o)&#123; state = o.state; &#125; public void setState(String state) &#123; this.state=state; &#125; public String getState() &#123; return this.state; &#125;&#125; 典型的负责人类代码： 123456789public class Caretaker &#123; private Memento memento; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento=memento; &#125;&#125; 4. 适用场景 保存一个对象在某一个时刻的状态或部分状态，这样以后需要时它能够恢复到先前的状态。 如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过负责人可以间接访问其内部状态。 5. 模式应用 撤销操作 但是当软件关闭再打开时不能再进行撤销操作，也就是说不能再回到关闭软件前的状态，实际上这中间就使用到了备忘录模式，在编辑文件的同时可以保存一些内部状态，这些状态在软件关闭时从内存销毁，当然这些状态的保存也不是无限的，很多软件只提供有限次的撤销操作。 回滚操作 数据库管理系统DBMS所提供的事务管理应用了备忘录模式，当数据库某事务中一条数据操作语句执行失败时，整个事务将进行回滚操作，系统回到事务执行之前的状态。 6. 模式扩展 备忘录的封装性 为了确保备忘录的封装性，除了原发器外，其他类是不能也不应该访问备忘录类的。 C++可以用friend关键字，使原发器类和备忘录类成为友元类，互相之间可以访问对象的一些私有的属性。 在Java语言中可以将两个类放在一个包中，使它们之间满足默认的包内可见性，也可以将备忘录类作为原发器类的内部类，使得只有原发器才可以访问备忘录中的数据，其他对象都无法使用备忘录中的数据。 多备份实现 在负责人中定义一个集合对象来存储多个状态，而且可以方便地返回到某一历史状态。 在备份对象时可以做一些记号，这些记号称为检查点(Check Point)。在使用HashMap等实现时可以使用Key来设置检查点。 7. 模式优缺点 优点 提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用先前存储起来的备忘录将状态复原。 实现了信息的封装，一个备忘录对象是一种原发器对象的表示，不会被其他代码改动，这种模式简化了原发器对象，备忘录只保存原发器的状态，采用堆栈来存储备忘录对象可以实现多次撤销操作，可以通过在负责人中定义集合对象来存储多个备忘录。 缺点 资源消耗过大，如果类的成员变量太多，就不可避免占用大量的内存，而且每保存一次对象的状态都需要消耗内存资源，如果知道这一点大家就容易理解为什么一些提供了撤销功能的软件在运行时所需的内存和硬盘空间比较大了。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十八）命令模式（Command）]]></title>
    <url>%2F2017%2F09%2F17%2FdesignPattern%2Fcommand%2F</url>
    <content type="text"><![CDATA[介绍命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。 命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。 关系图： Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象。 接口： 123public interface Command &#123; public void exe(); &#125; 实现类： 123456789101112public class MyCommand implements Command &#123; private Receiver receiver; public MyCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void exe() &#123; receiver.action(); &#125; &#125; 调用者： 1234567891011public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void action()&#123; command.exe(); &#125; &#125; 被调用者： 12345public class Receiver &#123; public void action()&#123; System.out.println("command received!"); &#125; &#125; 测试类： 123456789public class Test &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); Command cmd = new MyCommand(receiver); Invoker invoker = new Invoker(cmd); invoker.action(); &#125; &#125; //输出：command received! 命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！ 扩展1. 模式动机 在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。 命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 2. 模式结构 命令模式包含如下角色： Command: 抽象命令类 声明执行操作的接口。有java接口或者抽象类来实现。 Concrete Command: 具体命令类 将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现命令角色声明的执行操作的接口。 Invoker: 调用者 调用命令对象执行这个请求。 Receiver: 接收者 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。 Client:客户类 创建一个具体命令对象（并可以设定它的接收者）。 3. 模式分析 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。 典型的抽象命令类代码： 123public abstract class Command &#123; public abstract void execute();&#125; 典型调用者类代码： 12345678910111213141516public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command=command; &#125; public void setCommand(Command command) &#123; this.command=command; &#125; //业务方法，用于调用命令类的方法 public void call() &#123; command.execute(); &#125;&#125; 典型的具体命令类代码： 123456public class ConcreteCommand extends Command &#123; private Receiver receiver; public void execute() &#123; receiver.action(); &#125;&#125; 典型的请求接收者代码： 12345public class Receiver &#123; public void action() &#123; //具体操作 &#125;&#125; 4. 适用场景 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 系统需要在不同的时间指定请求、将请求排队和执行请求。 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 系统需要将一组操作组合在一起，即支持宏命令。 5. 模式应用 Java语言使用命令模式实现AWT/Swing GUI的委派事件模型 (Delegation Event Model, DEM)。 在AWT/Swing中，Frame、Button等界面组件是请求发送者，而AWT提供的事件监听器接口和事件适配器类是抽象命令接口，用户可以自己写抽象命令接口的子类来实现事件处理，即实现具体命令类，而在具体命令类中可以调用业务处理方法来实现该事件的处理。对于界面组件而言，只需要了解命令接口即可，无须关心接口的实现，组件类并不关心实际操作，而操作由用户来实现。 很多系统都提供了宏命令功能，如UNIX平台下的Shell编程，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列。 6. 模式扩展 撤销操作 结构图 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758abstract class AbstractCommand &#123; public abstract int execute(int value); public abstract int undo();&#125;class ConcreteCommand extends AbstractCommand &#123; private Adder adder = new Adder(); private int value; public int execute(int value) &#123; this.value=value; return adder.add(value); &#125; public int undo() &#123; return adder.add(-value); &#125;&#125;class CalculatorForm &#123; private AbstractCommand command; public void setCommand(AbstractCommand command) &#123; this.command=command; &#125; public void compute(int value) &#123; int i = command.execute(value); System.out.println("执行运算，运算结果为：" + i); &#125; public void undo() &#123; int i = command.undo(); System.out.println("执行撤销，运算结果为：" + i); &#125;&#125;class Adder &#123; private int num=0; public int add(int value) &#123; num+=value; return num; &#125;&#125;class Client &#123; public static void main(String args[]) &#123; CalculatorForm form = new CalculatorForm(); ConcreteCommand command = new ConcreteCommand(); form.setCommand(command); form.compute(10); form.compute(5); form.compute(10); form.undo(); &#125;&#125; 宏命令又称为组合命令，它是命令模式和组合模式联用的产物。宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。 7. 模式优缺点 优点 降低系统的耦合度。 新的命令可以很容易地加入到系统中。 可以比较容易地设计一个命令队列和宏命令（组合命令）。 可以方便地实现对请求的Undo和Redo。 缺点 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十七）责任链模式（Chain of Responsibility）]]></title>
    <url>%2F2017%2F09%2F17%2FdesignPattern%2Fchain%2F</url>
    <content type="text"><![CDATA[介绍职责链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。它是一种对象行为型模式。 责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。 关系图： Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。 接口： 123public interface Handler &#123; public void operator(); &#125; 抽象类： 1234567891011public abstract class AbstractHandler &#123; private Handler handler; public Handler getHandler() &#123; return handler; &#125; public void setHandler(Handler handler) &#123; this.handler = handler; &#125; &#125; 实现类： 123456789101112131415public class MyHandler extends AbstractHandler implements Handler &#123; private String name; public MyHandler(String name) &#123; this.name = name; &#125; @Override public void operator() &#123; System.out.println(name+"deal!"); if(getHandler()!=null)&#123; getHandler().operator(); &#125; &#125; &#125; 测试类： 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; MyHandler h1 = new MyHandler("h1"); MyHandler h2 = new MyHandler("h2"); MyHandler h3 = new MyHandler("h3"); h1.setHandler(h2); h2.setHandler(h3); h1.operator(); &#125; &#125; //输出：/*h1deal!h2deal!h3deal!*/ 此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。 扩展1. 模式动机 职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。 链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并使请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，将请求的发送者和请求的处理者解耦。 2. 模式结构 职责链模式包含如下角色： Handler: 抽象处理者 ConcreteHandler: 具体处理者 Client: 客户类 3. 模式分析 在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。 请求在这条链上传递，直到链上的某一个对象处理此请求为止。 发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。 典型的抽象处理者代码： 123456789public abstract class Handler&#123; protected Handler successor; public void setSuccessor(Handler successor)&#123; this.successor=successor; &#125; public abstract void handleRequest(String request);&#125; 具体处理者代码： 123456789public class ConcreteHandler extends Handler&#123; public void handleRequest(String request)&#123; if(请求request满足条件)&#123; ...... //处理请求； &#125;else&#123; this.successor.handleRequest(request); //转发请求 &#125; &#125;&#125; 4. 适用场景 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可动态指定一组对象处理请求。 5. 模式应用 Java中的异常处理机制。 JavaScript事件浮升机制。 6. 模式扩展纯与不纯的职责链模式： 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：一个是承担责任，另一个是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又将责任向下传的情况。 在一个纯的职责链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的职责链模式里面，一个请求可以最终不被任何接收端对象所接收。 7. 模式优缺点 优点 降低耦合度。 可简化对象的相互连接。 增强给对象指派职责的灵活性。 增加新的请求处理类很方便 缺点 不能保证请求一定被接收。 系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。 ​]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十六）迭代器模式（Iterator）]]></title>
    <url>%2F2017%2F09%2F17%2FdesignPattern%2Fiterator%2F</url>
    <content type="text"><![CDATA[介绍迭代器模式(Iterator Pattern) ：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。 迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。 关系图： 这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例。 两个接口： 123456789public interface Collection &#123; public Iterator iterator(); /*取得集合元素*/ public Object get(int i); /*取得集合大小*/ public int size(); &#125; 1234567891011public interface Iterator &#123; //前移 public Object previous(); //后移 public Object next(); public boolean hasNext(); //取得第一个元素 public Object first(); &#125; 两个实现： 1234567891011121314151617public class MyCollection implements Collection &#123; public String string[] = &#123;"A","B","C","D","E"&#125;; @Override public Iterator iterator() &#123; return new MyIterator(this); &#125; @Override public Object get(int i) &#123; return string[i]; &#125; @Override public int size() &#123; return string.length; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyIterator implements Iterator &#123; private Collection collection; private int pos = -1; public MyIterator(Collection collection)&#123; this.collection = collection; &#125; @Override public Object previous() &#123; if(pos &gt; 0)&#123; pos--; &#125; return collection.get(pos); &#125; @Override public Object next() &#123; if(pos&lt;collection.size()-1)&#123; pos++; &#125; return collection.get(pos); &#125; @Override public boolean hasNext() &#123; if(pos&lt;collection.size()-1)&#123; return true; &#125;else&#123; return false; &#125; &#125; @Override public Object first() &#123; pos = 0; return collection.get(pos); &#125; &#125; 测试类： 1234567891011public class Test &#123; public static void main(String[] args) &#123; Collection collection = new MyCollection(); Iterator it = collection.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125; &#125; //输出：A B C D E 扩展1. 模式动机 一个聚合对象，如一个列表(List)或者一个集合(Set)，应该提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构。 针对不同的需要，可能还要以不同的方式遍历整个聚合对象，但是我们并不希望在聚合对象的抽象层接口中充斥着各种不同遍历的操作。 在迭代器模式中，提供一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。 2. 模式结构 迭代器模式包含如下角色： Iterator: 抽象迭代器 ConcreteIterator: 具体迭代器 Aggregate: 抽象聚合类 ConcreteAggregate: 具体聚合类 3. 模式分析 聚合是一个管理和组织数据对象的数据结构。聚合对象主要拥有两个职责：一是存储内部数据；二是遍历内部数据。 将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器模式的本质。迭代器模式是“单一职责原则”的完美体现。 在迭代器模式中应用了工厂方法模式，聚合类充当工厂类，而迭代器充当产品类，由于定义了抽象层，系统的扩展性很好，在客户端可以针对抽象聚合类和抽象迭代器进行编程。 java编程语言的类库都已经实现了迭代器模式，因此在实际使用中我们很少自定义迭代器，只需要直接使用Java语言中已定义好的迭代器即可。 4. 适用场景 访问一个聚合对象的内容而无须暴露它的内部表示。 需要为聚合对象提供多种遍历方式。 为遍历不同的聚合结构提供一个统一的接口。 5. 模式应用JDK1.2 引入了新的Java聚合框架Collections Collection是所有Java聚合类的根接口。 在JDK类库中，Collection的iterator()方法返回一个java.util.Iterator类型的对象，而其子接口java.util.List的listIterator()方法返回一个java.util.ListIterator类型的对象，ListIterator是Iterator的子类。它们构成了Java语言对迭代器模式的支持，Java语言的java.util.Iterator接口就是迭代器模式的应用。 6. 模式扩展Java迭代器，•在JDK中，Iterator接口具有如下3个基本方法： Object next()：通过反复调用next()方法可以逐个访问聚合中的元素。 boolean hasNext()：hasNext()方法用于判断聚合对象中是否还存在下一个元素，为了不抛出异常，必须在调用next()之前先调用hasNext()。如果迭代对象仍然拥有可供访问的元素，那么hasNext()返回true。 void remove()：用于删除上次调用next()时所返回的元素 1234567Iterator iterator = collection.iterator(); //collection是已实例化的集合对象iterator.next(); // 跳过第一个元素iterator.remove(); // 删除第一个元素iterator.remove();iterator.next(); //该语句不能去掉iterator.remove(); 7. 模式优缺点 优点 它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足开闭原则的要求。 缺点 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 ​]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十五）观察者模式（Observer）]]></title>
    <url>%2F2017%2F09%2F16%2FdesignPattern%2Fobserver%2F</url>
    <content type="text"><![CDATA[介绍观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。 观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。 关系图： MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。 Observer接口: 123public interface Observer &#123; public void update(); &#125; 两个实现类： 123456public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println("observer1 has received!"); &#125; &#125; 123456public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println("observer2 has received!"); &#125; &#125; Subject接口及实现类： 12345678910111213public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); &#125; 123456789101112131415161718192021//抽象类AbstractSubject定义Subject接口的通用方法public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125; &#125; 12345678//MySubject实现自身不同的方法public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println("update self!"); notifyObservers(); &#125; &#125; 测试类： 1234567891011121314public class ObserverTest &#123; public static void main(String[] args) &#123; Subject sub = new MySubject(); sub.add(new Observer1()); sub.add(new Observer2()); sub.operation(); &#125; &#125; //输出：/*update self!observer1 has received!observer2 has received!*/ 扩展1. 模式动机 建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。 2. 模式结构 观察者模式包含如下角色： Subject: 抽象目标 目标角色知道它的观察者，可以有任意多个观察者观察同一个目标。并且提供注册和删除观察者对象的接口。目标角色往往由抽象类或者接口来实现。 ConcreteSubject: 具体目标 将有关状态存入各个Concrete Observer对象。当它的状态发生改变时, 向它的各个观察者发出通知。 Observer: 抽象观察者 为那些在目标发生改变时需要获得通知的对象定义一个更新接口。抽象观察者角色主要由抽象类或者接口来实现。 ConcreteObserver: 具体观察者 存储有关状态，这些状态应与目标的状态保持一致。实现Observer的更新接口以使自身状态与目标的状态保持一致。在本角色内也可以维护一个指向Concrete Subject对象的引用。 3. 模式分析 这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。 ​ 抽象目标类代码： 123456public abstract class Subject &#123; protected ArrayList observers = new ArrayList(); public abstract void attach(Observer observer); public abstract void detach(Observer observer); public abstract void notify();&#125; 具体目标类代码： 123456789101112131415public class ConcreteSubject extends Subject &#123; public void attach(Observer observer) &#123; observers.add(observer); &#125; public void detach(Observer observer) &#123; observers.remove(observer); &#125; public void notify() &#123; for(Object obs:observers) &#123; ((Observer)obs).update(); &#125; &#125; &#125; 抽象观察者代码： 123public interface Observer &#123; public void update();&#125; 具体观察者代码 12345public class ConcreteObserver implements Observer &#123; public void update() &#123; //具体更新代码 &#125;&#125; 测试代码： 12345678public class Test &#123; public static void main(String[] args) &#123; Subject subject = new ConcreteSubject(); Observer observer = new ConcreteObserver(); subject.attach(observer); subject.notify(); &#125;&#125; 4. 适用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，可以使用观察者模式创建一种链式触发机制。 5. 模式应用 委派事件模型 JDK1.1版本及以后的各个版本中，事件处理模型采用基于观察者模式的委派事件模型(DelegationEvent Model, DEM) 在DEM中，事件的发布者称为事件源(Event Source)，而订阅者叫做事件监听器(Event Listener)，在这个过程中还可以通过事件对象(Event Object)来传递与事件相关的信息，可以在事件监听者的实现类中实现事件处理，因此事件监听对象又可以称为事件处理对象。 事件源对象、事件监听对象（事件处理对象）和事件对象构成了Java事件处理模型的三要素。 除了AWT中的事件处理之外，Java语言解析XML的技术SAX2以及Servlet技术的事件处理机制都基于DEM，它们都是观察者模式的应用。 软件开发中 如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息。 某团队战斗游戏中某队友牺牲将给所有成员提示等。 凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 6. 模式扩展 Java语言提供的对观察者模式的支持 在JDK的java.util包中，提供了Observable类以及Observer接口。 MVC模式 观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。 7. 模式优缺点 优点 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信。 观察者模式符合开闭原则的要求。 缺点 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 举例一个随机数产生对象和两个观察者，这两个观察者都在随机数产生对象那里注册了，意思说如果你产生了新的数字，就通知我一声。 结构图： 类说明： 名称 功能说明 Observer 观察者接口，要成为观察者必须实现此接口 NumberGenerator 产生数值的抽象类 RandomNumberGenerator 产生随机数的类 NumberObserver 数字观察者，会打印出变化的数字 SymbolObserver 符号观察者，打印N个符号 Observer接口： 123public interface Observer &#123; public abstract void update(NumberGenerator generator);&#125; NumberGenerator抽象类： 123456789101112131415161718192021222324public abstract class NumberGenerator &#123; private ArrayList observers = new ArrayList(); //存储Observer /** 添加观察者*/ public void addObserver(Observer observer) &#123; observers.add(observer); &#125; /** 删除观察者*/ public void delObserver(Observer observer) &#123; observers.remove(observer); &#125; /** 通知所有观察者*/ public void notifyObservers() &#123; Iterator it = observers.iterator(); while(it.hasNext()) &#123; Observer o =(Observer) it.next(); o.update(this);//this相当于上面提到的邮局名 &#125; &#125; public abstract int getNumber();//获取数字 public abstract void generate();//产生数字&#125; RandomNumberGenerator类： 12345678910111213141516public class RandomNumberGenerator extends NumberGenerator&#123; private Random random = new Random();//随机数产生器 private int number; //用于存放数字 public void generate() &#123; for(int i=0 ; i &lt; 5; i++) &#123; number = random.nextInt(10);//产生10以内的随机数 notifyObservers(); //有新产生的数字，通知所有注册的观察者 &#125; &#125; /** 获得数字*/ public int getNumber() &#123; return number; &#125;&#125; NumberObserver：数字观察者 12345678910public class NumberObserver implements Observer&#123; public void update(NumberGenerator generator) &#123; System.out.println("NumberObserver:"+ generator.getNumber()); try &#123; Thread.sleep(1000 * 3); //为了能清楚的看到输出，休眠3秒钟。 &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; SymbolObserver：符号观察者 123456789101112131415public class SymbolObserver implements Observer&#123; public void update(NumberGenerator generator) &#123; System.out.print("SymbolObserver:"); int count = generator.getNumber(); for(int i = 0 ; i &lt; count; i ++) &#123; System.out.print("*^_^* "); &#125; System.out.println(""); try &#123; Thread.sleep(1000 * 3); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 测试类： 12345678910111213public class Test &#123; public static void main(String[] args) &#123; //实例化数字产生对象 NumberGenerator generator = new RandomNumberGenerator(); //实例化观察者 Observer observer1 = new NumberObserver(); Observer observer2 = new SymbolObserver(); //注册观察者 generator.addObserver(observer1); generator.addObserver(observer2); generator.generate(); //产生数字 &#125;&#125; 测试结果： 123456789101112/*NumberObserver:5SymbolObserver:*^_^* *^_^* *^_^* *^_^* *^_^* NumberObserver:5SymbolObserver:*^_^* *^_^* *^_^* *^_^* *^_^* NumberObserver:9SymbolObserver:*^_^* *^_^* *^_^* *^_^* *^_^* *^_^* *^_^* *^_^* *^_^* NumberObserver:7SymbolObserver:*^_^* *^_^* *^_^* *^_^* *^_^* *^_^* *^_^* NumberObserver:7SymbolObserver:*^_^* *^_^* *^_^* *^_^* *^_^* *^_^* *^_^* */]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十四）模板方法模式（Template Method）]]></title>
    <url>%2F2017%2F09%2F16%2FdesignPattern%2Ftemplate%2F</url>
    <content type="text"><![CDATA[介绍模板方法模式(Template Method Pattern)：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式。 模板方法模式就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。 先看个关系图： 就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用。 抽象类： 123456789101112131415161718public abstract class AbstractCalculator &#123; /*主方法，实现对本类其它方法的调用*/ public final int calculate(String exp,String opt)&#123; int array[] = split(exp,opt); return calculate(array[0],array[1]); &#125; /*被子类重写的方法*/ abstract public int calculate(int num1,int num2); public int[] split(String exp,String opt)&#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125; &#125; 子类： 123456public class Plus extends AbstractCalculator &#123; @Override public int calculate(int num1,int num2) &#123; return num1 + num2; &#125; &#125; 测试类： 12345678public class StrategyTest &#123; public static void main(String[] args) &#123; String exp = "8+8"; AbstractCalculator cal = new Plus(); int result = cal.calculate(exp, "\\+"); System.out.println(result); &#125; &#125; 程序的执行过程：首先将exp和”\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。 扩展1.模式动机 模板方法模式是基于继承的代码复用基本技术，模板方法模式的结构和用法也是面向对象设计的核心之一。在模板方法模式中，可以将相同的代码放在父类中，而将不同的方法实现放在不同的子类中。 在模板方法模式中，我们需要准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来让子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现，这就是模板方法模式的用意。模板方法模式体现了面向对象的诸多重要思想，是一种使用频率较高的模式。 2.模式结构 模板方法模式包含如下角色： AbstractClass: 抽象类 ConcreteClass: 具体子类 3. 模式分析 模板方法模式是一种类的行为型模式，在它的结构图中只有类之间的继承关系，没有对象关联关系。 实现这些具体逻辑步骤的方法称为基本方法(Primitive Method)，而将这些基本法方法汇总起来的方法称为模板方法(Template Method)。 模板方法：一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。 基本方法：基本方法是实现算法各个步骤的方法，是模板方法的组成部分。 抽象方法(Abstract Method) 具体方法(Concrete Method) 钩子方法(Hook Method) 典型抽象类代码： 123456789101112131415public abstract class AbstractClass&#123; public void templateMethod() &#123; //模板方法 primitiveOperation1(); primitiveOperation2(); primitiveOperation3(); &#125; public void primitiveOperation1() &#123; //基本方法—具体方法 //实现代码 &#125; public abstract void primitiveOperation2(); //基本方法—抽象方法 public void primitiveOperation3() &#123; //基本方法—钩子方法 &#125;&#125; 典型的具体子类代码： 12345678public class ConcreteClass extends AbstractClass&#123; public void primitiveOperation2() &#123; //实现代码 &#125; public void primitiveOperation3() &#123; //实现代码 &#125;&#125; 在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，具体子类的基本方法将覆盖父类中定义的基本方法，子类的钩子方法也将覆盖父类的钩子方法，从而可以通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。 4. 适用场景 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。 控制子类的扩展。 5. 模式应用 模板方法模式广泛应用于框架设计（如Spring，Struts等）中，以确保父类控制处理流程的逻辑顺序（如框架的初始化）。 Java单元测试工具JUnit中的TestCase类的设计： 123456789public void runBare() throws Throwable &#123; setUp(); try &#123; runTest(); &#125; finally &#123; tearDown(); &#125;&#125; 6. 模式扩展 模板方法模式鼓励我们恰当使用继承，此模式可以用来改写一些拥有相同功能的相关类，将可复用的一般性的行为代码移到父类里面，而将特殊化的行为代码移到子类里面。这也进一步说明，虽然继承复用存在一些问题，但是在某些情况下还是可以给开发人员带来方便，模板方法模式就是体现继承优势的模式之一。 在模板方法模式中，好莱坞原则体现在：子类不需要调用父类，而通过父类来调用子类，将某些步骤的实现写在子类中，由父类来控制整个过程。 钩子方法 钩子方法的引入使得子类可以控制父类的行为。 最简单的钩子方法就是空方法，也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。 比较复杂一点的钩子方法可以对其他方法进行约束，这种钩子方法通常返回一个boolean类型，即返回true或false，用来判断是否执行某一个基本方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class HookDemo &#123; public abstract void getData(); public void convertData() &#123; System.out.println("通用的数据转换操作。"); &#125; public abstract void displayData(); public void process() &#123; getData(); if(isValid()) &#123; convertData(); &#125; displayData(); &#125; public boolean isValid() &#123; return true; &#125;&#125; class SubHookDemo extends HookDemo &#123; public void getData() &#123; System.out.println("从XML配置文件中获取数据。"); &#125; public void displayData() &#123; System.out.println("以柱状图显示数据。"); &#125; public boolean isValid() &#123; return false; &#125; &#125;class Client &#123; public static void main(String a[]) &#123; HookDemo hd; hd=new SubHookDemo(); hd.process(); &#125;&#125; 7. 模式优缺点 优点 模板方法模式在一个类中形式化地定义算法，而由它的子类实现细节的处理。 模板方法模式是一种代码复用的基本技术。 模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为， 符合开闭原则。 缺点 每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，但是更加符合单一职责原则，使得类的内聚性得以提高。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十三）策略模式（Strategy）]]></title>
    <url>%2F2017%2F09%2F16%2FdesignPattern%2Fstrategy%2F</url>
    <content type="text"><![CDATA[下面开始行为型模式。11种行为型模式的关系： 介绍策略模式(Strategy Pattern)：定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。策略模式是一种对象行为型模式。 关系图如下： 统一接口： 123public interface ICalculator &#123; public int calculate(String exp); &#125; 辅助类： 12345678910public abstract class AbstractCalculator &#123; public int[] split(String exp,String opt)&#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125; &#125; 三个实现类： 1234567public class Plus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"\\+"); return arrayInt[0]+arrayInt[1]; &#125; &#125; 12345678public class Minus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"-"); return arrayInt[0]-arrayInt[1]; &#125; &#125; 12345678public class Multiply extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"\\*"); return arrayInt[0]*arrayInt[1]; &#125; &#125; 测试类： 12345678public class StrategyTest &#123; public static void main(String[] args) &#123; String exp = "2+8"; ICalculator cal = new Plus(); int result = cal.calculate(exp); System.out.println(result); &#125; &#125; 策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。 扩展1.模式动机 完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。 定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。 2. 模式结构 策略模式包含如下角色： Context: 环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 3. 模式分析 策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是准备一组算法，并将每一个算法封装起来，使得它们可以互换。 不使用策略模式的代码： 12345678910111213public class Context&#123; public void algorithm(String type) &#123; if(type == "strategyA")&#123; //算法A &#125; else if(type == "strategyB")&#123; //算法B &#125; else if(type == "strategyC")&#123; //算法C &#125; &#125;&#125; 重构之后的抽象策略类： 123public abstract class AbstractStrategy&#123; public abstract void algorithm(); &#125; 重构之后的具体策略类： 12345public class ConcreteStrategyA extends AbstractStrategy&#123; public void algorithm()&#123; //算法A &#125;&#125; 重构之后的环境类： 123456789public class Context&#123; private AbstractStrategy strategy; public void setStrategy(AbstractStrategy strategy)&#123; this.strategy= strategy; &#125; public void algorithm()&#123; strategy.algorithm(); &#125;&#125; 测试代码： 123456789public class Test&#123; public static void main(String[] args)&#123; AbstractStrategy strategy; Context context = new Context(); strategy = new ConcreteStrategyA(); context.setStrategy(strategy); context.algorithm(); &#125;&#125; 4. 适用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。 5. 模式应用 JavaSE的容器布局管理就是策略模式应用的一个经典实例。 6. 模式扩展策略模式与状态模式 可以通过环境类状态的个数来决定是使用策略模式还是状态模式。 策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。 使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。 如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。 7. 模式优缺点 优点 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。 策略模式提供了可以替换继承关系的办法。 使用策略模式可以避免使用多重条件转移语句。 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 举例设计一个贩卖各类书籍的电子商务网站的购物车系统。折扣是根据以下的几个算法中的一个进行的： 算法一：对初级会员没有折扣。 算法二：对中级会员提供10%的促销折扣。 算法三：对高级会员提供20%的促销折扣。 结构图： 抽象折扣类： 12345678public interface MemberStrategy &#123; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double calcPrice(double booksPrice);&#125; 初级会员折扣类： 1234567public class PrimaryMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于初级会员的没有折扣"); return booksPrice; &#125;&#125; 中级会员折扣类： 1234567public class IntermediateMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于中级会员的折扣为10%"); return booksPrice * 0.9; &#125;&#125; 高级会员折扣类： 1234567public class AdvancedMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于高级会员的折扣为20%"); return booksPrice * 0.8; &#125;&#125; 价格类： 1234567891011121314151617181920public class Price &#123; //持有一个具体的策略对象 private MemberStrategy strategy; /** * 构造函数，传入一个具体的策略对象 * @param strategy 具体的策略对象 */ public Price(MemberStrategy strategy)&#123; this.strategy = strategy; &#125; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double quote(double booksPrice)&#123; return this.strategy.calcPrice(booksPrice); &#125;&#125; 测试类： 1234567891011public class Client &#123; public static void main(String[] args) &#123; //选择并创建需要使用的策略对象 MemberStrategy strategy = new AdvancedMemberStrategy(); //创建环境 Price price = new Price(strategy); //计算价格 double quote = price.quote(300); System.out.println("图书的最终价格为：" + quote); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十一）享元模式（Flyweight）]]></title>
    <url>%2F2017%2F09%2F16%2FdesignPattern%2Fflyweight%2F</url>
    <content type="text"><![CDATA[介绍享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。 举例：数据库连接池 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ConnectionPool &#123; private Vector&lt;Connection&gt; pool; /*公有属性*/ private String url = "jdbc:mysql://localhost:3306/test"; private String username = "root"; private String password = "root"; private String driverClassName = "com.mysql.jdbc.Driver"; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /*构造方法，做一些初始化工作*/ private ConnectionPool() &#123; pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) &#123; try &#123; Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* 返回连接到连接池 */ public synchronized void release() &#123; pool.add(conn); &#125; /* 返回连接池中的一个数据库连接 */ public synchronized Connection getConnection() &#123; if (pool.size() &gt; 0) &#123; Connection conn = pool.get(0); pool.remove(conn); return conn; &#125; else &#123; return null; &#125; &#125; &#125; 扩展1. 模式动机 享元模式通过共享技术实现相同或相似对象的重用。 可以很好地解决一些灵活性或可扩展性问题。 2.模式分析 享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。 享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。 12345678910111213141516171819202122232425262728//典型的享元工厂类代码public class FlyweightFactory&#123; private HashMap flyweights = new HashMap(); public Flyweight getFlyweight(String key)&#123; if(flyweights.containsKey(key))&#123; return (Flyweight)flyweights.get(key); &#125;else&#123; Flyweight fw = new ConcreteFlyweight(); flyweights.put(key,fw); return fw; &#125; &#125;&#125; //典型的享元类代码public class Flyweight&#123; //内部状态作为成员属性 private String intrinsicState; public Flyweight(String intrinsicState)&#123; this.intrinsicState = intrinsicState; &#125; public void operation(String extrinsicState)&#123; ...... &#125; &#125; 享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。 3. 模式结构 享元模式包含如下角色： Flyweight: 抽象享元类 ConcreteFlyweight: 具体享元类 UnsharedConcreteFlyweight: 非共享具体享元类 FlyweightFactory: 享元工厂类 4. 模式扩展 单纯享元模式 在单纯享元模式中，所有的享元对象都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。 复合享元模式 将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。 享元模式与其他模式的联用 在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。 在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。 享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。 5. 适用场景 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。 6.模式应用 字符串连接池 Integer类的valueOf方法 123456//IntegerCache将常用整数-128~127做了缓存处理public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 7. 模式优缺点 优点 享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。 缺点 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十一）组合模式（Composite）]]></title>
    <url>%2F2017%2F09%2F15%2FdesignPattern%2Fcomposite%2F</url>
    <content type="text"><![CDATA[介绍组合模式(Composite Pattern)：组合多个对象形成树形结构以表示整体-部分的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。 关系图： 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class TreeNode &#123; private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); public TreeNode(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public TreeNode getParent() &#123; return parent; &#125; public void setParent(TreeNode parent) &#123; this.parent = parent; &#125; //添加孩子节点 public void add(TreeNode node)&#123; children.add(node); &#125; //删除孩子节点 public void remove(TreeNode node)&#123; children.remove(node); &#125; //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren()&#123; return children.elements(); &#125; &#125; 测试代码： 12345678910111213141516public class Tree &#123; TreeNode root = null; public Tree(String name) &#123; root = new TreeNode(name); &#125; public static void main(String[] args) &#123; Tree tree = new Tree("A"); TreeNode nodeB = new TreeNode("B"); TreeNode nodeC = new TreeNode("C"); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println("build the tree finished!"); &#125; &#125; 扩展1. 模式动机 对于树形结构，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，如子文件夹和文件）并调用执行（递归调用）。 组合模式描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象。 2. 模式结构 组合模式包含如下角色： Component: 抽象构件 Leaf: 叶子构件 Composite: 容器构件 Client: 客户类 3. 模式分析 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。 同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。 抽象构件代码示例： 123456public abstract class Component&#123; public abstract void add(Component c); public abstract void remove(Component c); public abstract Component getChild(int i); public abstract void operation(); &#125; 叶子构件代码示例： 1234567891011public class Leaf extends Component&#123; public void add(Component c)&#123; //异常处理或错误提示 &#125; public void remove(Component c)&#123; //异常处理或错误提示 &#125; public Component getChild(int i)&#123; //异常处理或错误提示 &#125; public void operation()&#123; //实现代码 &#125; &#125; 容器构件示例代码： 123456789101112131415161718192021public class Composite extends Component&#123; private ArrayList list = new ArrayList(); public void add(Component c)&#123; list.add(c); &#125; public void remove(Component c)&#123; list.remove(c); &#125; public Component getChild(int i)&#123; (Component)list.get(i); &#125; public void operation()&#123; for(Object obj:list)&#123; ((Component)obj).operation(); &#125; &#125; &#125; 4. 使用场景 需要表示一个对象整体或部分层次，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。 让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节。 对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们 5. 模式应用 XML文档解析 操作系统中的目录结构是一个树形结构，因此在对文件和文件夹进行操作时可以应用组合模式，例如杀毒软件在查毒或杀毒时，既可以针对一个具体文件，也可以针对一个目录。如果是对目录查毒或杀毒，将递归处理目录中的每一个子目录和文件。 JDK的AWT/Swing是组合模式在Java类库中的一个典型实际应用 6. 模式扩展 透明组合模式 安全组合模式 7. 模式优缺点 优点 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。 客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。 定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。 更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。 缺点 使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。 增加新构件时可能会产生一些问题，很难对容器中的构件类型进行限制。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（十）桥接模式（Bridge）]]></title>
    <url>%2F2017%2F09%2F13%2FdesignPattern%2Fbridge%2F</url>
    <content type="text"><![CDATA[介绍桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。 类图： 接口： 123public interface Sourceable &#123; public void method(); &#125; 实现类： 123456public class SourceSub1 implements Sourceable &#123; @Override public void method() &#123; System.out.println("this is the first sub!"); &#125; &#125; 123456public class SourceSub2 implements Sourceable &#123; @Override public void method() &#123; System.out.println("this is the second sub!"); &#125; &#125; 定义一个桥，持有Sourceable的一个实例： 123456789101112131415public abstract class Bridge &#123; private Sourceable source; public void method()&#123; source.method(); &#125; public Sourceable getSource() &#123; return source; &#125; public void setSource(Sourceable source) &#123; this.source = source; &#125; &#125; 12345public class MyBridge extends Bridge &#123; public void method()&#123; getSource().method(); &#125; &#125; 测试类： 123456789101112131415161718public class BridgeTest &#123; public static void main(String[] args) &#123; Bridge bridge = new MyBridge(); /*调用第一个对象*/ Sourceable source1 = new SourceSub1(); bridge.setSource(source1); bridge.method(); /*调用第二个对象*/ Sourceable source2 = new SourceSub2(); bridge.setSource(source2); bridge.method(); &#125; &#125; //输出：//this is the first sub!//this is the second sub! 这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来再画个图，JDBC连接的原理，有数据库学习基础的，一结合就都懂了。 扩展1. 模式动机 对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。 桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。 2. 模式结构 桥接模式包含如下角色： Abstraction：抽象类 RefinedAbstraction：扩充抽象类 Implementor：实现类接口 ConcreteImplementor：具体实现类 3. 模式分析理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。 抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。 实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。 实现类接口： 123public interface Implementor&#123; public void operationImpl();&#125; 抽象类： 123456789public abstract class Abstraction&#123; protected Implementor impl; public void setImpl(Implementor impl)&#123; this.impl=impl; &#125; public abstract void operation();&#125; 扩充抽象类： 1234567public class RefinedAbstraction extends Abstraction&#123; public void operation()&#123; //代码 impl.operationImpl(); //代码 &#125;&#125; 4. 模式适用场景 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 5. 模式应用 java虚拟机跨平台性 JDBC驱动程序 使用JDBC驱动程序的应用系统就是抽象角色，而所使用的数据库是实现角色。一个JDBC驱动程序可以动态地将一个特定类型的数据库与一个Java应用程序绑定在一起，从而实现抽象角色与实现角色的动态耦合。 6. 适配器模式与桥接模式联用 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。 7. 模式优缺点 优点 分离抽象接口及其实现部分。 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 实现细节对客户透明，可以对用户隐藏实现细节。 缺点 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（九）外观模式（Facade）]]></title>
    <url>%2F2017%2F09%2F13%2FdesignPattern%2Ffacade%2F</url>
    <content type="text"><![CDATA[介绍外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式 外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。我们以一个计算机的启动过程为例。 类图： 实现类：CPU 123456789public class CPU &#123; public void startup()&#123; System.out.println("cpu startup!"); &#125; public void shutdown()&#123; System.out.println("cpu shutdown!"); &#125; &#125; 实现类：Memory 123456789public class Memory &#123; public void startup()&#123; System.out.println("memory startup!"); &#125; public void shutdown()&#123; System.out.println("memory shutdown!"); &#125; &#125; 实现类：Disk 123456789public class Disk &#123; public void startup()&#123; System.out.println("disk startup!"); &#125; public void shutdown()&#123; System.out.println("disk shutdown!"); &#125; &#125; 实现类： 123456789101112131415161718192021222324252627public class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println("start the computer!"); cpu.startup(); memory.startup(); disk.startup(); System.out.println("start computer finished!"); &#125; public void shutdown()&#123; System.out.println("begin to close the computer!"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println("computer closed!"); &#125; &#125; 测试类： 1234567891011121314151617181920public class User &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.startup(); computer.shutdown(); &#125; &#125; //输出：/*start the computer!cpu startup!memory startup!disk startup!start computer finished!begin to close the computer!cpu shutdown!memory shutdown!disk shutdown!computer closed!*/ 引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。 如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式。 扩展1. 模式结构 Facade：外观角色 SubSystem：子系统角色 2. 模式适用场景 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。 3. 模式应用 JDBCFacade 12345678910111213141516public class JDBCFacade &#123; private Connection conn=null; private Statement statement=null; public void open(String driver,String jdbcUrl,String userName,String userPwd) &#123; ...... &#125; public int executeUpdate(String sql) &#123; ...... &#125; public ResultSet executeQuery(String sql) &#123; ...... &#125; public void close() &#123; ...... &#125;&#125; 4. 模式优缺点 优点 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类 缺点 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了开闭原则。 5. 外观模式与迪米特法则 根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。 6. 注意事项 一个系统有多个外观类 在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。在很多情况下为了节约系统资源，一般将外观类设计为单例类。当然这并不意味着在整个系统里只能有一个外观类，在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。 不要试图通过外观类为子系统增加新行为 不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。 抽象外观类的引入 类图： 外观模式最大的缺点在于违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（八）代理模式（Proxy）]]></title>
    <url>%2F2017%2F09%2F12%2FdesignPattern%2Fproxy%2F</url>
    <content type="text"><![CDATA[介绍代理模式就是多一个代理类出来，替原对象进行一些操作。给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模。 关系图： 接口： 123public interface Sourceable &#123; public void method(); &#125; 被代理类： 123456public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125; &#125; 代理类： 12345678910111213141516171819public class Proxy implements Sourceable &#123; private Source source; public Proxy()&#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println("after proxy!"); &#125; private void before() &#123; System.out.println("before proxy!"); &#125; &#125; 测试类： 1234567891011public class ProxyTest &#123; public static void main(String[] args) &#123; Sourceable source = new Proxy(); source.method(); &#125; &#125; //输出：//before proxy!//the original method!//after proxy! 代理模式的应用场景： 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 修改原有的方法来适应。这样违反了对扩展开放，对修改关闭的原则。 就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护。 装饰器模式和代理模式区别： 这两个设计模式看起来很像。对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。此外，不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法。 然而，实际上，在装饰器模式和代理模式之间还是有很多差别的。装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。 我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。 扩展1. 模式动机作用：在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为代理的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。 目的：就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。 2. 动态代理 动态代理是一种较为高级的代理模式，它的典型应用就是Spring AOP。 在传统的代理模式中，客户端通过Proxy调用Source类的method()方法，同时还在代理类中封装了其他方法(如before()和after())，可以处理一些其他问题。 如果按照这种方法使用代理模式，那么真实主题角色必须是事先已经存在的，并将其作为代理对象的内部成员属性。如果一个真实主题角色必须对应一个代理主题角色，这将导致系统中的类个数急剧增加，因此需要想办法减少系统中类的个数，此外，如何在事先不知道真实主题角色的情况下使用代理主题角色，这都是动态代理需要解决的问题。 Java动态代理实现相关类位于java.lang.reflect包，主要涉及两个类： InvocationHandler接口 它是代理实例的调用处理程序实现的接口，该接口中定义了如下方法：public Object invoke (Object proxy, Method method, Object[] args) throws Throwable。 invoke()方法中第一个参数proxy表示代理类，第二个参数method表示需要代理的方法，第三个参数args表示代理方法的参数数组。 Proxy类 该类即为动态代理类，该类最常用的方法为：public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException。 newProxyInstance()方法用于根据传入的接口类型interfaces返回一个动态创建的代理类的实例，方法中第一个参数loader表示代理类的类加载器，第二个参数interfaces表示代理类实现的接口列表（与真实主题类的接口列表一致），第三个参数h表示所指派的调用处理程序类。 3. 代理模式涉及到的角色 抽象角色：声明真实对象和代理对象的共同接口。 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。 为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托 类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。 java动态代理1. Proxyjava.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。 12345678// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器static InvocationHandler getInvocationHandler(Object proxy)// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象static Class getProxyClass(ClassLoader loader, Class[] interfaces)// 方法 3：该方法用于判断指定类对象是否是一个动态代理类static boolean isProxyClass(Class cl)// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例static Object newProxyInstance(ClassLoader loader, Class[] interfaces,InvocationHandler h) Proxy构造方法： 1234// 由于 Proxy 内部从不直接调用构造函数，所以 private 类型意味着禁止任何调用private Proxy() &#123;&#125;// 由于 Proxy 内部从不直接调用构造函数，所以 protected 意味着只有子类可以调用protected Proxy(InvocationHandler h) &#123;this.h = h;&#125; Proxy 静态方法 newProxyInstance： 123456789101112131415161718192021222324public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException &#123; // 检查 h 不为空，否则抛异常 if (h == null) &#123; throw new NullPointerException(); &#125; // 获得与制定类装载器和一组接口相关的代理类类型对象 Class cl = getProxyClass(loader, interfaces); // 通过反射获取构造函数对象并生成代理类实例 try &#123; Constructor cons = cl.getConstructor(constructorParams); return (Object) cons.newInstance(new Object[] &#123; h &#125;); &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString()); &#125; catch (IllegalAccessException e) &#123; throw new InternalError(e.toString()); &#125; catch (InstantiationException e) &#123; throw new InternalError(e.toString()); &#125; catch (InvocationTargetException e) &#123; throw new InternalError(e.toString()); &#125;&#125; 由此可见，动态代理真正的关键是在 getProxyClass 方法，该方法负责为一组接口动态地生成代理类类型对象。 2. InvocationHandlerjava.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。 123// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象// 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行Object invoke(Object proxy, Method method, Object[] args) 每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象（参见 Proxy 静态方法 4 的第三个参数）。 3. ClassLoaderjava.lang.ClassLoader：这是类装载器类，负责将类的字节码装载到 Java 虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何个 .class 文件中。 每次生成动态代理类对象时都需要指定一个类装载器对象（参见 Proxy 静态方法 4 的第一个参数） 4. 代理机制及其特点首先让我们来了解一下如何使用 Java 动态代理。具体有如下四步骤： 通过实现 InvocationHandler 接口创建自己的调用处理器。 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类。 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型。 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 5. 动态代理对象创建过程123456789// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用InvocationHandler handler = new InvocationHandlerImpl(..);// 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象Class clazz = Proxy.getProxyClass(classLoader, new Class[] &#123; Interface.class, ... &#125;);// 通过反射从生成的类对象获得构造函数对象Constructor constructor = clazz.getConstructor(new Class[] &#123; InvocationHandler.class &#125;);// 通过构造函数对象创建动态代理类实例Interface Proxy = (Interface)constructor.newInstance(new Object[] &#123; handler &#125;); 实际使用过程更加简单，因为 Proxy 的静态方法 newProxyInstance 已经为我们封装了步骤 2 到步骤 4 的过程，所以简化后的过程如下： 12345// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发InvocationHandler handler = new InvocationHandlerImpl(..);// 通过 Proxy 直接创建动态代理类实例Interface proxy = (Interface)Proxy.newProxyInstance( classLoader,new Class[] &#123; Interface.class &#125;, handler); 6. 一个动态代理的例子接口： 123public interface Subject&#123; public void request();&#125; 真实类： 12345public class RealSubject implements Subject&#123; public void request()&#123; System.out.println("From real subject!"); &#125;&#125; 具体代理类： 1234567891011121314import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DynamicSubject implements InvocationHandler&#123; private Object sub; public DynamicSubject(Object obj)&#123; this.sub = obj; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; System.out.println("before calling: " + method); method.invoke(sub, args); System.out.println(args == null); System.out.println("after calling: " + method); return null;&#125; 注：该代理类的内部属性是Object类型，实际使用的时候通过该类的构造方法传递进来一个对象。 此外，该类还实现了invoke方法，该方法中的method.invoke其实就是调用被代理对象的将要 执行的方法，方法参数是sub，表示该方法从属于sub，通过动态代理类，我们可以在执行真实对象的方法前后加入自己的一些额外方法。 测试类： 123456789101112131415import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class Client &#123; public static void main(String[] args)&#123; RealSubject realSubject = new RealSubject(); InvocationHandler handler = new DynamicSubject(realSubject); Class&lt;?&gt; classType = handler.getClass(); // 下面的代码一次性生成代理 Subject subject = (Subject) Proxy.newProxyInstance(classType .getClassLoader(), realSubject.getClass().getInterfaces(),handler); subject.request(); System.out.println(subject.getClass()); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（七）装饰模式（Decorator）]]></title>
    <url>%2F2017%2F09%2F12%2FdesignPattern%2Fdecorator%2F</url>
    <content type="text"><![CDATA[介绍装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。 关系图： Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能。 接口： 123public interface Sourceable &#123; public void method(); &#125; 被装饰类： 123456public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125; &#125; 装饰类： 1234567891011121314public class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println("before decorator!"); source.method(); System.out.println("after decorator!"); &#125; &#125; 测试类： 1234567891011public class DecoratorTest &#123; public static void main(String[] args) &#123; Sourceable source = new Source(); Sourceable obj = new Decorator(source); obj.method(); &#125; &#125; //输出：//before decorator!//the original method!//after decorator! 在不改变被装饰类的前提下，通过装饰类装饰被装饰类的每个方法，实现功能增强。 装饰模式应用场景： 需要扩展一个类的功能。 动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 缺点： 产生过多相似的对象，不易排错。 适配器模式和装饰模式的区别： 适配器模式的旧类没有实现目标接口，为了重用旧类的代码，将旧类或者旧类的对象包裹在适配器中，调用的依旧是旧类的代码。 装饰器模式的旧类本身已经实现了目标接口，只是为了动态拓展类的功能，（如在调用方法的前后输出日志等），用装饰器类包裹旧类，调用旧类的代码。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（六）适配器模式（Adapter）]]></title>
    <url>%2F2017%2F09%2F11%2FdesignPattern%2Fadapter%2F</url>
    <content type="text"><![CDATA[介绍适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。 主要分为三类： 类的适配器模式 对象的适配器模式 接口的适配器模式 类适配器模式 核心思想是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里。 类图： Source类： 12345public class Source &#123; public void method1() &#123; System.out.println("this is original method!"); &#125; &#125; Targetable接口： 1234567public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; Adapter类： 123456public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; &#125; 测试类： 12345678910public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125; //输出：//this is original method!//this is the targetable method! 这样Targetable接口的实现类就具有了Source类的功能。 优点： 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 缺点： 适配器模式是补救措施，所以在系统设计过程中请忘掉这个设计模式，这个模式只是在你无可奈何时的补救方式 对象适配器模式 基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。 类图： 只需要修改Adapter类的源码即可： 123456789101112131415161718public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125; 测试类： 12345678public class AdapterTest &#123; public static void main(String[] args) &#123; Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); &#125; &#125; 优点： 一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。 缺点： 与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 接口适配器模式 接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。 类图： Sourceable接口： 1234public interface Sourceable &#123; public void method1(); public void method2(); &#125; Wrapper2抽象类： 1234public abstract class Wrapper2 implements Sourceable&#123; public void method1()&#123;&#125; public void method2()&#123;&#125; &#125; SourceSub1 类： 12345public class SourceSub1 extends Wrapper2 &#123; public void method1()&#123; System.out.println("the sourceable interface's first Sub1!"); &#125; &#125; SourceSub2 类： 12345public class SourceSub2 extends Wrapper2 &#123; public void method2()&#123; System.out.println("the sourceable interface's second Sub2!"); &#125; &#125; 测试类： 1234567891011public class WrapperTest &#123; public static void main(String[] args) &#123; Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); //the sourceable interface's first Sub1! source1.method2(); source2.method1(); source2.method2(); //the sourceable interface's second Sub2! &#125; &#125; 总结一下三种适配器模式的应用场景： 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。 扩展1. 模式动机 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。 2. 模式结构 Target：目标抽象类或接口 Adapter：适配器类（用来实现接口或继承Source源类） Adaptee：适配者类（Source源类） Client：客户类（测试类） 3. 模式应用 1Arrays.asList(T a); 抽象类实现接口，选择性实现接口的方法。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（五）原型模式（Prototype）]]></title>
    <url>%2F2017%2F09%2F10%2FdesignPattern%2FPrototype%2F</url>
    <content type="text"><![CDATA[介绍用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 Prototype原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。它主要面对的问题是：“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。 原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。通过对象的复制，进行讲解。 在Java中，复制对象是通过clone()实现的，先创建一个原型类： 123456public class Prototype implements Cloneable &#123; public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125; &#125; 很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的。 原型模式最大的特点是克隆一个现有的对象，这个克隆的结果有2种，一种是是浅复制，另一种是深复制，创建型模式一般是用来创建一个新的对象，然后我们使用这个对象完成一些对象的操作，通过原型模式可以快速的创建一个对象而不需要提供专门的new()操作就可以快速完成对象的创建，这无疑是一种非常有效的方式，快速的创建一个新的对象。 结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念： 浅复制 将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。 原型模式原理图： 一个深浅复制的例子1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 需要实现Cloneable接口 */ public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125; /* 深复制 需要实现Cloneable和Serializable接口 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public String getString() &#123; return string; &#125; public void setString(String string) &#123; this.string = string; &#125; public SerializableObject getObj() &#123; return obj; &#125; public void setObj(SerializableObject obj) &#123; this.obj = obj; &#125; &#125; class SerializableObject implements Serializable &#123; private static final long serialVersionUID = 1L; &#125; 要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。 测试类: 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args)throws CloneNotSupportedException,ClassNotFoundException ,IOException&#123; Prototype pt=new Prototype(); SerializableObject obj=new SerializableObject(); pt.setObj(obj); pt.setStr("Hello World"); System.out.println("使用浅克隆方法进行创建对象"); Prototype pt1=(Prototype)pt.clone(); System.out.println("============================="); System.out.println("比较pt和pt1的str的值："); System.out.println(pt.getStr()); System.out.println(pt1.getStr()); System.out.println("修改pt1对象中str的值后，比较pt和pt1的str的值："); pt1.setStr("你好，世界"); System.out.println(pt.getStr()); System.out.println(pt1.getStr()); System.out.println("============================"); System.out.println("比较pt和pt1中temp对象的值"); System.out.println(pt.getObj()); System.out.println(pt1.getObj()); System.out.println("使用深克隆方法进行创建对象"); System.out.println("============================"); pt1=(Prototype)pt.deepClone(); System.out.println(pt.getObj()); System.out.println(pt1.getObj()); &#125;&#125; 测试结果： 123456789101112131415161718/*使用浅克隆方法进行创建对象=============================比较pt和pt1的str的值：Hello WorldHello World修改pt1对象中str的值后，比较pt和pt1的str的值：Hello World你好，世界============================比较pt和pt1中temp对象的值Temp@affc70Temp@affc70使用深克隆方法进行创建对象============================Temp@affc70Temp@15d56d5*/ 从上面的输出结果我们可以看出使用Object.clone()方法只能浅层次的克隆，即只能对那些成员变量是基本类型或String类型的对象进行克隆，对哪些成员变量是类类型的对象进行克隆要使用到对象的序列化，不然克隆克隆出来的Prototype对象都共享同一个obj实例。 模型分析Java语言提供的clone()方法将对象复制了一份并返回给调用者。一般而言，clone()方法满足： 对任何的对象x，都有x.clone() !=x，即克隆对象与原对象不是同一个对象。 对任何的对象x，都有x.clone().getClass()==x.getClass()，即克隆对象与原对象的类型一样。 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。 浅拷贝：一定要实现Cloneable接口（否则CloneNotSupportedException异常）。 深拷贝；实现Cloneable 和Serializable接口。 原型模式优缺点 优点 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。 可以动态增加或减少产品类。 原型模式提供了简化的创建结构。 可以使用深克隆的方式保存对象的状态。 缺点 需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了开闭原则。 在实现深克隆时需要编写较为复杂的代码。 总结原型模式作为创建型模式中的最特殊的一个模式，具体的创建过程，是由对象本身提供，这样我们在很多的场景下，我们可以很方便的快速的构建新的对象，就像前面分析讲解的几类场景中，可能我们通过使用对象的克隆，比通过其他几类的创建型模式，效果要好的多，而且代价也小很多。 打个比方，原型模式对于系统的扩展，可以做到无缝的扩展，为什么这么说呢？比如其他的创建型工厂，如果新增一个对象类型，那么我们不管是修改配置文件的方式，还是修改代码的形式，无疑我们都是需要进行修改的，对于我们大家通用的公共应用来说这无疑是危险的，那么通过原型模式，则可以解决这样的问题，因为类型本身实现这样的方法即可，但是也有一定的缺点，每个对象都实现这样的方法，无疑是很大的工作量，但是在某些特殊的环境下，或者实际的项目中，可能原型模式是好的选择。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（四）建造者模式（Builder）]]></title>
    <url>%2F2017%2F09%2F09%2FdesignPattern%2Fbuilder%2F</url>
    <content type="text"><![CDATA[介绍工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。 还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。 建造者类: 1234567891011121314public class Builder &#123; private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;(); public void produceMailSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new MailSender()); &#125; &#125; public void produceSmsSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new SmsSender()); &#125; &#125; &#125; 测试类： 123456public class Test &#123; public static void main(String[] args) &#123; Builder builder = new Builder(); builder.produceMailSender(10); &#125; &#125; 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。 扩展1. 使用场景无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发送机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 意图：将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 2. 模式定义 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。建造者模式又可以称为生成器模式。 3. 模式结构 建造者模式包含如下角色： Builder：抽象建造者 给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。 ConcreteBuilder：具体建造者 实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例。 Director：指挥者 调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 Product：产品角色 要创建的复杂对象。 4. 模式代码示例具体的产品Product： 1234567891011121314151617181920212223242526272829303132public class Product &#123; private String basic;//地基 private String wall;//墙 private String roofed;//楼顶 public String getBasic() &#123; return basic; &#125; public void setBasic(String basic) &#123; this.basic = basic; &#125; public String getWall() &#123; return wall; &#125; public void setWall(String wall) &#123; this.wall = wall; &#125; public String getRoofed() &#123; return roofed; &#125; public void setRoofed(String roofed) &#123; this.roofed = roofed; &#125; &#125; 抽象建造者类： 1234567891011121314151617181920212223public interface Builder &#123; /** * 打基础 */ public void buildBasic(); /** * 砌墙 */ public void buildWalls(); /** * 封顶 */ public void roofed(); /** * 造房子 * @return */ public Product buildProduct();&#125; 指挥者类： 123456789public class Director &#123; public Product constructProduct(ConcreteBuilder concreteBuilder)&#123; concreteBuilder.buildBasic(); concreteBuilder.buildWalls(); concreteBuilder.roofed(); return concreteBuilder.buildProduct(); &#125;&#125; 具体建造者类： 123456789101112131415161718192021222324252627public class ConcreteBuilder implements Builder&#123; private Product product; public ConcreteBuilder()&#123; product=new Product(); &#125; @Override public void buildBasic() &#123; product.setBasic("打好基础"); &#125; @Override public void buildWalls() &#123; product.setWall("砌墙"); &#125; @Override public void roofed() &#123; product.setRoofed("封顶大吉"); &#125; @Override public Product buildProduct() &#123; return product; &#125;&#125; 测试类： 1234567public class Test&#123; public static void main(String[] args)&#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); Product product = director.constructProduct(); &#125;&#125; 5. 模式应用1. StringBuffer6. 适用范围 需要生成的产品对象有复杂的内部结构。 需要生成的产品对象的属性相互依赖，建造者模式可以强迫生成顺序。 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到。 7. 效果 建造者模式的使用时的产品的内部表象可以独立的变化。使用建造者模式可以使客户端不必知道产品内部组成的细节。 每一个Builder都相对独立，而与其他的Builder无关。 模式所建造的最终产品易于控制。 模式优缺点1. 优点 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 2. 缺点 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大 与抽象工厂模式比较 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。 举例下面我们来看一下经典创建者模式的一个实现形式，这里以上面讲述的服装的过程作为例子来说明下创建者模式的原理和思想 具体产品类： 12345678910111213public class Product &#123; ArrayList&lt;String&gt; parts = new ArrayList&lt;String&gt;(); public void add(String part)&#123; parts.add(part); &#125; public void show()&#123; System.out.println("产品创建------------"); for(String part : parts)&#123; System.out.println(part); &#125; &#125;&#125; 抽象建造者类： 12345public abstract class Builder &#123; public abstract void BuildPartA(); public abstract void BuildPartB(); public abstract Product getResult();&#125; 具体建造者类： 12345678910111213141516171819202122232425262728293031323334353637//具体建造者类1public class ConcreteBuilder1 extends Builder&#123; private Product product = new Product(); @Override public void BuildPartA() &#123; product.add("部件A"); &#125; @Override public void BuildPartB() &#123; product.add("部件B"); &#125; @Override public Product getResult() &#123; return product; &#125;&#125;//具体建造者类2public class ConcreteBuilder2 extends Builder&#123; private Product product = new Product(); @Override public void BuildPartA() &#123; product.add("部件x"); &#125; @Override public void BuildPartB() &#123; product.add("部件y"); &#125; @Override public Product getResult() &#123; return product; &#125;&#125; 指挥者类： 123456public class Director &#123; public void Construct(Builder builder)&#123; builder.BuildPartA(); builder.BuildPartB(); &#125;&#125; 测试类： 12345678910111213public class TestBuilder &#123; public static void main(String[] args) &#123; Director director = new Director(); Builder b1 = new ConcreteBuilder1(); Builder b2 = new ConcreteBuilder2(); director.Construct(b1); Product p1 = b1.getResult(); p1.show(); director.Construct(b2); Product p2 = b2.getResult(); p2.show(); &#125;&#125; 上面的代码给出了经典创建者模式的核心代码形式，那么针对上面无疑有以下的几个缺点： IBuilder接口必须定义完整的组装流程，一旦定义就不能随意的动态修改。 Builder与具体的对象之间有一定的依赖关系，当然这里可以通过接口来解耦来实现灵活性。 Builder必须知道具体的流程。 针对上面的几个问题，通过配置文件或者其他的形式来提供灵活性。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（三）单例模式（Singleton）]]></title>
    <url>%2F2017%2F09%2F09%2FdesignPattern%2Fsingleton%2F</url>
    <content type="text"><![CDATA[介绍单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在，而且自行实例化并向整个系统提供这个实例。这样的模式有几个好处： 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 在单例模式的实现过程中，需要注意如下三点： 单例类的构造函数为私有 提供一个自身的静态私有成员变量 提供一个公有的静态工厂方法 非线程安全单例123456789101112131415161718192021public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return instance; &#125; &#125; 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了。如何解决？ 首先会想到对getInstance方法加synchronized关键字，如下： 123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进： 12345678910public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (instance) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 这样似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例： A、B线程同时进入了第一个if判断 A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton() 由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块 B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序 此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了 所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化： 123456private static class SingletonFactory&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonFactory.instance; &#125; 实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题： 1234567891011121314151617181920public class Singleton &#123; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; /* 获取实例 */ public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return getInstance(); &#125; &#125; 如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的： 12345678910111213141516171819public class SingletonTest &#123; private static SingletonTest instance = null; private SingletonTest() &#123; &#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125; &#125; 考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响 总结：synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁） 影子实例采用影子实例的办法为单例对象的属性同步更新： 1234567891011121314151617181920212223242526272829public class SingletonTest &#123; private static SingletonTest instance = null; private Vector properties = null; public Vector getProperties() &#123; return properties; &#125; private SingletonTest() &#123; &#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125; public void updateProperties() &#123; SingletonTest shadow = new SingletonTest(); properties = shadow.getProperties(); &#125; &#125; 静态类与单例类采用类的静态方法，实现单例模式的效果，也是可行的，二者有什么不同？ 首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的） 其次，单例可以被延迟初始化，静态类一般在第一次加载时初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能 再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写 最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样 懒汉模式12345678910111213public class Singleton&#123; private static Singleton instance=null; //静态私有成员变量 //私有构造函数 private Singleton()&#123; &#125; //静态公有工厂方法，返回唯一实例 public static Singleton getInstance()&#123; if(instance==null) instance=new Singleton(); return instance; &#125;&#125; 饿汉模式1234567891011public class Singleton&#123; private static Singleton instance=new Singleton() ; //静态私有成员变量 //私有构造函数 private Singleton()&#123; &#125; //静态公有工厂方法，返回唯一实例 public static Singleton getInstance()&#123; return instance; &#125;&#125; 枚举类型模式123456public enum Sinleton &#123; INSTANCE; public void doSomething() &#123; System.out.println("enum Singleton"); &#125;&#125; 测试类： 12345public class Test&#123; public static void main(String[] args)&#123; Sinleton.INSTANCE.doSomething(); &#125;&#125; 单例模式应用123456789public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); private Runtime() &#123; &#125; public static Runtime getRuntime() &#123; return currentRuntime; &#125;&#125; 适用场景 需要频繁实例化然后销毁的对象。 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 有状态的工具类对象。 频繁访问数据库或文件的对象。 以及其他我没用过的所有要求只有一个对象的场景。 单例模式的优缺点 优点 在内存中只有一个对象，节省内存空间。 避免频繁的创建销毁对象，可以提高性能。 避免对共享资源的多重占用。 可以全局访问。 缺点 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。 注意事项 只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。 不要做断开单例类对象与类中静态引用的危险操作。 多线程使用单例使用共享资源时，注意线程安全问题。 思考 单例模式的对象长时间不用会被jvm垃圾收集器收集吗 看到不少资料中说：如果一个单例对象在内存中长久不用，会被jvm认为是一个垃圾，在执行垃圾收集的时候会被清理掉。对此这个说法，网上一个观点是：在hotspot虚拟机1.6版本中，除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。 在一个jvm中会出现多个单例吗 在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。代码如下 1234Class c = Class.forName(Singleton.class.getName());Constructor ct = c.getDeclaredConstructor();ct.setAccessible(true);Singleton singleton = (Singleton)ct.newInstance(); 这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。 懒汉式单例线程安全吗 主要是网上的一些说法，懒汉式的单例模式是线程不安全的，即使是在实例化对象的方法上加synchronized关键字，也依然是危险的。但事实加synchronized关键字修饰后，虽然对性能有部分影响，但是却是线程安全的，并不会产生实例化多个对象的情况。 单例模式只有饿汉式和懒汉式两种吗 饿汉式单例和懒汉式单例只是两种比较主流和常用的单例模式方法，从理论上讲，任何可以实现一个类只有一个实例的设计模式，都可以称为单例模式。 单例类可以被继承吗 饿汉式单例和懒汉式单例由于构造方法是private的，所以他们都是不可继承的，但是其他很多单例模式是可以继承的，例如登记式单例。 饿汉式单例好还是懒汉式单例好 在java中，饿汉式单例要优于懒汉式单例。C++中则一般使用懒汉式单例。]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（二）抽象工厂模式（Abstract Factory）]]></title>
    <url>%2F2017%2F09%2F08%2FdesignPattern%2FabstractFactory%2F</url>
    <content type="text"><![CDATA[介绍工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则 抽象工厂模式 创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码.提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类 抽象工厂模式的结构： 抽象工厂（Abstract Factory）角色 具体工厂（Concrete Factory）角色 抽象产品（Abstract Product）角色 具体产品（Concrete Product）角色 同样一个发短信或发邮件的例子： 关系图： 接口： 123public interface Sender &#123; public void Send(); &#125; 实现类： 123456public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is mailsender!"); &#125; &#125; 123456public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is sms sender!"); &#125; &#125; 工厂类实现的接口： 123public interface Provider &#123; public Sender produce(); &#125; 工厂类：一个实现对应一个工厂 123456public class SendMailFactory implements Provider &#123; @Override public Sender produce()&#123; return new MailSender(); &#125; &#125; 123456public class SendSmsFactory implements Provider&#123; @Override public Sender produce() &#123; return new SmsSender(); &#125; &#125; 测试类： 12345678public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); &#125; &#125; //输出：this is mailsender! 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好 模式扩展上面的例子就是抽象工厂模式的退化 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式 下面看一个多产品的抽象工厂 抽象类： 1234public abstract class AbstractFactory&#123; public abstract MailSender mailSend(); public abstract SmsSender smsSend();&#125; 工厂类： 1234567891011//工厂1同时存在产品A和产品Bpublic class ConcreteFactory1 extends AbstractFactory&#123; public MailSender mailSend()&#123; return new MailSender(); &#125; public SmsSender smsSend()&#123; return new SmsSender(); &#125; &#125;//工厂2同时也可以存在产品A和产品B 实现类继承的抽象类： 123public abstract class Sender&#123; public abstract void send();&#125; 实现类： 123456public class MailSender extends Sender &#123; @Override public void Send() &#123; System.out.println("this is mailsender!"); &#125; &#125; 123456public class SmsSender extends Sender &#123; @Override public void Send() &#123; System.out.println("this is sms sender!"); &#125; &#125; 测试类： 1234567891011public class Test &#123; public static void main(String[] args) &#123; ConcreteFactory1 concreteFactory1 = new ConcreteFactory1(); MailSender mailSend = concreteFactory1.mailSend(); SmsSender smsSend = concreteFactory1.smsSend(); mailSend.Send(); smsSend.Send(); &#125; &#125; //输出：this is mailsender!//输出：this is sms sender! 模式应用待深入理解 Iterator与ListIterator，前者只能向后移动，后者前后移动，两种迭代器产品 List是抽象工厂的角色，它有两个制造产品的方法，iterator和listIterator，相当于Creator ListIterator和Iterator都是抽象产品，相当于ProductA和ProductB。其中ListIterator有两个实现类，分别是AbstractList.ListItr和LinkedList.ListItr，相当于ProductA1和ProductA2。Iterator的实现类为AbstractList.Itr，相当于ProductB1，但是没有B2 LinkedList是其中一个具体的工厂类，相当于ConcreteCreator1，实现抽象工厂List，它制造的两个具体产品分别是LinkedList.ListItr和AbstractList.ListItr 同样的，ArrayList也是一个具体的工厂类，相当于ConcreteCreator2，实现抽象工厂List，它制造的两个具体产品分别是AbstractList.ListItr和AbstractList.Itr Iterable接口是List的父接口，所以它只负责一个产品Iterator的制造，所以是工厂方法模式，而List接口扩展了Iterable接口，又添加了一个制造产品的方法，即又添加了一个系列的产品，所以就成为了抽象工厂模式 ArrayList和LinkedList分别是List接口的两种实现，前者是基于数组操作，后者是基于链表。两者都可以产生Iterator和ListIterator而Iterator的实现都是在AbstractList中实现的，而对于ListIterator的实现却不相同，AbstractList.ListItr是基于数组的操作，LinkedList.ListItr是基于链表的操作方式 模式优缺点 优点 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式 增加新的具体工厂和产品族很方便，无须修改已有系统，符合开闭原则 缺点 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦） 抽象工厂模式使用场景 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。 这个系统有多于一个的产品族，而系统只消费其中某一产品族。 同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。 抽象工厂模式与工厂方法模式区别 工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。 当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 举例生产餐具和相应食物的工厂，有两个车间，其中一个车间用以生产餐具，一个车间用以生产相应的食物。当消费者消费时，只需要向相应的具体工厂请求具体餐具和具体食物便可以使用餐具消费食物。 在本例子中有3个具体工厂AKitchen， BKitchen， CKitchen，分别生产牛奶和汤匙、面包和刀、肉和叉子。牛奶、面包和肉都实现了食物接口。汤匙、刀和叉子都实现了餐具接口 抽象工厂和具体工厂： 抽象餐具与具体餐具： 抽象食物与具体食物： 抽象工厂的接口： 1234public interface KitchenFactory&#123; public Food getFood(); public TableWare getTableWare();&#125; 抽象餐具的接口： 123public interface TableWare&#123; public String getTool();&#125; 抽象食物的接口： 123public interface Food&#123; public String getEatable();&#125; 具体工厂：以AKitchen为例 123456789public class AKitchen implements KitchenFactory&#123; public Food getFood()&#123; return new Milk(); &#125; public TableWare getTableWare()&#123; return new Spoon(); &#125;&#125; 具体餐具：以spoon为例 12345public class Spoonimplements TableWare&#123; public String getTool() &#123; return "spoon"; &#125;&#125; 具体食物：以milk为例 12345public class Milkimplements Food&#123; public String getEatable()&#123; return "milk"; &#125;&#125; 测试代码： 12345678910111213141516public class Client&#123; public void eat(KitchenFactory k)&#123; System.out.println("A person eat "+k.getFood().getEatable() +" with "+k.getTableWare().getTool()+"!"); &#125; public static void main(String[] args)&#123; Client client=new Client(); KitchenFactory kf =new AKitchen(); client.eat(kf); kf=new BKitchen(); client.eat(kf); kf=new CKitchen(); client.eat(kf); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java设计模式（一）工厂方法模式（Factory Model）]]></title>
    <url>%2F2017%2F09%2F07%2FdesignPattern%2FfactoryModel%2F</url>
    <content type="text"><![CDATA[工厂方法模式分类工厂方法模式分为四种： 简单工厂模式 多个工厂方法模式 静态工厂方法模式 工厂方法模式 其中前三种都属于简单工厂模式，又叫做静态工厂方法模式，但不属于23种GOF设计模式之一。 一、简单工厂模式 简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 简单工厂模式存在三个组成部分： 工厂角色 在简单工厂模式中，工厂类是一个具体的实现类，在系统设计中工厂类负责实际对象的创建工作。 工厂类（Factory）的特点是：它知道系统中都存在哪些能够创建对象的具体类（ConcreteProduct），也知道该如何将创建的对象，以某种能够屏蔽具体类实现细节的方式（AbstractProduct）提供给所需要的其他角色来使用该对象提供的数据和服务。 抽象产品角色 抽象产品角色是具体的产品的抽象。抽象就是将产品的共性抽取出来，可以直接暴露给客户端（需要使用具体产品的角色）。 抽象产品角色，在实际系统中可以定义为接口或者抽象类。 具体产品角色 具体产品实现类一定是抽象产品类的实现或扩展。 举例：一个发送邮件和短信的例子 关系图： 二者的共同接口： 123public interface Sender &#123; public void Send(); &#125; 实现类： 123456public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is mailsender!"); &#125; &#125; 123456public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is sms sender!"); &#125; &#125; 工厂类： 123456789101112public class SendFactory &#123; public Sender produce(String type) &#123; if ("mail".equals(type)) &#123; return new MailSender(); &#125; else if ("sms".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("请输入正确的类型!"); return null; &#125; &#125; &#125; 测试类： 12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce("sms"); sender.Send(); &#125; &#125; //输出：this is sms sender! 二、多个工厂方法模式 多个工厂方法模式是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象 关系图： 工厂类： 123456789public class SendFactory &#123; public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 测试类： 12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); &#125; &#125; //输出：this is mailsender! 三、静态工厂方法模式 静态工厂方法模式将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可 工厂类： 123456789public class SendFactory &#123; public static Sender produceMail()&#123; return new MailSender(); &#125; public static Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 测试类： 1234567public class FactoryTest &#123; public static void main(String[] args) &#123; Sender sender = SendFactory.produceMail(); sender.Send(); &#125; &#125; //输出：this is mailsender! 模式应用：以上三种称为简单工厂模式 12345//在JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间//简单工厂特例，工厂角色与抽象产品角色合并为一个类，DateFormatpublic final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style,Locale locale); 模式优缺点： 优点 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易 在调用工厂类的工厂方法时，由于工厂方法是静态方法，可通过类名直接调用，而且只需要传入一个简单的参数即可 在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何Java源代码 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节 缺点 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的 在简单工厂模式中，只提供了一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了开闭原则 在简单工厂模式中，所有的产品都是由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性。而多态工厂类模式可以很好地解决这一问题 四、工厂方法模式 工厂方法模式又称多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 工厂方法模式的结构： 抽象工厂(Creator)角色 是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂(Concrete Creator)角色 这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。 抽象产品(Product)角色 工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品(Concrete Product)角色 这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。 抽象工厂类： 123public abstract class SendFactory&#123; public abstract AbstractSend getSendMethod();&#125; 具体工厂子类： 12345678910111213//邮件工厂public class MailSendFactory extends SendFactory&#123; public AbstractSend getSendMethod()&#123; return new MailSender(); &#125;&#125; //短信工厂public class SmsSendFactory extends SendFactory&#123; public AbstractSend getSendMethod()&#123; return new SmsSender(); &#125;&#125; 实现类： 12345678910111213//邮件实现类public class MailSender &#123; public void Send() &#123; System.out.println("this is mailsender!"); &#125; &#125; //短信实现类public class SmsSender &#123; public void Send() &#123; System.out.println("this is sms sender!"); &#125; &#125; 测试类： 12345678910public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory; AbstractSend sendMethod; factory=new MailSendFactory(); sendMethod =factory.getSendMethod(); sendMethod.send(); &#125; &#125; //输出：this is mailsender! 很明显可以看到，SendFactory工厂类变成了SendFactory抽象类，而继承此抽象类的分别是MailSendFactory和SmsSendFactory等等具体的工厂类。这样做有什么好处呢？很明显，这样做就完全OCP了。如果需要再加入（或扩展）产品类（比如加多个“发微信”）的话就不再需要修改工厂类了，而只需相应的再添加一个继承了工厂抽象类的具体工厂类即可。 模式应用： 1234//JDBC中的工厂方法(没有多个具体工厂，特例)Connection conn=DriverManager.getConnection("jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=");Statement statement=conn.createStatement();ResultSet rs=statement.executeQuery("select * from UserInfo"); 模式优缺点： 优点： 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合开闭原则 缺点： 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度 总结总体来说，工厂方法模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。 在简单工厂模式的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2017%2F09%2F03%2FdesignPattern%2FdesignPattern00%2F</url>
    <content type="text"><![CDATA[设计模式原文：Java之美[从菜鸟到高手演变]之设计模式 参考：Java开发中的23种设计模式详解 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式间关系： 一、设计模式分类1. 创建型模式创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则 创建型模式主要用于创建对象。共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。其中工厂方法模式称为类模式，其它称为对象模式 2. 结构型模式结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构 结构型模式主要用于处理类或对象的组合。共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中（类）适配器模式称为类模式，其它称为对象模式 3. 行为型模式行为型模式分为类行为型模式和对象行为型模式两种: 类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。 行为型模式(behavioral pattern)主要用于描述对类或对象怎样交互和怎样分配职责。共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 其中解释器模式 和模板方法模式称为类模式，其它称为对象模式 其实还有两类：并发型模式和线程池模式 二、设计模式六大原则1. 开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类 2. 里氏代换原则（Liskov Substitution Principle）里氏代换原则面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：子类型必须能够替换掉它们的父类型。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 里氏代换原则是对开-闭原则的补充。实现开-闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3. 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体 定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程 依赖倒转其实就是谁也不要依靠谁，除了约定的接口，大家都可以灵活自如。依赖倒转可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。如果设计的各个部件或类相互依赖，这样就是耦合度高，难以维护和扩展，这也就体现不出面向对象的好处了。 4. 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 接口隔离原则和单一职责原则 单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建 5. 迪米特法则（Demeter Principle）最少知道原则：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 迪米特法则其根本思想，是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。 6. 合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承关系达到复用的目的。 该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。其实这里最终要的地方就是区分“has-a”和“is-a”的区别。相对于合成和聚合，继承的缺点在于：父类的方法全部暴露给子类。父类如果发生变化，子类也得发生变化。聚合的复用的时候就对另外的类依赖的比较的少。合成/聚合复用 优点： 新对象存取成分对象的唯一方法是通过成分对象的接口； 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的； 这种复用支持包装； 这种复用所需的依赖较少； 每一个新的类可以将焦点集中在一个任务上； 这种复用可以在运行时动态进行，新对象可以使用合成/聚合关系将新的责任委派到合适的对象。 缺点： 通过这种方式复用建造的系统会有较多的对象需要管理。 继承复用 优点： 新的实现较为容易，因为基类的大部分功能可以通过继承关系自动进入派生类； 修改或扩展继承而来的实现较为容易。 缺点： 继承复用破坏包装，因为继承将基类的实现细节暴露给派生类，这种复用也称为白箱复用； 如果基类的实现发生改变，那么派生类的实现也不得不发生改变； 从基类继承而来的实现是静态的，不可能在运行时发生改变，不够灵活。 7. 单一职责原则（Single Responsibility Principle）定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责，应该仅有一个引起它变化的原因 虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。 遵循单一职责原的优点有： 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。 三、设计模式优点 设计模式使人们可以更加简单方便地复用成功的设计和体系结构，将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。设计模式使得重用成功的设计更加容易，并避免那些导致不可重用的设计方案 设计模式使得设计方案更加灵活，且易于修改。 设计模式的使用将提高软件系统的开发效率和软件质量，且在一定程度上节约设计成本。 设计模式有助于我们更深入地理解面向对象思想，一方面可以帮助初学者更加方便地阅读和学习现有类库与其他系统中的源代码，另一方面还可以提高软件的设计水平和代码质量]]></content>
      <categories>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL查询]]></title>
    <url>%2F2017%2F09%2F01%2FdataBase%2Fsqlselect%2F</url>
    <content type="text"><![CDATA[SQL查询针对常用的SQL查询总结一下 一、检索 distinct过滤相同的列 1SQL&gt; select distinct column_name from products;--唯一性，distinct作用于所有列 限制结果 SQL Server和Access 1SQL&gt; select top 5 column_name from products;--检索前五行 DB2 12SQL&gt; select column_name from products fetch first 5 rows only;--检索前五行 Oracle 12SQL&gt; select column_name from products where rownum &lt;= 5;--检索前五行 MySQL、MariaDB、PostgreSQL、SQLite 12SQL&gt; select column_name from products limit 5;--检索前五行 12SQL&gt; select column_name from products limit 5 offset 5;--检索从第五行起的五行数据 排序数据 1234--按列名排SQL&gt; select prod_id,prod_price,prod_name from products order by prod_price,prod_name;--order by通常位于子句的最后 1234--按位置排SQL&gt; select prod_id,prod_price,prod_name from products order by 2,3; 1234--降序SQL&gt; select prod_id,prod_price,prod_name from products order by prod_price desc,prod_name;--prod_name默认是升序 二、过滤 where子句过滤 1234SQL&gt; select prod_id,prod_price,prod_name from products where prod_price between 5 and 10;--&gt;、&lt;、=、is null、&lt;&gt;、!=--Microsoft Access 支持&lt;&gt;，不支持!= 求值顺序 1234SQL&gt; select prod_id,prod_price,prod_name from products where prod_id = &apos;as&apos; or prod_id = &apos;bs&apos; and prod_price &gt; 10;--and 优先于 or in和not 123SQL&gt; select prod_id,prod_price,prod_name from products where prod_id in(&apos;as&apos;,&apos;bs&apos;) ;--in同or 123SQL&gt; select prod_id,prod_price,prod_name from products where not prod_id = &apos;as&apos;;--否定后面的条件 三、通配符123456789--%,匹配多个SQL&gt; select prod_name from products where prod_name like &apos;F%Y&apos;;--Microsoft Access使用的是*而不是%--_匹配单个SQL&gt; select prod_name from products where prod_name like &apos;F_Y&apos;;--[]匹配方括号内任意一个字符SQL&gt; select prod_name from products where prod_name like &apos;[JM]%&apos;;--以J或M开头 四、计算字段 拼接字段 123456--+或者||SQL&gt; select rtrim(vend_name) + &apos;(&apos; + rtrim(vend_country) + &apos;)&apos; from vendors order by vend_name;--Assess和SQL Server使用+,DB2、Oracle、postgresql、sqlite、open office base使用||--rtrim、ltrim、trim去掉空格 使用别名 123SQL&gt; select rtrim(vend_name) + &apos;(&apos; + rtrim(vend_country) + &apos;)&apos; as vend_title from vendors MySQL和MariaDB使用的语句： 123SQL&gt; select concat(rtrim(vend_name) + &apos;(&apos; + rtrim(vend_country) + &apos;)&apos;) as vend_title from vendors 算术运算 123SQL&gt; select prod_id,quantity,price, quantity*price as expanded from orderItems; 五、函数 DBMS函数的差异 提取字符串的组成部分 Assess使用mid() DB2、Oracle、postgresql、sqlite使用substr() MySQL和SQL Server使用substring() 数据类型转换 Assess和Oracle，每种类型都要转换函数 DB2和postgresql使用cast() MariaDB、MySQL和SQL Server使用convert() 取当前时间 Assess使用now() DB2和postgresql使用current_date MariaDB和MySQL使用curdate() Oracle使用SYSDATE SQL Server使用getdate() SQLite使用date() soundex soundex是一个将任何文本串转换为描述其语音表示的字母模式的算法 12345--匹配发音类似Mochael green的人员SQL&gt; select cust_name,cust_contact from customers where soundex(cust_contact) = soundex(&apos;Mochael green&apos;);--Assess和postgresql不支持soundex 日期和时间 检索2017年的所有订单 1234567891011121314151617181920212223--SQL ServerSQL&gt; select order_num from orders where datepart(yy,order_date) = 2017;--AccessSQL&gt; select order_num from orders where datepart(&apos;yyyy&apos;,order_date) = 2017;--postgresqlSQL&gt; select order_num from orders where date_part(&apos;year&apos;,order_date) = 2017;--OracleSQL&gt; select order_num from orders where to_number(to_char(order_date,&apos;YYYY&apos;)) = 2017;--MariaDB和MySQLSQL&gt; select order_num from orders where year(order_date) = 2017;--SQLite小技巧SQL&gt; select order_num from orders where strftime(&apos;%Y&apos;,order_date) = &apos;2017&apos;; 六、汇总 平均值 1234SQL&gt; select avg(prod_price) as avg_price from products;--avg用于单列，并忽略null值的行SQL&gt; select max(prod_price) as avg_price from products;SQL&gt; select min(prod_price) as avg_price from products; 计数 1SQL&gt; select count(*) as num_cust from customers;--对所有行计数 汇总 12SQL&gt; select sum(price*quantity) as total from orderItems; 七、分组 创建分组 123SQL&gt; select vend_id,count(*) as num_prods from products group by vend_id; --group by 2,1-先按第二列分组，再按第一列分 having过滤 1234567--where可以用having代替，where过滤行，having过滤组--having结合group by使用SQL&gt; select vend_id,count(*) as num_prods from products where vend_price &gt;= 4 group by vend_id having count(*) &gt;= 2; 排序 1234567SQL&gt; select vend_id,vend_num,count(*) as num_prods from products where vend_price &gt;= 4 group by vend_id having count(*) &gt;= 2 order by vend_id,vend_num;--Access不允许按别名排序 八、子查询 子查询 12345678910111213SQL&gt; select cust_name,cust_contact from customers where cust_id in( select cust_id from orders where order_num in( select order_num from orderitems where prod_id = &apos;RGAN01&apos; ) ); 子查询作为计算字段 123456SQL&gt; select cust_name,cust_state, (select count(*) from orders where orders.cust_id = customers.cust_id) as ordernum from customers order by cust_name; 九、联结表 创建联结 123SQL&gt; select vend_name,prod_name,prod_price from vendors,products where vendors.vend_id = products.vend_id; 子查询与多表联结 123456--多表联结实现上面的子查询SQL&gt; select cust_name,cust_contact from customers,orders,orderitems where customers.cust_id = orders.cust_id and orders.order_num = orderitems.order_num and prod_id = &apos;RGAN01&apos;; 使用表别名 1234SQL&gt; select vend_name,prod_name,prod_price from vendors as v,products as p where v.vend_id = p.vend_id;--oracle中没有as ,直接vendors v 更多表联结参考 十、组合查询12345678910SQL&gt; select cust_name,cust_contact from customers where cust_state in(&apos;ax&apos;,&apos;as&apos;,&apos;sd&apos;) union select cust_name,cust_contact from customers where cust_name = &apos;FUNALL&apos; order by cust_name,cust_contact;--union-取消重复的行，union all不取消重复的行--组合查询只能有一个order by 十一、表复制123456SQL&gt; select * into custcopy from customers;--DB2不支持select into--MariaDB、MySQL、Oracle、postgresql、sqliteSQL&gt; create table custcopy as select * from customers;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引基本概念]]></title>
    <url>%2F2017%2F08%2F29%2FdataBase%2Findex%2F</url>
    <content type="text"><![CDATA[索引索引用来排序数据以加快搜索和排序操作的速度。使用索引，可以在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表。在定义了索引后，DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行。 创建索引语法： 1234SQL&gt; create [unique][clustered|nonclustered]index index_name --索引名必须唯一 on &#123;table_name|view_name&#125;[with [index_property]];--on指定被索引的表，括号中指明索引包含的列--例：建立唯一索引SQL&gt; create unique index emp_email on employees(email) tablespace users; 说明：unique：建立唯一索引，clustered：建立聚集索引，nonclustered：建立非聚集索引，index_property：索引属性。unique索引既可以采用聚集索引结构，也可以采用非聚集索引的结构。 删除索引语法： 1SQL&gt; drop index table_name.index_name[,table_name.index_name]--索引所在的表名称.索引名称 显示索引信息： 12345678910111213141516--oracle用user_indexes和user_ind_columns系统表查看已经存在的索引--user_indexes: 系统视图存放是索引的名称以及该索引是否是唯一索引等信息。--user_ind_column: 系统视图存放的是索引名称，对应的表和列等。--查看索引个数和类别:SQL&gt; select * from user_indexes where table=&apos;表名&apos;;--查看索引被索引的字段:SQL&gt; select * from user_ind_columns where index_name=upper(&apos;&amp;index_name&apos;);--通过类似下面的语句来查看一个表的索引的基本情况：SQL&gt; select user_ind_columns.index_name,user_ind_columns.column_name, user_ind_columns.column_position,user_indexes.uniqueness from user_ind_columns,user_indexes where user_ind_columns.index_name = user_indexes.index_name and user_ind_columns.table_name = &apos;你想要查询的表名字&apos;;--SQL Server使用系统存储过程：sp_helpindex 查看指定表的索引信息。SQL&gt; Exec sp_helpindex book1; 一、 索引的类型 唯一索引：唯一索引不允许两行具有相同的索引值 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空 聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个 非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个 举例： 图书馆对图书的管理建立一个以字母开头的目录，例如：a开头的书，在第一排，b开头的在第二排，这样在找什么书就好说了，这个就是一个聚集索引。很多人借书找某某作者的，不知道书名怎么办？图书管理员在写一个目录，某某作者的书分别在第几排，第几排，这就是一个非聚集索引。 字典前面的目录，可以按照拼音和部首去查询，我们想查询一个字，只需要根据拼音或者部首去查询，就可以快速的定位到这个汉字了，这个就是索引的好处，拼音查询法就是聚集索引，部首查询就是一个非聚集索引。 二、索引的存储机制首先，无索引的表，查询时，是按照顺序存续的方法扫描每个记录来查找符合条件的记录，这样效率十分低下。 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致，其实理解起来非常简单，还是举字典的例子：如果按照拼音查询，那么都是从a-z的，是具有连续性的，a后面就是b，b后面就是c， 聚集索引就是这样的，他是和表的物理排列顺序是一样的，例如有id为聚集索引，那么1后面肯定是2，2后面肯定是3，所以说这样的搜索顺序的就是聚集索引。非聚集索引就和按照部首查询是一样是，可能按照偏房查询的时候，根据偏旁‘弓’字旁，索引出两个汉字，张和弘，但是这两个其实一个在100页，一个在1000页，（这里只是举个例子），他们的索引顺序和数据库表的排列顺序是不一样的，这个样的就是非聚集索引。 所以他们的存储机制是这样的：聚集索引就是在数据库被开辟一个物理空间存放他的排列的值，例如1-100，所以当插入数据时，他会重新排列整个整个物理空间，而非聚集索引其实可以看作是一个含有聚集索引的表，他只仅包含原表中非聚集索引的列和指向实际物理表的指针。他只记录一个指针，其实就有点和堆栈差不多的感觉了。 三、索引建立原则 动作描述 使用聚集索引 使用非聚集索引 外键列 应 应 主键列 应 应 列经常被分组排序（order by） 应 应 返回某范围内的数据 应 不应 小数目的不同值 应 不应 大数目的不同值 不应 应 频繁更新的列 不应 应 频繁修改索引列 不应 应 一个或极少不同值 不应 不应 定义主键的数据列一定要建立索引；定义有外键的数据列一定要建立索引。 对于经常查询的数据列最好建立索引。 对于需要在指定范围内的快速或频繁查询的数据列。 经常用在WHERE子句中的数据列。 经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。 对于定义为text、image和bit的数据类型的列不要建立索引。 对于经常存取的列避免建立索引 。 限制表上的索引数目。对一个存在大量更新操作的表，所建索引的数目一般不要超过3个，最多不要超过5个。索引虽说提高了访问速度，但太多索引会影响数据的更新操作。 对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用,因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。 四、索引的优缺点 优点： 加快访问速度 加强行的唯一性 缺点： 带索引的表在数据库中需要更多的存储空间 操纵数据的命令需要更长的处理时间，因为它们需要对索引进行更新 五、索引注意事项 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引 索引数据需要占用大量的存储空间 索引用于数据过滤和数据排序，如果经常需要以某种特定顺序排序数据，该数据适合做索引 可以在索引中定义多个列（如：州加城市）。这样索引仅在以州加城市的顺序排序时有用 索引的效率随表数据的改变而变化，所以需要定期检查索引，使其性能达到最好 六、索引覆盖假设你在Sales表(SelesID,SalesDate,SalesPersonID,ProductID,Qty)的外键列(ProductID)上创建了一个索引，假设ProductID列是一个高选中性列，那么任何在where子句中使用索引列(ProductID)的select查询都会更快，如果在外键上没有创建索引，将会发生全部扫描，但还有办法可以进一步提升查询性能。假设Sales表有10,000行记录，下面的SQL语句选中400行(总行数的4%)： 1SELECT SalesDate, SalesPersonID FROM Sales WHERE ProductID = 112 我们来看看这条SQL语句在SQL执行引擎中是如何执行的： Sales表在ProductID列上有一个非聚集索引，因此它查找非聚集索引树找出ProductID=112的记录； 包含ProductID = 112记录的索引页也包括所有的聚集索引键(所有的主键键值，即SalesID)； 针对每一个主键(这里是400)，SQL引擎查找聚集索引树找出真实的行在对应页面中的位置； SQL引擎从对应的行查找SalesDate和SalesPersonID列的值。 在上面的步骤中，对ProductID = 112的每个主键记录(这里是400)，SQL引擎要搜索400次聚集索引树以检索查询中指定的其它列(SalesDate，SalesPersonID)。如果非聚集索引页中包括了聚集索引键和其它两列(SalesDate,，SalesPersonID)的值，SQL Server引擎可能不会执行上面的第3和4步，直接从非聚集索引树查找ProductID列速度还会快一些，直接从索引页读取这三列的数值。 幸运的是，有一种方法实现了这个功能，它被称为“覆盖索引”，在表列上创建覆盖索引时，需要指定哪些额外的列值需要和聚集索引键值(主键)一起存储在索引页中。下面是在Sales 表ProductID列上创建覆盖索引的例子： 123CREATE INDEX NCLIX_Sales_ProductID--Index name ON dbo.Sales(ProductID)--Column on which index is to be created INCLUDE(SalesDate, SalesPersonID)--Additional column values to include 应该在那些select查询中常使用到的列上创建覆盖索引，但覆盖索引中包括过多的列也不行，因为覆盖索引列的值是存储在内存中的，这样会消耗过多内存，引发性能下降。 七、索引碎片数据库自身优化) 八、索引实战（摘抄）摘抄地址：如何使你的SQL运行得更快) 人们在使用SQL时往往会陷入一个误区，即太关注于所得的结果是否正确，而忽略了不同的实现方法之间可能存在的性能差异，这种性能差异在大型的或是复杂的数据库环境中（如联机事务处理OLTP或决策支持系统DSS）中表现得尤为明显。而不良的SQL往往来自于不恰当的索引设计、不充份的连接条件和不可优化的where子句。 不合理的索引设计例：表record有620000行，试看在不同的索引下，下面几个 SQL的运行情况： 在date上建有一非聚集索引 123select count(*) from record where date &gt;&apos;19991201&apos; and date &lt; &apos;19991214&apos;and amount &gt;2000 (25秒)select date ,sum(amount) from record group by date(55秒)select count(*) from record where date &gt;&apos;19990901&apos; and place in (&apos;BJ&apos;,&apos;SH&apos;) (27秒) 分析：date上有大量的重复值，在非聚集索引下，数据在物理上随机存放在数据页上，在范围查找时，必须执行一次表扫描才能找到这一范围内的全部行。 在date上建有一聚集索引 123select count(*) from record where date &gt;&apos;19991201&apos; and date &lt; &apos;19991214&apos; and amount &gt;2000 （14秒）select date,sum(amount) from record group by date（28秒）select count(*) from record where date &gt;&apos;19990901&apos; and place in (&apos;BJ&apos;,&apos;SH&apos;)（14秒） 分析：在聚集索引下，数据在物理上按顺序在数据页上，重复值也排列在一起，因而在范围查找时，可以先找到这个范围的起末点，且只在这个范围内扫描数据页，避免了大范围扫描，提高了查询速度。 在place，date，amount上的组合索引 123select count(*) from record where date &gt;&apos;19991201&apos; and date &lt; &apos;19991214&apos; and amount &gt;2000 （26秒）select date,sum(amount) from record group by date（27秒）select count(*) from record where date &gt;&apos;19990901&apos; and place in (&apos;BJ, &apos;SH&apos;)（&lt; 1秒） 分析：这是一个不很合理的组合索引，因为它的前导列是place，第一和第二条SQL没有引用place，因此也没有利用上索引；第三个SQL使用了place，且引用的所有列都包含在组合索引中，形成了索引覆盖，所以它的速度是非常快的。 在date，place，amount上的组合索引 123select count(*) from record where date &gt;&apos;19991201&apos; and date &lt; &apos;19991214&apos; and amount &gt;2000(&lt; 1秒)select date,sum(amount) from record group by date（11秒）select count(*) from record where date &gt;&apos;19990901&apos; and place in (&apos;BJ&apos;,&apos;SH&apos;)（&lt; 1秒） 分析：这是一个合理的组合索引。它将date作为前导列，使每个SQL都可以利用索引，并且在第一和第三个SQL中形成了索引覆盖，因而性能达到了最优。 总结： 缺省情况下建立的索引是非聚集索引，但有时它并不是最佳的；合理的索引设计要建立在对各种查询的分析和预测上。 一般来说： 有大量重复值、且经常有范围查询（between, &gt;,&lt; ，&gt;=,&lt; =）和order by、group by发生的列，可考虑建立聚集索引。 经常同时存取多列，且每列都含有重复值可考虑建立组合索引。 组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。 不充分的连接条件例：表card有7896行，在card_no上有一个非聚集索引，表account有191122行，在account_no上有一个非聚集索引，试看在不同的表连接条件下，两个SQL的执行情况： 123select sum(a.amount) from account a,card b where a.card_no = b.card_no（20秒）select sum(a.amount) from account a,card b where a.card_no = b.card_no and a.account_no=b.account_no（&lt; 1秒） 分析： 在第一个连接条件下，最佳查询方案是将account作外层表，card作内层表，利用card上的索引，其I/O次数可由以下公式估算为：外层表account上的22541页+（外层表account的191122行*内层表card上对应外层表第一行所要查找的3页）=595907次I/O。 在第二个连接条件下，最佳查询方案是将card作外层表，account作内层表，利用account上的索引，其I/O次数可由以下公式估算为：外层表card上的1944页+（外层表card的7896行*内层表account上对应外层表每一行所要查找的4页）= 33528次I/O。 可见，只有充份的连接条件，真正的最佳方案才会被执行。 总结： 多表操作在被实际执行前，查询优化器会根据连接条件，列出几组可能的连接方案并从中找出系统开销最小的最佳方案。连接条件要充份考虑带有索引的表、行数多的表；内外表的选择可由公式：外层表中的匹配行数*内层表中每一次查找的次数确定，乘积最小为最佳方案。 查看执行方案的方法– 用set showplanon，打开showplan选项，就可以看到连接顺序、使用何种索引的信息；想看更详细的信息，需用sa角色执行dbcc(3604,310,302)。（数据库：Sybase11.0.3） 不可优化的where子句 例：下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢： 123select * from record where substring(card_no,1,4)=&apos;5378&apos;(13秒)select * from record where amount/30&lt; 1000（11秒）select * from record where convert(char(10),date,112)=&apos;19991201&apos;（10秒） 分析：where子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引；如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样：你会发现SQL明显快起来！ 123select * from record where card_no like&apos;5378%&apos;（&lt; 1秒）select * from record where amount&lt; 1000*30（&lt; 1秒）select * from record where date= &apos;1999/12/01&apos;（&lt; 1秒） 例：表stuff有200000行，id_no上有非群集索引，请看下面这个SQL： 1select count(*) from stuff where id_no in(&apos;0&apos;,&apos;1&apos;)（23秒） 分析：where条件中的’in’在逻辑上相当于’or’，所以语法分析器会将in (‘0’,’1’)转化为id_no =’0’ or id_no=’1’来执行。 我们期望它会根据每个or子句分别查找，再将结果相加，这样可以利用id_no上的索引； 但实际上（根据showplan）,它却采用了”OR策略”，即先取出满足每个or子句的行，存入临时数据库的工作表中，再建立唯一索引以去掉重复行，最后从这个临时表中计算结果。因此，实际过程没有利用id_no上索引，并且完成时间还要受tempdb数据库性能的影响。 实践证明，表的行数越多，工作表的性能就越差，当stuff有620000行时，执行时间竟达到220秒！还不如将or子句分开： 12select count() from stuff where id_no=&apos;0&apos;select count() from stuff where id_no=&apos;1&apos; 得到两个结果，再作一次加法合算。因为每句都使用了索引，执行时间只有3秒，在620000行下，时间也只有4秒。 或者，用更好的方法，写一个简单的存储过程： 1create proc count_stuff asdeclare @a intdeclare @b intdeclare @c intdeclare @d char(10)beginselect @a=count() from stuff where id_no=&apos;0&apos;select @b=count() from stuff where id_no=&apos;1&apos;endselect @c=@a+@bselect @d=convert(char(10),@c)print @d 直接算出结果，执行时间同上面一样快！ 总结：所谓优化即where子句利用了索引，不可优化即发生了表扫描或额外开销。 任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。 in、or子句常会使用工作表，使索引失效；如果不产生大量重复值，可以考虑把子句拆开；拆开的子句中应该包含索引。 要善于使用存储过程，它使SQL变得更加灵活和高效。 从以上这些例子可以看出，SQL优化的实质就是在结果正确的前提下，用优化器可以识别的语句，充份利用索引，减少表扫描的I/O次数，尽量避免表搜索的发生。其实SQL的性能优化是一个复杂的过程，上述这些只是在应用层次的一种体现，深入研究还会涉及数据库层的资源配置、网络层的流量控制以及操作系统层的总体设计。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Sql优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视图]]></title>
    <url>%2F2017%2F08%2F29%2FdataBase%2Fview%2F</url>
    <content type="text"><![CDATA[视图视图是一张虚拟表，它表示一张表的部分数据或多张表的综合数据，其结构和数据是建立在对表的查询基础上。视图中并不存放数据，视图只包含使用时动态检索数据的查询。存放在视图所引用的原始表（基表）中同一张原始表，根据不同用户的不同需求，可以创建不同的视图。DBMS支持说明： Microsoft Access不支持视图 MySQL从1.5版本开始支持视图 SQLite仅支持只读视图，所以视图可以创建，可以读，但不能修改 一、视图的作用例：检索订购了某种产品的顾客 12345SQL&gt; select cust_name, cust_contact from customers, orders, orderitems where customers.cust_id = orders.cust_id and orderitems.order_num = orders.order_num and prod_id = &apos;rgan01&apos;; 将整个查询包装成一个名为ProductCustomers的虚拟表 123SQL&gt; select cust_name, cust_contact from ProductCustomers where prod_id = &apos;rgan01&apos;; ProductCustomers是一个视图，它不包含任何数据，包含的是一个查询。视图提供了一种封装select语句的层次，可以用来简化数据处理，重新格式化或保护基础数据 二、使用视图的原因 使用视图的原因 重用SQL 简化复杂的SQL操作，方便重用而不必知道其基本的实现细节 使用表的一部分而不是整个表 保护数据，可以授权用户访问表的特定部分权限，而不是整个表的权限 更改数据格式和表示，视图可返回与底层表的表示和格式不同的数据 视图的使用 创建视图后，可以与表基本相同的方式使用视图（添加和更新存在限制） 视图仅仅是用来查看存储在别处数据的一种设施。视图返回的数据是从其他表中检索出来的，在添加或更改这些表的数据时，视图将返回改变过的数据 性能问题 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果在使用中用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会大幅度下降 三、视图的规则和限制一些常用的规则和限制： 视图必须唯一命名 视图可以嵌套，可以利用从其他视图中检索数据查询来构造视图 许多DBMS禁止在视图中使用order by子句 对返回的所有列进行命名，计算字段列需要使用别名 视图不能索引，也不能有关联的触发器或默认值 四、视图的语法使用T-SQL语句创建视图的语法： 123SQL&gt; CREATE VIEW view_nameAS&lt;select语句&gt; 删除视图： 12SQL&gt; drop view view_name;--覆盖（更新）视图，必须先删除再重新创建 1. 利用视图简化复杂的联结创建一个不绑定特点数据的视图： 1234567SQL&gt; create view productCustomers as select cust_name,cust_contact,prod_id from customers,orders,orderItems where customers.cust_id = orders.cust_id and orderItems.order_num = orders.order_num;--联结三个表，返回已订购了任意产品的所有顾客的列表 使用视图：检索订购了RGAN01的顾客 1234SQL&gt; select cust_name,cust_contact from productCustomers where prod_id = &apos;RGAN01&apos;;--利用视图，可一次性编写好基础的SQL，然后根据需要多次调用 2. 用视图重新格式化检索出来的数据在单个组合计算列中返回供应商名和位置： 1234SQL&gt; select rtrim(vend_name) + &apos;(&apos; + rtrim(vend_country) + &apos;)&apos;--+同 ||,MySQL使用concet函数 as vend_title from vendors order by vend_name; 如果经常需要这个格式的结果，可以将这个转成视图： 12345SQL&gt; create view vendorLocations as select rtrim(vend_name) + &apos;(&apos; + rtrim(vend_country) + &apos;)&apos;--+同 ||,MySQL使用concet函数 as vend_title from vendors 利用该视图检索数据： 1SQL&gt; select * from vendorLocations; 3. 用视图过滤数据过滤没有电子邮件地址的顾客： 12345SQL&gt; create view customerEMailList as select cust_id,cust_name,cust_email from Customers where cust_email is not null; 使用该视图过滤： 12SQL&gt; select * from customerEMailList;--视图中的where子句和使用视图检索的where子句会自动组合 4. 用视图与计算字段检索某个订单中的物品，计算每种物品的总价格： 123SQL&gt; select prod_id,quantity,item_price,quantity*item_price as expanded_price from OrderItems where order_num = abc; 转换成视图： 1234SQL&gt; create view orderItemsExpanded as select prod_id,quantity,item_price,quantity*item_price as expanded_price from OrderItems 检索abc的详细内容： 12SQL&gt; select * from orderItemsExpanded where order_num = abc;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务]]></title>
    <url>%2F2017%2F08%2F29%2FdataBase%2Faffair%2F</url>
    <content type="text"><![CDATA[数据库之事务一、事务事务是一组原子操作单元，从数据库角度说，就是一组SQL指令，要么全部执行成功，若因为某个原因其中一条指令执行有错误，则撤销先前执行过的所有指令。要么全部执行成功，要么撤销不执行。例：网上转帐就是典型的要用事务来处理，用以保证数据的一致性 1. ACID原则 原子性（atomicity）：事务执行过程中的任何失败都将导致事务所做的任何修改失效 一致性（consistency）：当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态 隔离性（isolation）：在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见 持久性（durability）：已提交的数据在事务执行失败时，数据的状态都应该正确 2. 数据异常因为Oracle中支持多个事务并发执行，所以会出现下面的数据异常 脏读 当一个事务修改数据时，另一事务读取了该数据，但是第一个事务由于某种原因取消对数据修改，使数据返回了原状态，这是第二个事务读取的数据与数据库中数据不一致，这就叫脏读。如： 事务T1修改了一条数据，但是还未提交，事务T2恰好读取到了这条修改后了的数据，此时T1将事务回滚，这个时候T2读取到的数据就是脏数据。 不可重复读 是指一个事务读取数据库中的数据后，另一个事务则更新了数据，当第一个事务再次读取其中的数据时，就会发现数据已经发生了改变，这就是不可重复读取。不可重复读取所导致的结果就是一个事务前后两次读取的数据不相同。如： 事务T1读取一行记录，紧接着事务T2修改了T1刚刚读取的记录，然后T1再次查询，发现与第一次读取的记录不同。 幻读 如果一个事务基于某个条件读取数据后，另一个事务则更新了同一个表中的数据，这时第一个事务再次读取数据时，根据搜索的条件返回了不同的行，这就是幻读。如： 事务T1读取一条指定where条件的语句，返回结果集。此时事务T2插入一行新记录，恰好满足T1的where条件。然后T1使用相同的条件再次查询，结果集中可以看到T2插入的记录，这条新纪录就是幻读。 事务中遇到的这些异常与事务的隔离性设置有关，事务的隔离性设置越多，异常就出现的越少，但并发效果就越低，事务的隔离性设置越少，异常出现的越多，并发效果越高 3.事务隔离级别针对读取数据时可能产生的不一致现象，在SQL92标准中定义了4个事务的隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted(读未提交) 是 是 是 Read committed（读已提交） 否 是 是 Repeatable read（可重复读） 否 否 是 Serializable（串行读） 否 否 否 oracle事务隔离级别 Oracle默认的隔离级别是read committed Oracle支持上述四种隔离级别中的两种:read committed 和serializable。除此之外，Oralce中还定义Read only和Read write隔离级别 Read only：事务中不能有任何修改数据库中数据的操作语句，是Serializable的一个子集 Read write：它是默认设置，该选项表示在事务中可以有访问语句、修改语句，但不经常使用 设置隔离级别 设置一个事务的隔离级别： 12345SQL&gt; SET TRANSACTION ISOLATION LEVEL READ COMMITTED;SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;SET TRANSACTION READ ONLY;SET TRANSACTION READ WRITE;--这些语句是互斥的，不能同时设置两个或两个以上的选项 设置单个会话的隔离级别： 12SQL&gt; ALTER SESSION SET TRANSACTION ISOLATION LEVEL READ COMMITTED;ALTER SESSION SET TRANSACTION ISOLATION SERIALIZABLE; 4. 管理事务 管理事务 1234SQL&gt; BEGIN TRANSACTION;--开始事务 COMMIT TRANSACTION;--提交事务 ROLLBACK TRANSACTION;--回滚（撤销）事务--一旦事务提交或回滚，则事务结束 判断某条语句执行是否出错 12345/*1.使用全局变量@@ERROR2.@@ERROR只能判断当前一条T-SQL语句执行是否有错，为了判断事务中所有T-SQL语句是否有错，我们需要对错误进行累计*/SQL&gt; SET @errorSum = @errorSum + @@error; 提交事务 123/*在执行使用COMMIT语句可以提交事务，当执行了COMMIT语句后，会确认事务的变化，结束事务，删除保存点，释放锁。当使用COMMIT语句结束事务之后，其他会话将可以查看到事务变化后的新数据*/ 回滚事务 保存点（savepoint）：是事务中的一点，用于取消部分事务，当结束事务时，会自动的删除该事务所定义的所有保存点。当执行ROLLBACK时，通过指定保存点可以回退到指定的点 12345678--设置保存点SQL&gt; Savepoint a;--删除保存点SQL&gt; Release Savepoint a;--回滚部分事务SQL&gt; Rollback To a;--回滚全部事务SQL&gt; Rollback; 5. 事务分类 显示事务：用BEGIN TRANSACTION明确指定事务的开始，这是最常用的事务类型 隐性事务：通过设置SET IMPLICIT_TRANSACTIONS ON 语句，将隐性事务模式设置为打开，下一个语句自动启动一个新事务。当该事务完成时，再下一个 T-SQL 语句又将启动一个新事务 自动提交事务：这是 SQL Server 的默认模式，它将每条单独的 T-SQL 语句视为一个事务，如果成功执行，则自动提交；如果错误，则自动回滚 二、 数据库锁数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。 在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改；加了共享锁的数据对象可以被其他事务读取，但不能修改。 锁分类 根据保护对象的不同，Oracle数据库锁可分为： DML lock（data locks，数据锁）：用于保护数据的完整性 DDL lock（dictionary locks，字典锁）：用于保护数据库对象的结构（例如表、视图、索引的结构定义） Internal locks 和latches（内部锁与闩）：保护内部数据库结构 Distributed locks（分布式锁）：用于OPS（并行服务器）中 PCM locks（并行高速缓存管理锁）：用于OPS（并行服务器）中 在Oracle中最主要的锁是DML锁，DML锁的目的在于保证并发情况下的数据完整性。在Oracle数据库中，DML锁主要包括TM锁和TX锁，其中TM锁称为表级锁，TX锁称为事务锁或行级锁 锁出现在数据共享的场合，用来保证数据的一致性。当多个会话同时修改一个表时，需要对数据进行相应的锁定。 锁有共享锁、排它锁，共享排它锁等多种类型，而且每种类型又有行级锁 (一次锁住一条记录)，页级锁 (一次锁住一页，即数据库中存储记录的最小可分配单元)，表级锁 (锁住整个表) 共享锁（S锁） 可通过lock table in share mode命令添加该S锁。在该锁定模式下，不允许任何用户更新表。但是允许其他用户发出select …from for update命令对表添加RS锁 排他锁（X锁） 可通过lock table in exclusive mode命令添加X锁。在该锁定模式下，其他用户不能对表进行任何的DML和DDL操作，该表上只能进行查询 行级共享锁（RS锁） 通常是通过select … from for update语句添加的，同时该方法也是我们用来手工锁定某些记录的主要方法。比如，当我们在查询某些记录的过程中，不希望其他用户对查询的记录进行更新操作，则可以发出这样的语句。当数据使用完毕以后，直接发出rollback命令将锁定解除。当表上添加了RS锁定以后，不允许其他事务对相同的表添加排他锁，但是允许其他的事务通过DML语句或lock命令锁定相同表里的其他数据行 行级排他锁（RX锁） 当进行DML操作时会自动在被更新的表上添加RX锁，或者也可以通过执行lock命令显式的在表上添加RX锁。在该锁定模式下，允许其他的事务通过DML语句修改相同表里的其他数据行，或通过lock命令对相同表添加RX锁定，但是不允许其他事务对相同的表添加排他锁（X锁） 共享行级排他锁（SRX锁） 通过lock table in share row exclusive mode命令添加SRX锁。该锁定模式比行级排他锁和共享锁的级别都要高，这时不能对相同的表进行DML操作，也不能添加共享锁。 锁之间的兼容关系 述几种锁模式中，RS锁是限制最少的锁，X锁是限制最多的锁 DDL和DML锁 基本上所有的锁都可以由Oracle内部自动创建和释放，但是其中的DDL和DML锁是可以通过命令进行管理的，命令语法： 123SQL&gt; LOCK table_name IN [row share][row exclusive][share][share row exclusive][exclusive] MODE [NOWAIT]; 产生锁定模式的SQL语句 当程序对所做的修改进行提交(Commit)或回滚(Rollback)后，锁住的资源便会得到释放，从而允许其他用户进行操作。如果两个事务，分别锁定一部分数据，而都在等待对方释放锁才能完成事务操作，这种情况下就会发生死锁 三、数据库事务实现机制几乎所有的数据库管理系统中，事务管理的机制都是通过使用日志文件来实现的，简单介绍一下日志的工作方式。 当用户执行一条修改数据库的DML语句时，DBMS自动在日志文件中写一条记录，显示被这条语句影响的每一条记录的两个副本。一个副本显示变化前的记录，另一个副本显示变化后的记录。当日志写完之后，DBMS才实际对磁盘中的记录进行修改。 如果用户随后执行COMMIT语句，事务结束也被记录在事务日志中。如果用户执行ROLLBACK语句，DBMS检查日志，找出自事务开始以来被修改的记录“以前”的样子，然后使用这些信息恢复它们以前的状态，有效地撤销事务期间对数据库所做的修改。 如果系统出错，系统操作员通常通过运行DBMS提供的特殊恢复程序来复原数据库。恢复程序检查到事务日志末尾，查找故障之前没有被提交的事务。恢复程序回滚没有完全完成的事务，以便仅有被提交的事务反映到数据库中，而故障中正处理的事务被回滚。 事务日志的使用明显增加了更新数据库的开销。在实际中，主流商用DBMS产品使用的日志技术比上述描述的方案更复杂，用以减小这种开销。此外，事务日志通常被存储在高速磁盘驱动器中，不同于存储数据库的磁盘，以减小磁盘访问竞争。某些个人计算机DBMS产品允许关闭事务日志性能，以提高DBMS的性能。 四、银行转账示例用户把钱从一个银行账号转账至另一个银行账号，需要将资金从一个银行账号中取出，然后再存入另一个银行账号中。理想来说，这两次操作都应该成功。但是，如果有错误发生，则两次操作都应该失败，否则的话，操作之后其中一个账号中的金额将会是错误的，整个操作过程应该是原子性的，两个操作都是一个原子事务操作的一部分 1234567891011121314151617181920212223242526272829303132-- 从账户一向账户二转账SQL&gt; DECLARE v_money NUMBER(8, 2); -- 转账金额 v_balance account.balance%TYPE; -- 账户余额BEGIN v_money := &amp;转账金额; -- 输入转账金额 -- 从账户一减钱 UPDATE account SET balance = balance - v_money WHERE id=&amp;转出账户 RETURNING balance INTO v_balance; IF SQL%NOTFOUND THEN RAISE_APPLICATION_ERROR(-20001, &apos;没有该账户：&apos;||&amp;转出账户); END IF; IF v_balance &lt; 0 THEN RAISE_APPLICATION_ERROR(-20002, &apos;账户余额不足&apos;); END IF; -- 向账户二加钱 UPDATE account SET balance = balance + v_money WHERE id=&amp;转入账户; IF SQL%NOTFOUND THEN RAISE_APPLICATION_ERROR(-20001, &apos;没有该账户：&apos;||&amp;转入账户); END IF; -- 如果没有异常，则提交事务 COMMIT; DBMS_OUTPUT.PUT_LINE(&apos;转账成功&apos;); EXCEPTION WHEN OTHERS THEN ROLLBACK; -- 出现异常则回滚事务 DBMS_OUTPUT.PUT_LINE(&apos;转账失败：&apos;); DBMS_OUTPUT.PUT_LINE(SQLERRM);END; 五、Java调用数据库事务JavaBean中使用JDBC方式进行事务处理 : 1234567891011121314151617181920public int delete(int sID) &#123; dbc = new DataBaseConnection(); Connection con = dbc.getConnection(); try &#123; con.setAutoCommit(false);// 更改JDBC事务的默认提交方式 dbc.executeUpdate("delete from xiao where ID=" + sID); dbc.executeUpdate("delete from xiao_content where ID=" + sID); dbc.executeUpdate("delete from xiao_affix where bylawid=" + sID); con.commit();//提交JDBC事务 con.setAutoCommit(true);// 恢复JDBC事务的默认提交方式 dbc.close(); return 1; &#125; catch (Exception exc) &#123; con.rollBack();//回滚JDBC事务 exc.printStackTrace(); dbc.close(); return -1; &#125; &#125; 参考链接]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发器]]></title>
    <url>%2F2017%2F08%2F28%2FdataBase%2Ftrigger%2F</url>
    <content type="text"><![CDATA[Oracle触发器数据库触发器是一个与表相关联的、存储的PL/SQL程序。触发器作用：每当一个特定的数据操作语句（insert、update、delete）在指定的表上发出时，oracle自动地执行触发器中定义的语句序列。例：每当成功插入新员工后自动打印“成功插入新员工” 123456789101112SQL&gt; create trigger saysuccemp after insert on emp declare begin dbms_output.put_line(&apos;成功插入新员工&apos;); end; /--插入数据库操作SQL&gt; insert into emp(empno,ename,sal,deptno) values (1001,&apos;Tom&apos;,3000,10); 一、触发器语法123456SQL&gt; create [or replace] trigger 触发器名 before | after delete | insert | update [of 列名] --只有当更新该列名时才出发 on 表名 [for each row [where(条件)]] --指明触发器的类型，行级触发器 PLSQL块 语句级触发器 在指定的操作语句操作之前或之后执行一次，不管这条语句影响了多少行 行级触发器 触发语句作用的每一条记录都被触发。在行级触发器总使用 : old 和 : new伪记录变量，识别值的状态 区别 123SQL&gt; insert into emps select * from emp where deptno = 10;--emp中有3条记录--语句级触发器：针对的是表，所以该插入操作只会调用该触发器一次--行级触发器：针对的是行，所以该插入操作会调用该触发器三次 二、触发器的应用 复杂的安全性检查 例：非工作时间禁止操作数据库中的数据 123456789101112131415161718192021/*1.针对的是表，所以采用数据级触发器2.周末：to_char(sysdate,&apos;day&apos;) in (&apos;星期六&apos;,&apos;星期天&apos;);3.上班前，下班后：to_number(to_char(sysdate,&apos;hh24&apos;)) not between 9 and 18;*/SQL&gt; create or replace trigger securityemp before insert on emp begin if to_char(sysdate,&apos;day&apos;) in (&apos;星期六&apos;,&apos;星期天&apos;) or to_number(to_char(sysdate,&apos;hh24&apos;)) not between 9 and 18 then raise_application_error(-20001,&apos;非工作时间禁止操作数据库中的数据&apos;); --这里表示应用层错误，错误代码范围[-20000,-20999] --不能用raise抛出例外，raise表示数据库错误 end if; end; /SQL&gt; insert into emp(empno,ename,sal,deptno) values (1001,&apos;Tom&apos;,3000,10); 数据的确认 例：只有当涨后的工资大于涨前的工资时，才执行涨工资操作 12345678910111213141516/*检查记录行，所以是行级触发器*/SQL&gt; create or replace trigger checksalary before update on emp for each row --由于每行都要检查所以没有where条件 begin if :new.sal &lt; :old.sal then raise_application_error(-20002,&apos;涨后的工资不能小于涨前&apos;); end if; end; /SQL&gt; update emp set sal = sal + 1 where empno = 7839; update emp set sal = sal - 1 where empno = 7839; 数据库的审计 跟踪表上所做数据的操作，什么时间，什么人操作了什么数据 oracle已经实现了数据库的审计，共有5种，基于触发器的只是其中一种，这种叫基于值的审计 1234567891011121314151617181920212223/*1.给员工涨工资，当涨后的薪水超过6000块时，审计该员工的信息2.行级触发器*/--创建表用来保存审计信息SQL&gt; create table audit_info(information varchar2(200));SQL&gt; create or replace trigger do_audit_emp_salary after update on emp for each row begin if :new.sal &gt; 6000; then insert into audit_info values(:new.empno||&apos; &apos;||:new.ename||&apos; &apos;||:new.sal); end if; end; /SQL&gt; update emp set sal = sal + 2000;--information--7839 Tom 6100 数据库的备份与同步 当主数据库的数据更改，通过触发器将数据同步到从数据库中作备份 123456789101112131415161718/*1.给员工涨工资后，自动备份新的工资到备份表中2.行级触发器*/--创建备份表SQL&gt; create table emp_back as select * from emp;SQL&gt; create or replace trigger sync_salary after update on emp for each row begin --当主表更新后，自动更新备份表 update emp_back set sal = :new.sal where empno = :new.empno; end; /SQL&gt; update emp set sal = sal + 2000 where empno = 7839; 触发器与快照 触发器：同步备份（同步：没有延迟） 快照：异步备份 ​ ​]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储过程和存储函数]]></title>
    <url>%2F2017%2F08%2F27%2FdataBase%2Fprocedure%2F</url>
    <content type="text"><![CDATA[存储过程和存储函数存储在数据库中供所有用户程序调用的子程序叫存储过程、存储函数。两者的相同点是：完成特点功能的程序。区别是：存储函数可以使用return语句返回值，存储过程不可以。存储过程的有点： 执行速度更快 允许模块化程序设计 提高系统安全性 减少网络流通量 系统存储过程存放在master数据库中，名称都以sp_开头或xp_开头，类似Java语言类库中的方法： 系统存储过程 说明 sp_databases 列出服务器上的所有数据库 sp_helpdb 报告有关指定数据库或所有数据库的信息 sp_renamedb 更改数据库的名称 sp_tables 返回当前环境下可查询的对象的列表 sp_columns 返回某个表列的信息 sp_help 查看某个表的所有信息 sp_helpconstraint 查看某个表的约束 sp_helpindex 查看某个表的索引 sp_stored_procedures 列出当前环境中的所有存储过程 sp_password 添加或修改登录账户的密码 sp_helptext 显示默认值、未加密的存储过程、用户定义的存储过程、触发器或视图的实际文本 一、创建和使用存储过程 用create procedure命令建立存储过程 123SQL&gt; create [or replace] procedure 过程名[(参数列表)] as pl/sql子程序体; 第一个存储过程：打印hello world 1234567SQL&gt; create or replace procedure SAYHELLOWORLD as --oracle存储数据库对象默认采用大写，所以保存的过程名全大写 --说明部分（包括声明光标等） begin dbms_output.put_line(&apos;Hello World&apos;); end; / 调用该存储过程 1234567--调用方式1SQL&gt; exec SAYHELLOWORLD();----调用方式2SQL&gt; begin SAYHELLOWORLD(); end; / 带参数的存储过程 例：为指定的员工涨100块钱工资，并打印涨前和涨后的工资 1234567891011121314SQL&gt; create or replace procedure RAISESALARY(eno in number) --输入参数 as --定义一个变量保存涨前的薪水 psal emp.sal % type; begin --得到员工涨前的薪水 select sal into psal from emp where empno = eno; --涨薪水操作 update emp set sal = sal + 100 where empno = eno; --可以commit和rollback --一般不在存储过程或存储函数中commit或rollback，因为这样不能保证调用者在同一个事务中 dbms_output.put_line(&apos;涨前：&apos;|| psal || &apos;涨后：&apos; || (psal+100)); end; / 调用该存储过程 123456SQL&gt; begin RAISESALARY(7839); RAISESALARY(7840); commit; end; / 调用存储过程 不推荐远程调试（指oracle数据库与图形化工具不在同一机器上），这样远程调试需要指定服务器的IP地址，还需要工具-首选项-调试器-端口 推荐把图形化工具拷贝到虚拟机所在的服务器的IP地址上 授权 12SQL&gt; / as sysdba;--不用写用户名和密码，采用主机认证 grant debug connect session,debug any procedure to scott; 二、存储函数函数(Function)命名的存储程序，可带参数，并返回一计算值。存储函数和存储过程的结构类似，但必须有一个return子句用于返回函数值 创建存储函数的语法 1234SQL&gt; create [or replace] function 函数名[(参数列表)] return 函数值类型 as pl/sql子程序体; 例：查询某个员工的年收入 123456789101112SQL&gt; create or replace function QUERYEMPINCOME(eno in number) return number as --定义员工的薪水和奖金变量 psal emp.sal % type; pcomm emp.comm % type; begin --得到该员工的月薪和奖金 select sal,comm into psal,pcomm from emp where empno = eno; return psal*12+nvl(pcomm,0); end; / 三、out参数存储过程和存储函数都可以有多个out参数，存储过程可以通过out参数来实现返回值。原则：如果只有一个返回值，则使用存储 函数，否则使用存储过程。例：查询某个员工姓名、月薪和职位： 12345678910SQL&gt; create or replace procedure QUERYEMPININFO(eno in number, pename out varchar2, psal out number, pjob out varchar2) as begin select ename,sal,empjob into pename,psal,pjob from emp where empno = eno; end; / 分析： 查询某个员工的所有信息–out参数太多？ 查询某个部门中所有员工的所有信息–out参数中返回集合？ 如何解决：在out参数中使用光标 四、out参数使用光标查询某个部门中所有员工的所有信息： 123456789101112131415161718--包头：只负责声明ref---引用，SQL&gt; create or replace package mypackage as type empcursor is ref cursor;--光标的类型，使用type自定义的 --ref---引用，引用光标的类型作为empcursor的类型，即empcursor为光标类型 procedure QUERYEMPLIST(dno in number, emplist out empcursor); end mypackage;--包体：需要实现包头中声明的所有方法，包括存储过程SQL&gt; create or replace package body mypackage as procedure QUERYEMPLIST(dno in number, emplist out empcursor); as begin open emplist for select * from emp where deptno = dno;--for关键字 end QUERYEMPLIST; end mypackage;--可以查看程序包的结构SQL&gt; desc mypackage 在应用中实现 1234//在应用中访问包中的存储过程package.cursor//需要带包名//应用程序实现rs = ((OracleCallableStatement)call).getCursor(2);//需要强制转换 五、java访问存储过程数据库工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 接口：java.sql.CallableStatement * 该语法允许对所有RDBMS使用标准方式调用存储过程 * @author guangguang_duan * *///创建数据库工具类public class JDBCUtils &#123; private static String driver = "oracle.jdbc.OracleDriver"; private static String url = "jdbc:oracle:thin:@127.0.0.1:1521:orcl"; private static String user = "scott"; private static String password = "tiger"; //注册数据库的驱动 static&#123; try&#123; Class.forName(driver);//使用反射机制注册 //DriverManager.registerDriver(driver); &#125;catch(ClassNotFoundException e)&#123; throw new ExceptionInInitializerError(e); &#125; &#125; //获取数据库连接 public static Connection getConnection()&#123; try&#123; return DriverManager.getConnection(url,user,password); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; return null; &#125; //释放数据库方法 public static void release(Connection conn, Statement st, ResultSet rs)&#123; if(rs != null)&#123; try&#123; rs.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125;finally&#123; rs = null;//目的是这个对象会迅速成为java垃圾回收的对象 &#125; &#125; if(st != null)&#123; try&#123; st.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125;finally&#123; st = null; &#125; &#125; if(conn != null)&#123; try&#123; conn.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125;finally&#123; conn = null; &#125; &#125; &#125;&#125; 访问存储过程 123456789101112131415161718192021222324252627282930import org.junit.Test;public class TestProcedure &#123; @Test public void tProcedure()&#123; String sql = "&#123;call QUERYEMPINFO(?,?,?,?)&#125;"; Connection conn = null; CallableStatement call = null; try&#123; conn = JDBCUtils.getConnection(); call = conn.prepareCall(sql); //对于in参数，赋值 call.setInt(1, 7839); //对于out参数，申明 call.registerOutParameter(2, OracleTypes.VARCHAR);//??? call.registerOutParameter(3, OracleTypes.NUMBER); call.registerOutParameter(4, OracleTypes.VARCHAR); //执行调用 call.execute(); //取结果 String name = call.getString(2); double sal = call.getDouble(3); String job = call.getString(4); System.out.println(name +"\t"+ sal +"\t"+job); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; JDBCUtils.release(conn, call, null); &#125; &#125;&#125; 六、java访问存储函数访问存储函数 123456789101112import org.junit.Test;public class TestFunction &#123; @Test public void tProcedure()&#123; //第一个?表示out参数，第二个?表示in参数 String sql = "&#123;? = call QUERYEMPINCOME(?)&#125;"; /** * 同存储过程 */ &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle函数]]></title>
    <url>%2F2017%2F08%2F27%2FdataBase%2Foracle-function%2F</url>
    <content type="text"><![CDATA[Oracle之函数一、数值函数 四舍五入 1234567SQL&gt; ROUND(n[,m]);--省略m或者m等于0：取整--m&gt;0：小数点后m位,保留m位小数--m&lt;0：小数点前m位，从m位进行四舍五入SQL&gt; select round(23.4),round(23.45,1),round(23.45,-1) from dual;--23, 23.5, 23 取整函数 12345SQL&gt; CEIL(n); --取最大值 FLOOR(n); --取最小值SQL&gt; select ceil(23.45),floor(23.45) from dual;--24, 23 取绝对值 1SQL&gt; ABS(n); 取余数 12MOD(m,n);--m/n，如果 m和n中有一个值为null，则结果为null m的n次幂 12SQL&gt; POWER(m,n);--m^n，m和n中有一个值为null，则结果为null 平方根 1SQL&gt; SQRT(n); 三角函数 123SQL&gt; SIN(n);ASIN(n); --正玄/反正玄 COS(n);ACOS(n); --余玄/反余玄 TAN(n);ATAN(n); --正切/反正切 二、字符函数 大小写转换函数 123456SQL&gt; UPPER(char); --小--大 LOWER(char); --大--小 INITCAP(char); --首字母大写SQL&gt; select upper(&apos;abcd&apos;),lower(&apos;ASD&apos;),initcap(&apos;asd&apos;) from dual;--用途：注册用户名密码：不区分大小写，统一转换成大/小写存入数据库 获取子字符串函数 1234SQL&gt; SUBSTR(char[,m[,n]]);--char：源字符串--m：取子串开始的位置，m为负数表示从尾开始--n：截取的位数 获取字符串长度函数 123SQL&gt; LENGTH(char)SQL&gt; select length(&apos;abc &apos;) from dual;--4 字符串连接函数 1SQL&gt; CONCAT(char1,char2);--同|| 去除子串函数 123456--当只有一个参数时表示去除空格SQL&gt; TRIM(c2 from c1); --从c1中去除c2，只能去除一个字符 LTRIM(c1[,c2]); --从c1中去除c2，去除头部 RTRIM(c1[,c2]); --从c1中去除c2，去除尾部SQL&gt; select rtrim(&apos;abaa&apos;,&apos;a&apos;) from dual;--ab 替换函数 1234567SQL&gt; REPLACE(char,s_string[,r_string]);--char：源字符串--s_string：源字符串中被替换的字符串--r_string：替换s_string的字符串，省略时表示空替换SQL&gt; select replace(&apos;abcde&apos;,&apos;a&apos;,&apos;A&apos;) from dual;--Abcde select replace(&apos;abcde&apos;,&apos;a&apos;) from dual;--bcde 三、日期函数 系统时间 1SQL&gt; SYSDATE;--默认格式是DD-MON-RR 27-8月-17 日期操作 1234567891011121314151617SQL&gt; ADD_MONTHS(date,i); --i为正在月份上加，i为负在月份上减 NEXT_DAY(date,char); select next_day(sysdate,&apos;星期一&apos;) from dual; --返回下一个星期一是几号 LAST_DAY(date); --用于返回日期所在月的最后一天是几号 MONTHS_BETWEEN(date1,date2); --两日期之间间隔的月份 EXTRACT(date from datetime); select extract(year from sysdate) from dual;--month/day --返回所在的年/月/日 select extract(hour from timestamp &apos;2017-8-27 17:35:28&apos;) from dual; 四、转换函数 日期转字符 1234567SQL&gt; TO_CHAR(date[,fmt[,params]]);--date：要转换的日期--fmt：转换的格式YY MM DD HH24 HH12 MI SS--params：日期的语言，英文的格式：YEAR MONTH DAY--默认格式：DD-MON-RRSQL&gt; select to_char(sysdate,&apos;YYYY-MM-DD HH24:MI:SS&apos;) from dual; 字符转日期 123SQL&gt; TO_DATE(char[,fmt[,params]]); select to_date(&apos;2017-8-27&apos;,&apos;YYYY-MM-DD&apos;) from dual;--注：to_date按照系统默认格式显示成日期，可再结合to_char转换 数字转字符 123456789SQL&gt; TO_CHAR(number[,fmt]);--9：显示数字并忽略前面的0--0：显示数字，位数不足用0补齐--.或D：显示小数点--,或G：显示千位符--$：显示美元符号--s：加正负号，前后都可以，不能同时加SQL&gt; select to_char(12345.678,&apos;$99,999.999&apos;) from dual;--$12,345.678 字符转数字 12SQL&gt; TO_NUMBER(char[,fmt]); select to_number(&apos;$1,000&apos;,&apos;$9999&apos;) from dual;--1000 五、oracle在查询中使用函数 使用字符函数 12345--根据身份证号得到生日SQL&gt; select substr(cardid,7,8) from users;--将部门号“01”替换成“信息技术”SQL&gt; select replace(deptno,&apos;01&apos;,&apos;信息技术&apos;) from users; 使用数值函数 1SQL&gt; select mod(age,10) from dual; 使用日期函数 12345--取员工入职年份SQL&gt; select extract(year from regdate) from users;--查询5月份入职的员工信息SQL&gt; select * from users where extract(month from regdate) = 5;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PL/SQL基础]]></title>
    <url>%2F2017%2F08%2F25%2FdataBase%2FplsqlBase%2F</url>
    <content type="text"><![CDATA[PL/SQL基础PL/SQL操作oracle数据库效率最高，是学习存储过程，存储函数，触发器的前提。打印hello world： 1234567891011SQL&gt; declare --说明部分（变量，光标或者例外） begin -- 程序体 dbms_output.put_line(&apos;hello world&apos;); end; / --表示pl/sql完成并执行--打开输出开关SQL&gt; set serveroutput on; / --执行 一、PL/SQL概念PL/SQL（procedure language/sql）是oracle对sql语言的过程化扩展 SQL语言：数据操纵 过程语言：数据处理 组成pl/sql：简单、高效、灵活、实用 不同的数据库对sql的扩展 oracle ：pl/sql DB2：sql/pl SQL Server：Transac_SQL（T-SQL） 二、PL/SQL基础语法12345678SQL&gt; declare --说明部分 begin --语句序列（DML语句） exception --例外处理语句 end; / 1. 变量定义 定义基本变量 123456--类型char, varchar2, date, number, boolean, long--例：varl char(15);married boolean := true;psal number(7,2); 引用型变量 12--例：my_name emp.ename % type; 记录型变量 可以理解为是个数组，数组中的每个元素为列 1234--例：emp_rec emp % rowtype;--行类型--记录型变量的引用emp_rec.ename := &apos;ADAMS&apos;; 例子 查询并打印7839的姓名和薪水 12345678910111213--定义引用型变量SQL&gt; declare --pename varchar2(20); --基本变量 --psal number; --基本变量 pename emp.ename % type; psal emp.sal % type; begin --得到7839的姓名和薪水 select ename,sal into pename,psal from emp where empno = &apos;7839&apos;; --打印姓名和薪水 dbms_output.put_line(pename||&apos;的薪水是&apos;||psal); end; / 12345678--定义记录型变量实现上面的例子SQL&gt; declare emp_rec emp % rowtype; begin select * into emp_rec from emp where empno = &apos;7839&apos;; dbms_output.put_line(emp_rec.ename||&apos;的薪水是&apos;||emp_rec.sal); end; / 2. if语句123456789101112--例：判断用户键盘输入的数字SQL&gt; accept num prompt &quot;请输入一个数字&quot;; declare --num：地址值，含义是在该地址上保存了输入的值 pnum number := &amp;num;--&amp;是地址符 begin if pnum = 0 then dbms_output.put_line(&quot;输入0&quot;); elsif pnum = 1 then dbms_output.put_line(&quot;输入1&quot;); else dbms_output.put_line(&quot;其他&quot;); end if; end; / 3. 循环语句 形式1 1234SQL&gt; while total &lt;= 2500 loop ... total := total+salary; end loop; 例：使用while循环打印1-10 123456789SQL&gt; declare pnum number := 1; begin while pnum &lt;= 10 loop dbms_output.put_line(pnum); pnum := pnum+1; end loop; end; / 形式2 1234SQL&gt; loop exit [when conditions];--当条件成立时退出循环 ... end loop; 例： 12345678910SQL&gt; declare pnum number := 1; begin loop exit when pnum &gt;10; dbms_output.put_line(pnum); pnum := pnum+1; end loop; end; / 形式3 123SQL&gt; for i in 1...3 loop --必须是连续区间 ... end loop; 例： 12345678SQL&gt; declare pnum number := 1; begin for pnum in 1...10 loop dbms_output.put_line(pnum); end loop; end; / 三、光标光标就是一个结果集（result set）。例： 12select job into ptilte from emp;--job是一个结果集合，不能直接赋给ptilte，too many rows。所以引入光标 1. 光标的语法1234SQL&gt; cursor 光标名 [(参数名 参数类型,...)] is select 语句;--例：SQL&gt; cursor cl is select ename from emp; 从光标中取值： 123456--打开光标open cl;--取一行光标的值fetch cl into pename;--关闭光标close cl;--关闭光标，释放资源 2. 光标的属性1234%found;--fetch取到记录则为true%notfound;--%isopen;--光标是否打开%rowcount;--影响的行数，不是总行数 例：查询并打印员工的姓名和薪水 12345678910111213141516SQL&gt; set serveroutput on; declare cursor cemp is select ename,sal from emp; --为光标定义对应的变量 pename emp.ename % type; psal emp.sal % type; begin open cemp; loop fetch cemp into pename,psal; exit when cemp % notfound; --当取不到记录时退出循环 dbms_output.put_line(pename||&apos;的薪水是&apos;||psal);--fetch不一定能取到记录 end loop; close cemp; end; / 3. 案例：给员工涨工资12345678910111213141516171819202122--给员工涨工资，总裁1000，经理800，其他400SQL&gt; declare cursor cemp is select pempno,pjob from emp; --为光标定义对应的变量 pempno emp.empno % type; pjob emp.empjob % type; begin --rollback open cemp; loop fetch cemp into pempno,pjob; exit when cemp % notfound; --当取不到记录时退出循环 if pjob = &apos;zongcai&apos; then update emp set sal=sal+1000 where empno = pempno; elsif pjob = &apos;jingli&apos; then update emp set sal=sal+800 where empno = pempno; else update emp set sal=sal+400 where empno = pempno; end if; end loop; close cemp; commit;--当对数据库数据发生改变时需要提交 --对于oracle默认的事物隔离级别是read committed end; / 4. 光标数的限制默认情况下，oracle数据库只允许在同一个会话中打开300个光标 查看参数值 12SQL&gt; conn sys/orcl as sysdba; show parameter cursor; 修改光标数的限制 12345SQL&gt; alter system set open_cursor = 400 scope = both;--scope取值both;--两者都更改（当前实例/改参数文件）memory;--只更改当前实例，不更改参数文件spfile;--只更改参数文件，不更改当前实例（需要重启数据库） 5. 带参数的光标例：查询某个部门中员工的姓名 12345678910111213SQL&gt; declare cursor cemp(dno number) is select ename from emp where deptno = dno; pename emp.ename % type; begin open cemp(10); loop fetch cemp into pename; exit when cemp % notfound; dbms_output.put_line(pename); end loop; close cemp; end; / 四、例外例外是程序设计语言提供的一种功能，用来增强程序的健壮性和容错性。系统例外： no_data_found 没有找到数据 too_many_rows select…into语句匹配多个行 zero_divide 被零除 value_error 算术或转换错误 timeout_on_resource 在等待资源时发生超时（典型场景：分布式数据库） 1. 系统例外之no_data_found123456789SQL&gt; declare pename emp.ename % type; begin select ename into pename from emp where empno = 123; exception when no_data_found then dbms_output.put_line(&quot;没有找到员工&quot;); when others then dbms_output.put_line(&quot;其他例外&quot;); end; / 2. 系统例外之too_many_rows12345678910SQL&gt; declare pename emp.ename % type; begin --查询所有10号部门的员工 select ename into pename from emp where deptno = 10; exception when too_many_rows then dbms_output.put_line(&quot;select into 匹配了多行&quot;); when others then dbms_output.put_line(&quot;其他例外&quot;); end; / 3. 系统例外之zero_divide123456789SQL&gt; declare pnum number; begin pnum := 10/0; exception when zero_divide then dbms_output.put_line(&quot;0不能做除数&quot;); when others then dbms_output.put_line(&quot;其他例外&quot;); end; / 4. 系统例外之value_error123456789SQL&gt; declare pnum number; begin pnum := &apos;abc&apos;; exception when value_error then dbms_output.put_line(&quot;转换错误&quot;); when others then dbms_output.put_line(&quot;其他例外&quot;); end; / 5. 系统例外之timeout_on_resource 6. 自定义例外定义变量，类型是exception，使用raise抛出自定义例外 1234567891011121314151617181920212223SQL&gt; declare cursor cemp is select ename from emp where deptno = 50; pename emp.ename % type; --自定义例外 no_emp_found exception; begin open cemp; loop fetch cemp into pename; if cemp % notfound then raise no_emp_found; end if; end loop; --oracle自动启动pmon（processmonitor 进程监视器） --自动释放资源（当抛出异常时，语句直接跳到exception，所以光标没有正确关闭） close cemp; exception when no_emp_found --一般会将异常存入表中 then insert into emp values(&quot;fetch语句没有获得数据或数据已经处理完&quot;); when others then dbms_output.put_line(&quot;其他例外&quot;); close cemp; end; / 五、PL/SQL综合案例1. 统计每年入职的员工数12345678910111213141516171819202122SQL&gt; declare cursor cemp is select to_char(hiredate,&apos;yyyy&apos;) from emp; phiredate varchar(4); --员工入职年份 count16 number := 0; --员工数 count17 number := 0; countnum number := 0; begin open cemp; loop fetch cemp into phiredate; exit when cemp % notfound; if phiredate = &apos;2016&apos; then count16 := count16 + 1; elsif phiredate = &apos;2017&apos; then count17 := count17 + 1; else countnum := countnum + 1; end if; end loop; close cemp; dbms_output.put_line(&quot;16年入职人数：&quot;|| count16); dbms_output.put_line(&quot;17年入职人数：&quot;|| count17); dbms_output.put_line(&quot;其他年份入职人数：&quot;|| countnum); end; / 2. 员工涨工资从最低工资涨起，每人涨10%，但工资总额不能超过5万元，计算涨工资的人数（次数）和涨后的工资总额 1234567891011121314151617181920212223242526SQL&gt; declare cursor cemp is select empno,sal from emp order by sal; pempno emp.empno % type; psal emp.sal % type; countemp number := 0;--涨工资的次数 saltotal number; begin select sum(sal) into saltotal from emp;--得到工资总额初始值 open cemp; loop exit when saltotal &gt; 50000;--退出条件，工资总额初始值大于50000 fetch cemp into pempno,psal; exit when cemp % notfound; --涨工资 update emp set sal = sal*1.1 where empno = pempno; countemp := countemp+1;--这里指涨工资的次数，人数的话还需要判断这个人涨工资后是否还进行过涨工资 saltotal ：= saltotal+psal*0.1; ----在涨工资后做判断，工资总额大于50000时不进行涨工资操作 if saltotal &gt; 50000 then update emp set sal = sal/1.1 where empno = pempno; saltotal ：= saltotal-psal*0.1; end loop; close cemp; commit; dbms_output.put_line(&quot;涨工资次数数：&quot;|| countemp ||&quot;,涨后的工资总额：&quot; || saltotal); end; / 分析：涨后的工资总额 select sum(sal) into saltotal from emp; 涨后的工资总额 = 涨前的工资总额 + sal*0.1 因为不是每个人都会涨，所以需要得到工资总额初始值，一开始得不到涨后的工资总额 注意rollback的使用方法 3. 涉及两张表的统计员工工资实现按部门分段（6000以上、[6000,3000]、3000以下）统计各工资段的人数以及各个部门的工作总额，不涉及多表查询 创建表保存统计结果 12345678SQL&gt; create table msg ( deptno number,--部门号 count1 number,--&lt;3000 count2 number,--[3000,6000] count3 number,--&gt;6000 saltotal number--工资总额 ) 12345678910111213141516171819202122232425262728293031323334353637SQL&gt; declare cursor cdept is select deptno from dept;--部门光标 pdeptno dept.deptno % type; cursor cemp(dno number) is select sal from emp where deptno = dno;--员工薪水光标 psal emp.sal % type; count1 number; count2 number; count3 number; saltotal number; begin open cdept; loop fetch cdept into pdeptno; exit when cemp % notfound; --初始化工作 count1 := 0; count2 := 0; count3 := 0; --得到部门的工资总额 select sum(sal) into saltotal from emp where deptno = pdeptno; open cemp(pdeptno); loop fetch cemp into psal; exit when cemp % notfound; if psal &lt; 3000 then count1 := count1+1; elsif psal &gt;= 3000 and psal &lt;= 6000 then count2 := count2+1; else count3 := count3+1; end if; end loop; close cemp; --保存当前部门的结果（退后进行部门统计） insert into msg values (pdeptno,count1,count2,count3,nvl(saltotal,0)) --nvl,预空函数，当saltotal为null时值为0 end loop; close cdept; commit; dbms_output.put_line(&quot;统计完成&quot;); end; / 4. 成绩统计按系名分段统计（&lt;60，[60,85]，&gt;85）”大学物理“课程各分段的学生人数以及各系学生的平均成绩。涉及多表查询（子查询） 1. 分析 sql语句 得到哪些系 12SQL&gt; select dno,dname from dep;--光标--循环--退出条件：notfound 得到系中选了”大学物理“课程学生的成绩 1234567SQL&gt; select grade from sc where cno = ( select cno from course where cname = ? --课程名 ) and sno in ( select sno from student where dno = ? --系名 );--带参数的光标--循环--退出条件：notfound 变量 初始值 最终值如何得到 每个分段的人数 count1，count2，count3初始化的位置，第一个循环内，第二个循环外 每个系选了”大学物理“学生的平均成绩 算术运算 查数据库 123456SQL&gt; select avg(grade) into avggrade from sc where cno = ( select cno from course where cname = ? ) and sno in ( select sno from student where dno = ? ); 性能问题 算术运算比较好 能不查数据库就不查数据库，查询数据库耗时大 2. 程序 创建msg1保存结果 123456789SQL&gt; create table msg1 ( coursename varchar2(20),--课程名称 dname varchar2(20),--系名 count1 number,--&lt;60 count2 number,--[60,85] count3 number,--&gt;85 avggrade number--平均成绩 ) 成绩统计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950SQL&gt; declare --系的光标 cursor cdept is select dno,dname from dep; pdno dep.dno % type; pdname dep.dname % type; --成绩光标 cursor cgrade(coursename varchar2,depno number) is select grade from sc where cno = ( select cno from course where cname = coursename) and sno in ( select sno from student where dno = depno ); pgrade sc.grade % type; --每个分段的人数 count1 number; count2 number; count3 number; --每个系选秀了&quot;&quot;大学物理&quot;学生的平均成绩 avggrade number; --课程名称 pcoursename varchar2 := &apos;大学物理&apos;; begin open cdept; loop --取一个系的信息 fetch cdept into pdno,pdname; exit when cemp % notfound; --初始化工作 count1 := 0; count2 := 0; count3 := 0; --系的平均成绩 select avg(grade) into avggrade from sc where cno = ( select cno from course where cname = pcoursename) and sno in ( select sno from student where dno = pdno); --取系中选修了&quot;&quot;大学物理&quot;的学生成绩 open cgrade(pcoursename,pdno); loop fetch cgrade into pgrade; --取一个学生的成绩 exit when cgrade % notfound; if pgrade &lt; 60 then count1 := count1+1; elsif psal &gt;= 60 and psal &lt;= 85 then count2 := count2+1; else count3 := count3+1; end if; end loop; close cgrade; --保存当前结果 insert into msg1 values (pcoursename,pdname,count1,count2,count3,avggrade); end loop; close cdept; commit; dbms_output.put_line(&quot;统计完成&quot;); end; /]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础]]></title>
    <url>%2F2017%2F08%2F24%2FdataBase%2ForacleBase%2F</url>
    <content type="text"><![CDATA[Oracle基础 用户登录 1234--使用用户名/密码登陆SQL&gt;connect username/password;--使用sys登陆，权限最高SQL&gt;connect sys/password as sysdba; 查看登陆用户 123SQL&gt;show user;--dba_users用户信息的数据字典SQL&gt;select username from dba_users; 启用scott用户 12SQL&gt;alter user scott account unlook;SQL&gt;connect scott/password; 一、表空间表空间是数据库的逻辑存储空间，在数据库中开辟的空间用来存储数据对象。表空间由数据文件构成，数据库可以由多个表空间来构成 永久表空间 表、视图、存储过程 临时表空间 中间过程、临时表 UNDO表空间（安度） 保存事物所修改的旧值，可以执行撤销操作 设置默认表空间 12--设置user为默认表空间SQL&gt;alter user system DEFAULT TABLESPACE system; 创建表空间 123SQL&gt;create tablespace TEST_TABLESPACE datafile &apos;testfile.dbf&apos; size 10m;--创建临时表空间SQL&gt;create temporary tablespace TEMP tempfile &apos;tempfile.dbf&apos; size 10m; 查看表空间 123SQL&gt;desc dba_tablespaces;--user_tablespaceSQL&gt;select tablespace_name from dba_tablespace;SQL&gt;select file_name from dba_data_files where tablespace_name = &apos;TEST_TABLESPACE&apos;; 修改表空间 123456--设置联机或脱机状态SQL&gt;alter tablespace TEST_TABLESPACE online;--offline--查看表空间状态SQL&gt;select status from dba_tablespace where tablespace_name = &apos;TEST_TABLESPACE&apos;;--设置只读或可读可写状态（联机状态下）SQL&gt;alter tablespace TEST_TABLESPACE read only;--read write 修改数据文件 1234567--增加数据文件SQL&gt;alter tablespace TEST_TABLESPACE add datafile &apos;testfile2.dbf&apos; size 10m;--查看数据文件SQL&gt;select file_name from dba_data_files where tablespace_name = &apos;TEST_TABLESPACE&apos;;--删除数据文件SQL&gt;alter tablespace TEST_TABLESPACE drop datafile &apos;testfile2.dbf&apos;;--注：不能删除创建表空间时创建的数据文件，否则需要删除该表空间 删除表空间 1234--只删除表空间SQL&gt;drop tablespace TEST_TABLESPACE;--删除表空间及数据SQL&gt;drop tablespace TEST_TABLESPACE including contients; 二、管理表1. 认识表 表是基本存储单位，位于表空间 二维结构：行—-记录；列—域或字段 约定： 每一列数据必须具有相同数据类型 列名唯一 每一行数据的唯一性 2. 数据类型（oracle 11g） 字符型 固定长度 123--按照unicode编码，存汉字情况多CHAR(n);--max:2000NCHAR(n);--max:1000 可变长度 12VARCHAR2(n);--max:4000NVARCHAR2(n);--max:2000 数值型 1234NUMBER(p,s);--p表示有效数字，s表示小数点后的位数。例：NUMBER(5,2) ---123.45FLOAT(n);--主要存储二进制类型，能存储二进制位数1-126位--二进制转十进制：给这个数乘以0.30103 日期型 123DATE--表示范围：公元前4712年1月1日到公元9999年12月31日TIMESTAMP--时间戳，可精确到小数秒 其他类型（存放大数据） 12BLOB--可存放4GB数据，以二进制形式存CLOB--可存放4GB数据，以字符串形式存 3. 管理表 创建表 1234create table table_name( column_name datatype, ...) 添加字段 1alter table table_name add column_name datatype; 更改字段数据类型 1alter table table_name modify column_name datatype; 删除字段 1alter table table_name drop column column_name; 修改字段名 1alter table table_name rename column column_name to new_column_name; 修改表名 1rename table_name to new_table_name; 删除表 123delete from table_name where column_name = column_value;--删除表中数据truncate table table_name;--删除表中数据，效果比delete快很多，也称为截断drop table table_name;--删除表结构 三、操作表中数据1. 添加12insert into table_name (column1,column1,...) values (value1,value2,...)--默认值：default,创建表修改表都可以使用 2. 复制表数据12345678--创建表时复制create table table_nameasselect column1,...|* from table_old--添加时复制insert into table_name[(column1,...)] --复制全部数据时可省略select column1,...|* from table_old 3. 修改数据12update table_name set column1 = value1,...[where conditions] 4. 删除数据12delete from table_name[where conditions] 四、约束约束作用：定义规则，确保数据完整性 1. 非空约束 创建表时设置非空约束 12345create table table_name( column_name datatype not null, ...) 修改表时设置非空约束 123--前提时修改的表无数据。可先delete再修改alter table table_namemodify column_name datatype not null 2. 主键约束确保表当中每一行数据的唯一性，非空。一张表只能设计一个主键约束。主键约束可以由多个字段构成（联合主键/复合主键） 创建表时创建 12345create table table_name( column_name datatype primary key, ...) 联合主键举例 1234567create table userinfo( id number(6,0), username varchar2(20), userpass varchar2(20), constraint pk_id_username primary key(id,username) --pk_id_username是主键约束名) 查主键 12--user_constraints用户数据字典select constraint_name from user_constraints where table_name = &apos;userinfo&apos;; 修改表时添加主键约束 123alter table table_nameadd constraint constraint_name --主键名primary key(column_name1,...); 更改约束名 12alter table userinforename constraint pk_id to new_pk_id; 删除主键约束 禁用 123alter table userinfo disable|enable constraint constraint_name;--禁用/启用--查看禁用启用select constraint_name,status from user_constraints where table_name = &apos;userinfo&apos;; 删除 1alter table userinfo drop constraint constraint_name; 涉及外键 12--涉及外键时，将引用该主键的也删掉alter table table_name drop primary key [cascade] 3. 外键约束注： 设置外键约束时，主表的字段必须是主键 主从表中相应的字段必须是同一个数据类型 从表中外键字段的值必须来自主表中相应字段的值或者为null值 创表时—列及 123456create table table1 --从表( column_name datatype references table2(column_name) --主表 ...) 创表时—表及 12constraint constraint_name foreign key (column_name)references table_name (column_name)[on delete cascade] --及联删除所在行 例： 123456789create table userinfo_f2( id varchar2(10) primary key, username varchar2(20), typeid_new varchar2(10) references typeinfo(typeid) --列及 ... typeid_new_t2 varchar2(10), constraint fk_typeid_new foreign key (typeid_new_t2) references typeinfo (typeid) --表及) 修改表时设置外键约束 123alter table table_nameadd constraint constraint_name foreign key (column_name)references table_name (column_name)[on delete cascade] 删除外键约束 禁用 12alter table table_namedisable|enable constraint constraint_name 删除 12alter table table_namedrop constraint constraint_name 4. 唯一约束保证字段值的唯一性 唯一约束与主键约束的区别 | | 主键约束 | 唯一约束 || —- | —- | ———— || 是否可空 | 非空 | 可空 || 值个数 | 一个 | 可多个，但空值只能有一个 | 创建表设置唯一约束 列及 12345create table table_name( column_name datatype unique, ...) 表及 12345create table table_name( column_name datatype, constraint constraint_name unique (column_name)) 修改表时添加唯一约束 12alter table table_nameadd constraint constraint_name unique (column_name) 删除唯一约束 禁用 12alter table table_namedisable|enable constraint constraint_name 删除 12alter table table_namedrop constraint constraint_name 5. 检查约束使数据有意义 创表时设置检查约束 列及 12345678910create table table_name( column_name datatype check (expressions), ...)--例：create table userinfo_f3( salary number(5,0) check (salary &gt; 0)) 表及 12345create table table_name( column_name datatype, constraint constraint_name check (expressions)) ​ 修改表时添加检查约束 12alter table table_nameadd constraint constraint_name check (expressions) 查看约束名 1select constraint_name,constraint_type,status from user_constraints where table_name = &apos;userinfo_f3&apos;; 删除检查约束 禁用 12alter table table_namedisable|enable constraint constraint_name 删除 12alter table table_namedrop constraint constraint_name 五、查询1. 基本查询语句12select [distinct] column_name1, ... | *from table_name [where conditions] 2. 在sql*plus中设置格式12345678910--设置结果的字段名column column_name heading new_name;--设置格式column column_name format dataformat; --注：字符型只能设置长度（a开头） column username format a10;--将长度改为10 --注：数值型可以用9代表一位数字 column salary format 9999.9;--还可以$99.9--清除格式column column_name clear; 3. 给字段设置别名针对查询结果，不改变表的列名 1select column_name as new_name, ... from table_name; 4. 运算符和表达式 算术运算符 +、-、*、/ 比较运算符 &gt;、&gt;=、&lt;、&lt;=、=、&lt;&gt; 逻辑运算符 and、or、not 优先级 not&gt;and&gt;or；比&gt;算 例： 12select salary+200 from salarys;select username from salarys where salary &gt; 800 and salary &lt;&gt; 1800; 5. 模糊查询使用通配符_或%，一个_只能代表一个字符，%可以代表0到多个任意字符。例： 123select * from users where username like &apos;a%&apos;;--以a开头select * from users where username like &apos;_a&apos;;--第二个字母是aselect * from users where username like &apos;%a%&apos;;--含有a 6. 范围查询范围查询使用in/not in或between and。例： 12select * from users where salary between 800 and 2000;--[800,2000]select * from users where username in (&apos;as&apos;,&apos;ad&apos;); 7. 查询结果排序12select column_name from table_name where [coditions]order by column_name desc|asc --降|升 8. case…when语句12345678910111213141516171819--用法1case column_namewhen value1 then result1,...[else resultn]end --例： select username,case username when &apos;aaa&apos; then &apos;计算机部门&apos; when &apos;bbb&apos; then &apos;市场部&apos; else &apos;其他部门&apos; end as 部门;--用法2:case搜索的行径casewhen column_name = value1then result1, ... [else resultn] end --例： select username,case when salary &lt; 800 then &apos;工资低&apos; when salary &gt; 5000 then &apos;工资高&apos; end as 工资水平 from users; 9. decode函数的使用1234decode (column_name,value1,result1,...,defaultvalue)--例：select username,decode (username,&apos;aaa&apos;,&apos;计算机部&apos;,&apos;bbb&apos;,&apos;市场部&apos;,&apos;其他&apos;)as 部门 from users;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统]]></title>
    <url>%2F2017%2F08%2F23%2FdataBase%2Fdb%2F</url>
    <content type="text"><![CDATA[数据库系统总结数据库，先对数据库系统的概念做一个整理 一、数据库数据库（Database）：相互之间有关联关系的数据的集合 数据库是电子化信息的集合 数据库起源于规范化表的处理 Table：以按行列形式组织及展现的数据 表名 表标题：列名 表内容： 行：元组/记录—row/tuple/record 列：字段/属性/数据项—column/field/attribute/dataitem 二、数据库系统数据库系统包含以下几个部分： 数据库（DB）：Database相互之间有关联关系的数据（table）的集合 数据库管理系统（DBMS）：Database Management System管理数据库的一种系统软件 数据库应用（DBAP）：DataBaseApplication针对于用户方便完成某功能的应用程序 数据库管理员（DBA）：DataBase Administrator使用DBMS 计算机系统 三、数据库管理系统从用户角度看： 数据库管理系统定义：定义数据库中Table的名称、标题等。定义语言：DDL 数据库管理系统操纵：向数据库的Table中增删改查、检索、统计等。操纵语言：DML 数据库管理系统控制：控制数据库中数据的使用权限（DBA控制）。控制语言：DCL 数据库管理系统维护：转储/恢复/重组/性能监测/分析数据库维护的实用程序，一般由DBA使用 四、数据库系统的标准结构数据库系统的标准结构就是三级模式两层映象 数据库系统的分层抽象：DBMS管理数据的三个层次 外部模式 External Level = User Level 某一用户能够看到与处理的数据，全面数据中的一部分 概念模式 Conceptual Level = Logic Level 从全局角度理解/管理的数据，含相应的关联约束 内部模式 Internal Leverl = Physical Level 存储在介质上的数据，含存储过程、存储方式、索引方式等 两层映象 E-CMapping External Schema - Conceptual Schema Mapping 将外模式映射为概念模式，数据概念视图向外部视图的转换，便于用户观察和使用 C-IMapping Conceptual Schema - Internal Schema Mapping 将概念模式映射为内部模式，数据概念视图向内部视图的转换，便于计算机进行存储和处理 数据（视图）与模式 模式（Schema） 对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息 视图（View）/数据（Data） 某一种表现形式下表现出来的数据库中的数据 两个独立性 逻辑数据独立性 当概念模式变化时，可以不改变外部模式（只需改变E-C），从而无需改变应用程序 物理数据独立性 当内部模式变化时，可以不改变概念模式（只需改变C-I），从而无需改变外部模式 五、数据模型 数据模型的概念 规定模式统一描述方式的模型，包括：数据结构、操作和约束 数据模型是对模式本身结构的抽象，模式是对数据本身结构形成的抽象 例：关系模型 所有模式都可为抽象表（Table）的形式[数据结构]，而每一个具体的模式都是拥有不同列名的具体的表 三大经典数据模型 关系模型：表的形式组织数据 层次模型：树的形式组织数据 网状模型：图的形式组织数据 六、数据库的发展由关系数据库到对象关系数据库、面向对象数据库以及XML数据库 关系数据库 按行按列形式组织数据：关系的第1范式 数据项的不可再分特性 关系运算：关系代数、元组演算、域演算—&gt;标准SQL 对象-关系数据库 可有效支持不满足关系第1范式的数据项 以对象来封装需分解的数据项 行对象与列对象，聚集对象与结构对象 面向对象数据库 面向对象技术（O-O）与集合/聚集操作技术（SQL）的结合 支持复杂的数据类型，数据封装与抽象数据结构 支持类、继承、封装、多态… XML数据库 半结构化数据库 数据与数据的语义合并在一起进行存储和处理 面向数据交换提出]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDBC数据库连接池]]></title>
    <url>%2F2017%2F08%2F22%2FdataBase%2Fjdbcconnection%2F</url>
    <content type="text"><![CDATA[java-JDBC数据库连接池Java语言通过JDBC技术访问数据库。JDBC是一种开放的方案，它为数据库应用开发人员﹑数据库前台工具开发人员提供了一种标准的应用程序设计接口，使开发人员可以用纯Java语言编写完整的数据库应用程序。JDBC提供两种API，分别是面向开发人员的API和面向底层的JDBC驱动程序API，底层主要通过直接的JDBC驱动和JDBC-ODBC桥驱动实现与数据库的连接 一、引言程序开发，存在很多问题：首先，每一次Web请求都要建立一次数据库连接。建立连接是一个费时的活动，每次都得花费0.05s～1s的时间，而且系统还要分配内存资源。这个时间对于一次或几次数据库操作，或许感觉不出系统有多大的开销。可是对于现在的Web应用，尤其是大型电子商务网站，同时有几百人甚至几千人在线是很正常的事。在这种情况下，频繁的进行数据库连接操作势必占用很多的系统资源，网站的响应速度必定下降，严重的甚至会造成服务器的崩溃。不是危言耸听，这就是制约某些电子商务网站发展的技术瓶颈问题。其次，对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将不得不重启数据库。还有，这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。问题的根源就在于对数据库连接资源的低效管理 二、连接池的基本工作原理1. 基本概念及原理对于共享资源，有一个很著名的设计模式：资源池（Resource Pool）。该模式正是为了解决资源的频繁分配﹑释放所造成的问题。为解决上述问题，可以采用数据库连接池技术。数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。更为重要的是我们可以通过连接池的管理机制监视数据库的连接的数量﹑使用情况，为系统开发﹑测试及性能调整提供依据 2. 服务器自带的连接池JDBC的API中没有提供连接池的方法。一些大型的WEB应用服务器如BEA的WebLogic和IBM的WebSphere等提供了连接池的机制，但是必须有其第三方的专用类方法支持连接池的用法 三、连接池关键问题分析1. 并发问题为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。这个问题相对比较好解决，因为Java语言自身提供了对并发管理的支持，使用synchronized关键字即可确保线程是同步的。使用方法为直接在类方法前面加上synchronized关键字，如： 1public synchronized Connection getConnection(); 2. 多数据库服务器和多用户对于大型的企业级应用，常常需要同时连接不同的数据库（如连接Oracle和Sybase）。如何连接不同的数据库呢？我们采用的策略是：设计一个符合单例模式的连接池管理类，在连接池管理类的唯一实例被创建时读取一个资源文件，其中资源文件中存放着多个数据库的url地址（&lt;poolName.url&gt;）﹑用户名（&lt;poolName.user&gt;）﹑密码（&lt;poolName.password&gt;）等信息。根据资源文件提供的信息，创建多个连接池类的实例，每一个实例都是一个特定数据库的连接池。连接池管理类实例为每个连接池实例取一个名字，通过不同的名字来管理不同的连接池 对于同一个数据库有多个用户使用不同的名称和密码访问的情况，也可以通过资源文件处理，即在资源文件中设置多个具有相同url地址，但具有不同用户名和密码的数据库连接信息 3. 事务处理我们知道，事务具有原子性，此时要求对数据库的操作符合ALL-ALL-NOTHING原则,即对于一组SQL语句要么全做，要么全不做 在Java语言中，Connection类本身提供了对事务的支持，可以通过设置Connection的AutoCommit属性为false，然后显式的调用commit或rollback方法来实现。但要高效的进行Connection复用，就必须提供相应的事务支持机制。可采用每一个事务独占一个连接来实现，这种方法可以大大降低事务管理的复杂性 4. 连接池的分配与释放连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。 对于连接的管理可使用空闲池。即把已经创建但尚未分配出去的连接按创建时间存放到一个空闲池中。每当用户请求一个连接时，系统首先检查空闲池内有没有空闲连接。如果有就把建立时间最长（通过容器的顺序存放实现）的那个连接分配给他（实际是先做连接是否有效的判断，如果可用就分配给用户，如不可用就把这个连接从空闲池删掉，重新检测空闲池是否还有连接）；如果没有则检查当前所开连接池是否达到连接池所允许的最大连接数（maxConn），如果没有达到，就新建一个连接，如果已经达到，就等待一定的时间（timeout）。如果在等待的时间内有连接被释放出来就可以把这个连接分配给等待的用户，如果等待时间超过预定时间timeout，则返回空值（null）。系统对已经分配出去正在使用的连接只做计数，当使用完后再返还给空闲池。对于空闲连接的状态，可开辟专门的线程定时检测，这样会花费一定的系统开销，但可以保证较快的响应速度。也可采取不开辟专门线程，只是在分配前检测的方法 5. 连接池的配置与维护连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConn）和最大连接数（maxConn）来控制连接池中的连接。最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过反复测试，找到最佳点。 如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。 四、连接池的实现1. 连接池模型连接池包括一个连接池类（DBConnectionPool）和一个连接池管理类（DBConnetionPoolManager） 连接池类是对某一数据库所有连接的缓冲池，主要实现以下功能： 从连接池获取或创建可用连接 使用完毕之后，把连接返还给连接池 在系统关闭前，断开所有连接并释放连接占用的系统资源 还能够处理无效连接（原来登记为可用的连接，由于某种原因不再可用，如超时，通讯问题），并能够限制连接池中的连接总数不低于某个预定值和不超过某个预定值 连接池管理类是连接池类的外覆类（wrapper）,符合单例模式，即系统中只能有一个连接池管理类的实例。其主要用于对多个连接池对象的管理，具有以下功能： 装载并注册特定数据库的JDBC驱动程序 根据属性文件给定的信息，创建连接池对象 为方便管理多个连接池对象，为每一个连接池对象取一个名字，实现连接池名字与其实例之间的映射 跟踪客户使用连接情况，以便需要是关闭连接释放资源。连接池管理类的引入主要是为了方便对多个连接池的使用和管理，如系统需要连接不同的数据库，或连接相同的数据库但由于安全性问题，需要不同的用户使用不同的名称和密码 2. 连接池实现连接池类和连接池管理类的主要属性及所要实现的基本接口： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DBConnectionPool implements TimerListener&#123; private int checkedOut;//已被分配出去的连接数 private ArrayList freeConnections=new ArrayList();//容器，空闲池，根据//创建时间顺序存放已创建但尚未分配出去的连接 private int minConn;//连接池里连接的最小数量 private int maxConn;//连接池里允许存在的最大连接数 private String name;//为这个连接池取个名字，方便管理 private String password;//连接数据库时需要的密码 private String url;//所要创建连接的数据库的地址 private String user;//连接数据库时需要的用户名 public Timer timer;//定时器 public DBConnectionPool(String name,String URL,String user,String password,int maxConn)//公开的构造函数 public synchronized void freeConnection(Connection con) //使用完毕之后，把连接返还给空闲池 public synchronized Connection getConnection(long timeout)//得到一个连接，timeout是等待时间 public synchronized void release()//断开所有连接，释放占用的系统资源 private Connection newConnection()//新建一个数据库连接 public synchronized void TimerEvent() //定时器事件处理函数 &#125; public class DBConnectionManager &#123; static private DBConnectionManager instance;//连接池管理类的唯一实例 static private int clients;//客户数量 private ArrayList drivers=new ArrayList();//容器，存放数据库驱动程序 private HashMap pools = new HashMap();//以name/value的形式存取连接池对象的名字及连接池对象 static synchronized public DBConnectionManager getInstance()/**如果唯一的实例instance已经创建，直接返回这个实例;否则，调用私有构造函数，创建连接池管理类的唯一实例*/ private DBConnectionManager()//私有构造函数,在其中调用初始化函数init() public void freeConnection(String name,Connection con)//释放一个连接，name是一个连接池对象的名字 public Connection getConnection(String name)//从名字为name的连接池对象中得到一个连接 public Connection getConnection(String name,long time)//从名字为name的连接池对象中取得一个连接，time是等待时间 public synchronized void release()//释放所有资源 private void createPools(Properties props)//根据属性文件提供的信息，创建一个或多个连接池 private void init()//初始化连接池管理类的唯一实例，由私有构造函数调用 private void loadDrivers(Properties props)//装载数据库驱动程序 &#125; 3. 连接池使用以Servlet为例说明连接池的使用： Servlet的生命周期是：在开始建立servlet时，调用其初始化（init）方法。之后每个用户请求都导致一个调用前面建立的实例的service方法的线程。最后，当服务器决定卸载一个servlet时，它首先调用该servlet的destroy方法 在初始化函数中生成连接池管理类的唯一实例（其中包括创建一个或多个连接池） 123public void init() throws ServletException&#123; connMgr=DBConnectionManager.getInstance(); &#125; 在service方法中通过连接池名称使用连接池，执行数据库操作。最后在destroy方法中释放占用的系统资源 1234public void destroy()&#123; connMgr.release(); super.destroy(); &#125; 五、一个经典的数据库连接池可以适用多数据库类型的应用以及一种数据库类型多个数据库且数据 库的数量可以动态增加的应用程序 1. 说明12345DBConnectionPool.java //数据库连接池类DBConnectionManager .java //数据库管理类DSConfigBean .java //单个数据库连接信息BeanParseDSConfig.java // 操作多(这个'多'包括不同的数据库和同一种数据库有多个数据库)数据 配置文件xmlds.config.xml //数据库配置文件xml 2. 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708//数据库连接池类import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.ArrayList;import java.util.Iterator;import java.util.Timer;public class DBConnectionPool implements TimerListener &#123; private Connection con=null; private int inUsed=0; //使用的连接数 private ArrayList freeConnections = new ArrayList();//容器，空闲连接 private int minConn; //最小连接数 private int maxConn; //最大连接 private String name; //连接池名字 private String password; //密码 private String url; //数据库连接地址 private String driver; //驱动 private String user; //用户名 public Timer timer; //定时 /** * */ public DBConnectionPool() &#123; // TODO Auto-generated constructor stub &#125; /** * 创建连接池 * @param driver * @param name * @param URL * @param user * @param password * @param maxConn */ public DBConnectionPool(String name, String driver,String URL, String user, String password, int maxConn) &#123; this.name=name; this.driver=driver; this.url=URL; this.user=user; this.password=password; this.maxConn=maxConn; &#125; /** * 用完，释放连接 * @param con */ public synchronized void freeConnection(Connection con) &#123; this.freeConnections.add(con);//添加到空闲连接的末尾 this.inUsed--; &#125; /** * timeout 根据timeout得到连接 * @param timeout * @return */ public synchronized Connection getConnection(long timeout) &#123; Connection con=null; if(this.freeConnections.size()&gt;0) &#123; con=(Connection)this.freeConnections.get(0); if(con==null)con=getConnection(timeout); //继续获得连接 &#125; else &#123; con=newConnection(); //新建连接 &#125; if(this.maxConn==0||this.maxConn&lt;this.inUsed) &#123; con=null;//达到最大连接数，暂时不能获得连接了。 &#125; if(con!=null) &#123; this.inUsed++; &#125; return con; &#125; /** * 从连接池里得到连接 */ public synchronized Connection getConnection()&#123; Connection con=null; if(this.freeConnections.size()&gt;0)&#123; con=(Connection)this.freeConnections.get(0); this.freeConnections.remove(0);//如果连接分配出去了，就从空闲连接里删除 if(con==null)con=getConnection(); //继续获得连接 &#125; else&#123; con=newConnection(); //新建连接 &#125; if(this.maxConn==0||this.maxConn&lt;this.inUsed)&#123; con=null;//等待 超过最大连接时 &#125; if(con!=null)&#123; this.inUsed++; System.out.println("得到 "+this.name+" 的连接，现有"+inUsed+"个连接在使用!"); &#125; return con; &#125; /** *释放全部连接 */ public synchronized void release()&#123; Iterator allConns=this.freeConnections.iterator(); while(allConns.hasNext())&#123; Connection con=(Connection)allConns.next(); try&#123; con.close(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125; this.freeConnections.clear(); &#125; /** * 创建新连接 * @return */ private Connection newConnection() &#123; try &#123; Class.forName(driver); con=DriverManager.getConnection(url, user, password); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); System.out.println("sorry can't find db driver!"); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); System.out.println("sorry can't create Connection!"); &#125; return con; &#125; /** * 定时处理函数 */ public synchronized void TimerEvent() &#123; //暂时还没有实现以后会加上的 &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub &#125; public String getDriver() &#123; return driver; &#125; public void setDriver(String driver) &#123; this.driver = driver; &#125; public int getMaxConn() &#123; return maxConn; &#125; public void setMaxConn(int maxConn) &#123; this.maxConn = maxConn; &#125; public int getMinConn() &#123; return minConn; &#125; public void setMinConn(int minConn) &#123; this.minConn = minConn; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUser() &#123; return user; &#125; public void setUser(String user) &#123; this.user = user; &#125;&#125;/*****************************************************************************///数据库连接池管理类import java.sql.Connection;import java.util.ArrayList;import java.util.Enumeration;import java.util.HashMap;import java.util.Hashtable;import java.util.Iterator;import java.util.Properties;import java.util.Vector;import com.chunkyo.db.ParseDSConfig;import com.chunkyo.db.DSConfigBean;import com.chunkyo.db.DBConnectionPool;public class DBConnectionManager &#123; static private DBConnectionManager instance;//唯一数据库连接池管理实例类 static private int clients; //客户连接数 private Vector drivers = new Vector();//驱动信息 private Hashtable pools=new Hashtable();//连接池 /** * 实例化管理类 */ public DBConnectionManager() &#123; // TODO Auto-generated constructor stub this.init(); &#125; /** * 得到唯一实例管理类 * @return */ static synchronized public DBConnectionManager getInstance() &#123; if(instance==null) &#123; instance=new DBConnectionManager(); &#125; return instance; &#125; /** * 释放连接 * @param name * @param con */ public void freeConnection(String name, Connection con) &#123; DBConnectionPool pool=(DBConnectionPool)pools.get(name);//根据关键名字得到连接池 if(pool!=null) pool.freeConnection(con);//释放连接 &#125; /** * 得到一个连接根据连接池的名字name * @param name * @return */ public Connection getConnection(String name) &#123; DBConnectionPool pool=null; Connection con=null; pool=(DBConnectionPool)pools.get(name);//从名字中获取连接池 con=pool.getConnection();//从选定的连接池中获得连接 if(con!=null) System.out.println("得到连接。。。"); return con; &#125; /** * 得到一个连接，根据连接池的名字和等待时间 * @param name * @param time * @return */ public Connection getConnection(String name, long timeout) &#123; DBConnectionPool pool=null; Connection con=null; pool=(DBConnectionPool)pools.get(name);//从名字中获取连接池 con=pool.getConnection(timeout);//从选定的连接池中获得连接 System.out.println("得到连接。。。"); return con; &#125; /** * 释放所有连接 */ public synchronized void release() &#123; Enumeration allpools=pools.elements(); while(allpools.hasMoreElements()) &#123; DBConnectionPool pool=(DBConnectionPool)allpools.nextElement(); if(pool!=null)pool.release(); &#125; pools.clear(); &#125; /** * 创建连接池 * @param props */ private void createPools(DSConfigBean dsb) &#123; DBConnectionPool dbpool=new DBConnectionPool(); dbpool.setName(dsb.getName()); dbpool.setDriver(dsb.getDriver()); dbpool.setUrl(dsb.getUrl()); dbpool.setUser(dsb.getUsername()); dbpool.setPassword(dsb.getPassword()); dbpool.setMaxConn(dsb.getMaxconn()); System.out.println("ioio:"+dsb.getMaxconn()); pools.put(dsb.getName(), dbpool); &#125; /** * 初始化连接池的参数 */ private void init() &#123; //加载驱动程序 this.loadDrivers(); //创建连接池 Iterator alldriver=drivers.iterator(); while(alldriver.hasNext()) &#123; this.createPools((DSConfigBean)alldriver.next()); System.out.println("创建连接池。。。"); &#125; System.out.println("创建连接池完毕。。。"); &#125; /** * 加载驱动程序 * @param props */ private void loadDrivers() &#123; ParseDSConfig pd=new ParseDSConfig(); //读取数据库配置文件 drivers=pd.readConfigInfo("ds.config.xml"); System.out.println("加载驱动程序。。。"); &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub &#125;&#125;/*****************************************************************************///配置文件Bean类public class DSConfigBean &#123; private String type =""; //数据库类型 private String name =""; //连接池名字 private String driver =""; //数据库驱动 private String url =""; //数据库url private String username =""; //用户名 private String password =""; //密码 private int maxconn =0; //最大连接数 /** * */ public DSConfigBean() &#123; // TODO Auto-generated constructor stub &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub &#125; /** * @return the driver */ public String getDriver() &#123; return driver; &#125; /** * @param driver the driver to set */ public void setDriver(String driver) &#123; this.driver = driver; &#125; /** * @return the maxconn */ public int getMaxconn() &#123; return maxconn; &#125; /** * @param maxconn the maxconn to set */ public void setMaxconn(int maxconn) &#123; this.maxconn = maxconn; &#125; /** * @return the name */ public String getName() &#123; return name; &#125; /** * @param name the name to set */ public void setName(String name) &#123; this.name = name; &#125; /** * @return the password */ public String getPassword() &#123; return password; &#125; /** * @param password the password to set */ public void setPassword(String password) &#123; this.password = password; &#125; /** * @return the type */ public String getType() &#123; return type; &#125; /** * @param type the type to set */ public void setType(String type) &#123; this.type = type; &#125; /** * @return the url */ public String getUrl() &#123; return url; &#125; /** * @param url the url to set */ public void setUrl(String url) &#123; this.url = url; &#125; /** * @return the username */ public String getUsername() &#123; return username; &#125; /** * @param username the username to set */ public void setUsername(String username) &#123; this.username = username; &#125;&#125;/*****************************************************************************///操作配置文件类读、写、修改、删除等操作 import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.util.List;import java.util.Vector;import java.util.Iterator;import org.jdom.Document;import org.jdom.Element;import org.jdom.JDOMException;import org.jdom.input.SAXBuilder;import org.jdom.output.Format;import org.jdom.output.XMLOutputter;public class ParseDSConfig &#123; /** * 构造函数 */ public ParseDSConfig() &#123; // TODO Auto-generated constructor stub &#125; /** * 读取xml配置文件 * @param path * @return */ public Vector readConfigInfo(String path) &#123; String rpath=this.getClass().getResource("").getPath().substring(1)+path; Vector dsConfig=null; FileInputStream fi = null; try &#123; fi=new FileInputStream(rpath);//读取路径文件 dsConfig=new Vector(); SAXBuilder sb=new SAXBuilder(); Document doc=sb.build(fi); Element root=doc.getRootElement(); List pools=root.getChildren(); Element pool=null; Iterator allPool=pools.iterator(); while(allPool.hasNext()) &#123; pool=(Element)allPool.next(); DSConfigBean dscBean=new DSConfigBean(); dscBean.setType(pool.getChild("type").getText()); dscBean.setName(pool.getChild("name").getText()); System.out.println(dscBean.getName()); dscBean.setDriver(pool.getChild("driver").getText()); dscBean.setUrl(pool.getChild("url").getText()); dscBean.setUsername(pool.getChild("username").getText()); dscBean.setPassword(pool.getChild("password").getText()); dscBean.setMaxconn(Integer.parseInt(pool.getChild("maxconn").getText())); dsConfig.add(dscBean); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (JDOMException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; fi.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return dsConfig; &#125;/** *修改配置文件 没时间写 过段时间再贴上去 其实一样的 */ public void modifyConfigInfo(String path,DSConfigBean dsb) throws Exception &#123; String rpath=this.getClass().getResource("").getPath().substring(1)+path; FileInputStream fi=null; //读出 FileOutputStream fo=null; //写入 &#125;/** *增加配置文件 * */ public void addConfigInfo(String path,DSConfigBean dsb) &#123; String rpath=this.getClass().getResource("").getPath().substring(1)+path; FileInputStream fi=null; FileOutputStream fo=null; try &#123; fi=new FileInputStream(rpath);//读取xml流 SAXBuilder sb=new SAXBuilder(); Document doc=sb.build(fi); //得到xml Element root=doc.getRootElement(); List pools=root.getChildren();//得到xml子树 Element newpool=new Element("pool"); //创建新连接池 Element pooltype=new Element("type"); //设置连接池类型 pooltype.setText(dsb.getType()); newpool.addContent(pooltype); Element poolname=new Element("name");//设置连接池名字 poolname.setText(dsb.getName()); newpool.addContent(poolname); Element pooldriver=new Element("driver"); //设置连接池驱动 pooldriver.addContent(dsb.getDriver()); newpool.addContent(pooldriver); Element poolurl=new Element("url");//设置连接池url poolurl.setText(dsb.getUrl()); newpool.addContent(poolurl); Element poolusername=new Element("username");//设置连接池用户名 poolusername.setText(dsb.getUsername()); newpool.addContent(poolusername); Element poolpassword=new Element("password");//设置连接池密码 poolpassword.setText(dsb.getPassword()); newpool.addContent(poolpassword); Element poolmaxconn=new Element("maxconn");//设置连接池最大连接 poolmaxconn.setText(String.valueOf(dsb.getMaxconn())); newpool.addContent(poolmaxconn); pools.add(newpool);//将child添加到root Format format = Format.getPrettyFormat(); format.setIndent(""); format.setEncoding("utf-8"); XMLOutputter outp = new XMLOutputter(format); fo = new FileOutputStream(rpath); outp.output(doc, fo); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (JDOMException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; &#125; &#125; /** *删除配置文件 */ public void delConfigInfo(String path,String name) &#123; String rpath=this.getClass().getResource("").getPath().substring(1)+path; FileInputStream fi = null; FileOutputStream fo=null; try &#123; fi=new FileInputStream(rpath);//读取路径文件 SAXBuilder sb=new SAXBuilder(); Document doc=sb.build(fi); Element root=doc.getRootElement(); List pools=root.getChildren(); Element pool=null; Iterator allPool=pools.iterator(); while(allPool.hasNext()) &#123; pool=(Element)allPool.next(); if(pool.getChild("name").getText().equals(name)) &#123; pools.remove(pool); break; &#125; &#125; Format format = Format.getPrettyFormat(); format.setIndent(""); format.setEncoding("utf-8"); XMLOutputter outp = new XMLOutputter(format); fo = new FileOutputStream(rpath); outp.output(doc, fo); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (JDOMException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fi.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub ParseDSConfig pd=new ParseDSConfig(); String path="ds.config.xml"; pd.readConfigInfo(path); //pd.delConfigInfo(path, "tj012006"); DSConfigBean dsb=new DSConfigBean(); dsb.setType("oracle"); dsb.setName("yyy004"); dsb.setDriver("org.oracle.jdbc"); dsb.setUrl("jdbc:oracle://localhost"); dsb.setUsername("sa"); dsb.setPassword(""); dsb.setMaxconn(1000); pd.addConfigInfo(path, dsb); pd.delConfigInfo(path, "yyy001"); &#125;&#125;/*****************************************************************************///ds.config.xml配置文件&lt;ds-config&gt;&lt;pool&gt;&lt;type&gt;mysql&lt;/type&gt;&lt;name&gt;user&lt;/name&gt;&lt;driver&gt;com.mysql.jdbc.driver&lt;/driver&gt;&lt;url&gt;jdbc:mysql://localhost:3306/user&lt;/url&gt;&lt;username&gt;sa&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;maxconn&gt;100&lt;/maxconn&gt;&lt;/pool&gt;&lt;pool&gt;&lt;type&gt;mysql&lt;/type&gt;&lt;name&gt;user2&lt;/name&gt;&lt;driver&gt;com.mysql.jdbc.driver&lt;/driver&gt;&lt;url&gt;jdbc:mysql://localhost:3306/user2&lt;/url&gt;&lt;username&gt;sa&lt;/username&gt;&lt;password&gt;1234&lt;/password&gt;&lt;maxconn&gt;10&lt;/maxconn&gt;&lt;/pool&gt;&lt;pool&gt;&lt;type&gt;sql2000&lt;/type&gt;&lt;name&gt;books&lt;/name&gt;&lt;driver&gt;com.microsoft.sqlserver.driver&lt;/driver&gt;&lt;url&gt;jdbc:sqlserver://localhost:1433/books:databasename=books&lt;/url&gt;&lt;username&gt;sa&lt;/username&gt;&lt;password&gt;&lt;/password&gt;&lt;maxconn&gt;100&lt;/maxconn&gt;&lt;/pool&gt;&lt;/ds-config&gt; 3. 连接池的使用 Connection的获得和释放 12345678DBConnectionManager connectionMan = DBConnectionManager.getInstance();//得到唯一实例//得到连接String name="mysql";//从上下文得到你要访问的数据库的名字Connection con=connectionMan.getConnection(name);/*使用 ......使用完毕*/connectionMan.freeConnection(name,con);//释放，但并未断开连接 数据库连接的动态增加和连接池的动态增加 调用xml操作增加类 重新实例华连接池管理池类]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库连接池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(十二)java操作数据库]]></title>
    <url>%2F2017%2F08%2F22%2Fjavase%2Fjava-conndata%2F</url>
    <content type="text"><![CDATA[java基础之连接数据库java访问数据库主要用的方法是JDBC，它是java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法 一、java访问数据库的步骤1. 加载数据库驱动加载就是把各个数据库提供的访问数据库的API加载到我们程序进来，加载JDBC驱动，并将其注册到DriverManager中，每一种数据库提供的数据库驱动不一样，加载驱动时要把jar包添加到lib文件夹下，一些主流数据库的JDBC驱动加裁注册的代码: 1234567891011121314//Oracle8/8i/9iO数据库(thin模式)Class.forName("oracle.jdbc.driver.OracleDriver").newInstance();//Sql Server7.0/2000数据库Class.forName("com.microsoft.jdbc.sqlserver.SQLServerDriver");//Sql Server2005/2008数据库Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");//DB2数据库Class.froName("com.ibm.db2.jdbc.app.DB2Driver").newInstance();//MySQL数据库 Class.forName("com.mysql.jdbc.Driver").newInstance(); 2. 建立连接建立数据库之间的连接是访问数据库的必要条件，建立连接对于不同数据库也是不一样的，一些主流数据库建立数据库连接，取得Connection对象的不同方式： 123456789101112131415161718192021//Oracle8/8i/9i数据库(thin模式)String url="jdbc:oracle:thin:@localhost:1521:orcl";String user="scott";String password="tiger";Connection conn=DriverManager.getConnection(url,user,password);//Sql Server7.0/2000/2005/2008数据库String url="jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=pubs";String user="sa";String password="";Connection conn=DriverManager.getConnection(url,user,password);//DB2数据库String url="jdbc:db2://localhost:5000/sample";String user="amdin"String password=-"";Connection conn=DriverManager.getConnection(url,user,password);//MySQL数据库String url="jdbc:mysql://localhost:3306/testDB?user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=gb2312";Connection conn=DriverManager.getConnection(url); 3. 执行SQL语句数据库连接建立好之后，接下来就是一些准备工作和执行sql语句了，准备工作要做的就是建立Statement对象PreparedStatement对象，例如： 123456789101112131415161718//建立Statement对象Statement stmt=conn.createStatement();//建立PreparedStatement对象String sql="select * from user where userName=? and password=?";PreparedStatement pstmt=Conn.prepareStatement(sql);pstmt.setString(1,"admin");pstmt.setString(2,"liubin");//做好准备工作之后就可以执行sql语句了，执行sql语句：String sql="select * from users";ResultSet rs=stmt.executeQuery(sql);//执行动态SQL查询ResultSet rs=pstmt.executeQuery();//执行insert update delete等语句，先定义sqlstmt.executeUpdate(sql); 4. 处理结果集访问结果记录集ResultSet对象。例如： 123while(rs.next)&#123;//...&#125; 5. 关闭数据库依次将ResultSet、Statement、PreparedStatement、Connection对象关 闭，释放所占用的资源。例如： 1234rs.close();stmt.clost();pstmt.close();con.close(); 二、JDBC事务事务，就是一组操作数据库的动作集合。事务是现代数据库理论中的核心概念之一。如果一组处理步骤或者全部发生或者一步也不执行，我们称该组处理步骤为一个事务。当所有的步骤像一个操作一样被完整地执行，我们称该事务被提交。由于其中的一部分或多步执行失败，导致没有步骤被提交，则事务必须回滚到最初的系统状态 事务必须服从ISO/IEC所制定的ACID原则 ACID是原子性（atomicity）表示事务执行过程中的任何失败都将导致事务所做的任何修改失效 一致性（consistency）表示 当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态 隔离性 （isolation）表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见 持久性（durability）表示当系统或介质发生故障时，确保已提交事务的更新不能丢失。持久性通过数据库备份和恢复来保证 JDBC 事务是用 Connection 对象控制的。JDBC Connection 接口( java.sql.Connection )提供了两种事务模式：自动提交和手工提交。 java.sql.Connection 提供了以下控制事务的方法： 1234public void setAutoCommit(boolean) public boolean getAutoCommit() public void commit() public void rollback() 使用 JDBC 事务界定时，可以将多个 SQL 语句结合到一个事务中。JDBC 事务的一个缺点是事务的范围局限于一个数据库连接。一个 JDBC 事务不能跨越多个数据库]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(十一)Swing]]></title>
    <url>%2F2017%2F08%2F21%2Fjavase%2Fjava-swing%2F</url>
    <content type="text"><![CDATA[java基础之SwingJ作为Swing组件的前缀，一些重要的组件： JFrame 窗体组件 JPanel 面板组件 JLabel 标签组件 JTextField 单行输入框组件 JButton 按钮组件 一、窗体Swing的窗体模型：Swing窗体中包含一个主容器，主容器中可以包含其他组件与子容器，子容器还可以有自己的组件与容器 123456789101112131415public class TestFrame extends JFrame&#123; public TestFrame()&#123; this.setBounds(50, 50, 50, 100);//设置窗口大小 this.setTitle("窗口标题"); this.setBackground(Color.BLACK);//窗口背景色 this.setAlwaysOnTop(true);//总是在最前面 this.setResizable(false);//不可调整大小 this.setDefaultCloseOperation(EXIT_ON_CLOSE);//点击关闭后退出程序 //注:如果不指定窗体的默认关闭行为是隐藏窗体而不是退出程序 this.setVisible(true);//可见 &#125; public static void main(String[] args) &#123; new TestFrame(); &#125;&#125; 二、布局管理器在进行布局嵌套时，一般选择JPanel作为子容器 1. 手工布局（null）null布局组件会一个像素不差的放在指定位置 12Container c = this.getContentPane();//获取主容器c.setLayout(null);//布局设为null 2. BorderLayout边框布局边框布局最多容纳5个组件，放置在上下左右中间方位，在将组件放入到容器时需要指定方位。JFrame主容器默认使用边框布局 123456Container c = this.getContentPane();//获取主容器c.add(new JButton("A"),BorderLayout.NORTH);c.add(new JButton("B"),BorderLayout.SOUTH);c.add(new JButton("C"),BorderLayout.WEST);c.add(new JButton("D"),BorderLayout.EAST);c.add(new JButton("E"),BorderLayout.CENTER); 3. FlowLayout流式布局流式布局会将组件按从左到右，从上到下排列，宽度不够会进行折行处理，可以在初始化布局管理器时选择左对齐、右对齐或居中对齐 1234Container c = this.getContentPane();//获取主容器c.setLayout(new FlowLayout(FlowLayout.CENTER));c.add(new JButton("A"));c.add(new JButton("B")); 4. GridLayout网格布局网格布局会将组件按行列排列，初始化时需要指定行数列数，并可以选择行间距与列间距 1234Container c = this.getContentPane();//获取主容器c.setLayout(new GridLayout(3,2,20,20));//3行2列，行列间距都为20c.add(new JButton("A"));c.add(new JButton("B")); 三、事件处理事件监听接口： ActionListener 通过鼠标或键盘选择按钮 MouseListener 监听鼠标按下、松开、移入、移出等事件 KeyListener 监听键盘按下、松开等事件 FocusListener 监听组件获取、失去焦点事件 WindowListener 监听窗体最大化、最小化、打开、关闭等事件，仅对JFrame有效 12345678910111213141516171819202122232425public class ClickAndExit extends JFrame&#123; JButton btnClose = new JButton("关闭"); //创建ActionListener接口的匿名实现类 ActionListener listener = new ActionListener()&#123; public void actionPerformed(ActionEvent e)&#123; System.exit(0); &#125; &#125;; public ClickAndExit()&#123; this.setBounds(50,50,250,250); Container c = this.getContentPane();//获取主容器 c.add(btnClose); //将监听加入按钮的监听器列表 btnClose.addActionListener(listener); //btnClose.addActionListener(new ActionListener()&#123; //还可以通过创建匿名对象的方式&#125;); this.setDefaultCloseOperation(EXIT_ON_CLOSE); this.setVisible(true); &#125; public static void main(String[] args)&#123; new ClickAndExit(); &#125;&#125; 四、其他组件1234567891011121314151617181920212223242526272829303132333435363738394041public class OtherFrame extends JFrame&#123; ButtonGroup bg = new ButtonGroup(); JRadioButton rbMale = new JRadioButton("男"); JRadioButton rbFemale = new JRadioButton("女"); public OtherFrame()&#123; bg.add(rbMale); bg.add(rbFemale); this.setBounds(50,50,250,250); Container c = this.getContentPane();//获取主容器 c.setLayout(new GridLayout(5,2,10,10)); //单选框 c.add(new JLabel("性别")); JPanel panelGender = new JPanel(); c.add(panelGender); panelGender.add(rbMale); panelGender.add(rbFemale); //复选框 c.add(new JLabel("爱好")); JPanel panelFav = new JPanel(); c.add(panelFav); panelFav.add(new JCheckBox("篮球")); panelFav.add(new JCheckBox("足球")); //下拉框 c.add(new JLabel("学历")); c.add(new JComboBox("小学，中学，大学".split(","))); //数字选择 c.add(new JLabel("年龄")); c.add(new JSpinner()); //数字滑动 c.add(new JLabel("年龄")); c.add(new JSLider(0,50,100)); this.setDefaultCloseOperation(EXIT_ON_CLOSE); this.setVisible(true); &#125;&#125; 五、内置对话框1. JOptionPane最常用的对话框，可用于弹出消框，输入框和选择框 12345678910public class Alert extends JFrame&#123; public static void main(String[] args)&#123; //输入框 String msg = JOptionPane.showInputDiglog("输入的话","默认值"); //选择框 int yesno = JOptionPane.showConfirmDialog(null,"你选择的是" + msg +"吗?"); //消息框 JOptionPane.showMessageDialog(null,msg); &#125;&#125; 2. JFileChooserJFileChooser可以选择磁盘上的文件，能够进行单选或多选，并返回结果 123456789101112public class FileCh extends JFrame&#123; public static void main(String[] args)&#123; JFileChooser jfc = new JFileChooser(); int result = jfc.showOpenDiaLog(null); if(result != JFileChooser.CANCEL_OPTION)&#123; File f = jfc.getSelectedFile(); System.out.println("你选择的文件是：" +f.getAbsolutePath()); &#125;else&#123; System.out.println("你取消了选择"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(十)网络编程]]></title>
    <url>%2F2017%2F08%2F20%2Fjavase%2Fjava-wangluobiancheng%2F</url>
    <content type="text"><![CDATA[java基础之网络编程网络编程就是在两个或两个以上的设备(例如计算机)之间传输数据。程序员所作的事情就是把数据发送到指定的位置，或者接收到指定的数据，这个就是狭义的网络编程范畴 一、网络基本概念 网络通信协议 计算机网络中实现通信的一些约定即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等指定的标准 网络通信接口 两个节点之间进行信息交流的接口，接口包括两部分： 硬件装置：实现节点之间的信息传送 软件装置：规定双方实现通信的约定协议 通信协议分层 协议的复合方式是层次方式，同层间可以通信，上一层可以调用下一层，与下下一层不发生关系，各层互不影响，利于系统的开发和扩展 IP协议 Internet Protocol协议网络层的主要协议，支持网间互连的数据报通信。它提供的主要功能有： 无连接数据报传送 数据报路由选择和差错控制 网络号+主机号分为a、b、c类网 端口 同一个ip地址上的不同的应用程序叫端口，分为TCP端口和UDP端口，TCP和UDP端口是分开的，分别有65536个 二、OSI模型OSI是Open System Interconnect，意为开放式系统互连，国际标准。 OSI TCP/IP 应用层 应用层 表示层 会话层 传输层 传输层(tcp/ip) 网络层 网络层（ip） 数据链路层 物理层 物理+数据链路层 1. 物理层2. 数据链路层3. 网络层4. 传输层5. 会话层6. 表示层7. 应用层三、TCP/UDP协议TCP是transmission control protocol缩写，是专门设计用于在不可靠的因特网上提供可靠的，端到端的字节流通信的协议，是一种面向连接的协议。TCP连接的是字节流而非报文流。TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。基于TCP/IP协议的应用程序分客户端和服务器端两部分 TCP/IP特点： TCP/IP协议仅支持点对点通信，同一台消息不能同时发给多台计算机 TCP/IP协议在通信前必须建立连接才能通信 在通信连接建立前，服务器端必须首先建立侦听，客户端才能发出连接请求。当连接建立后服务端和客户端都能发送、接收数据 TCP/IP协议会保证数据的正确性和传递的顺序，可靠性高 UDP是user data protocol缩写，是ODI模型中一种无连接的传输层协议，UDP不提供数据包分组、组装、排序，UDP向应用程序提供了一种发送封装的原始IP数据包的方法，并且发送时无需建立连接，是不可靠的连接，但传输性能很高。网络视频会议系统这种客户/服务器模式的网络应用使用的是UDP协议 TCP和UDP的区别： 使用UDP时，每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接 对于TCP协议，由于它是一个面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中多了一个连接建立的时间 使用UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内 TCP没有这方面的限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大量的数据 UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方 TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据 TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输 相比之下UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序 四、Socket两个应用程序可通过一个双向的网络通信连接实现数据交换，这个双向链路的一端称为socket socket用来实现client-server连接 java.net包中的Socket和ServerSocket分别实现client和server 建立连接时所需的寻址信息为远程计算机的IP地址和端口号 TCP-socketTCP-Socket通信模型： 示例1： 1234567891011121314151617181920212223242526272829//server端public class TCPServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket ss = new ServerSocket(6666); while(true) &#123; Socket s = ss.accept();//accept()阻塞式方法，没连接就一直等待 System.out.println("a client connect!"); DataInputStream dis = new DataInputStream(s.getInputStream()); System.out.println(dis.readUTF());//readUTF()也是阻塞式方法，同步式的， dis.close(); s.close(); &#125; &#125;&#125;//client端public class TCPClient &#123; public static void main(String[] args) throws Exception &#123; Socket s = new Socket("127.0.0.1", 6666); OutputStream os = s.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); Thread.sleep(30000); dos.writeUTF("hello server!"); dos.flush(); dos.close(); s.close(); &#125;&#125; 示例2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//点对点通讯public class Talkserver&#123; public static void main(String args[])&#123; try&#123; ServerSocket server = null; try&#123; server = new ServerSocket(4700); &#125;catch(Exception e)&#123; System.out.println("can not listen to:" + e); System.exit(0); &#125; Socket socket = null; try&#123; socket = server.accept(); &#125;catch(Exception e)&#123; System.out.println("Error:" + e); System.exit(0); &#125; String line; BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter os = new PrintWriter(socket.getOutputStream()); BufferedReader sin = new BufferedReader(new InputStreamReader(System.in)); System.out.println("Client:" + is.readLine()); line = sin.readLine(); while (!line.equals("bye")) &#123; os.println(line); os.flush(); System.out.println("Server:" + line); System.out.println("Client:" + is.readLine()); line = sin.readLine(); &#125; is.close(); os.close(); socket.close(); server.close(); &#125;catch(Exception e)&#123; System.out.println("Error" + e); &#125; &#125;&#125;public class Talkclient&#123; public static void main(String args[])&#123; try&#123; Socket socket = new Socket("127.0.0.1",4700); BufferedReader sin = new BufferedReader(new InputStreamReader(System.in)); PrintWriter os = new PrintWriter(socket.getOutputStream()); BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); String readline; readline = sin.readLine(); while (!readline.equals("bye")) &#123; os.println(readline); os.flush(); System.out.println("Client:" + readline); System.out.println("Server:" + is.readLine()); readline = sin.readLine(); &#125; os.close(); is.close(); socket.close(); &#125;catch(Exception e)&#123; System.out.println("Error" + e); &#125; &#125;&#125; UDP-socket示例： 12345678910111213141516171819202122232425262728293031323334//传输long类型public class TestUDPServer&#123; public static void main(String args[]) throws Exception&#123; byte buf[] = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf, buf.length); DatagramSocket ds = new DatagramSocket(5678); while(true)&#123; ds.receive(dp); ByteArrayInputStream bais = new ByteArrayInputStream(buf); DataInputStream dis = new DataInputStream(bais); System.out.println(dis.readLong()); &#125; &#125;&#125;public class TestUDPClient&#123; public static void main(String args[]) throws Exception&#123; long n = 10000L; ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(baos); dos.writeLong(n); byte[] buf = baos.toByteArray(); System.out.println(buf.length); DatagramPacket dp = new DatagramPacket(buf, buf.length, new InetSocketAddress("127.0.0.1", 5678)); DatagramSocket ds = new DatagramSocket(9999); ds.send(dp); ds.close(); &#125;&#125; 五、基于URL的网络编程 创建一个URL 为了表示URL， java.net中实现了类URL。我们可以通过下面的构造方法来初始化一个URL对象： 1234567891011121314public URL (String spec);//通过一个表示URL地址的字符串可以构造一个URL对象URL urlBase=new URL("http://www. 263.net/")public URL(URL context, String spec);//通过基URL和相对URL构造一个URL对象。URL net263=new URL ("http://www.263.net/");URL index263=new URL(net263, "index.html")public URL(String protocol, String host, String file);new URL("http", "www.gamelan.com", "/pages/Gamelan.net. html");public URL(String protocol, String host, int port, String file);URL gamelan=new URL("http", "www.gamelan.com", 80, "Pages/Gamelan.network.html"); 注意：类URL的构造方法都声明抛弃非运行时例外（MalformedURLException），因此生成URL对象时，我们必须要对这一例外进行处理，通常是用try-catch语句进行捕获 解析一个URL 一个URL对象生成后，其属性是不能被改变的，但是我们可以通过类URL所提供的方法来获取这些属性： 12345678910public String getProtocol() //获取该URL的协议名。public String getHost() //获取该URL的主机名。public int getPort() //获取该URL的端口号，如果没有设置端口，返回-1。public String getFile()// 获取该URL的文件名。public String getRef()// 获取该URL在文件中的相对位置。public String getQuery() //获取该URL的查询信息。public String getPath() //获取该URL的路径public String getAuthority() //获取该URL的权限信息public String getUserInfo() //获得使用者的信息 public String getRef()获得该URL的锚 从URL读取WWW网络资源 123456789101112//当我们得到一个URL对象后，就可以通过它读取指定的WWW资源。这时我们将使用URL的方法openStream()，其定义为：InputStream openStream(); openSteam()//与指定的URL建立连接并返回InputStream类的对象以从这一连接中读取数据。URL url = new URL("http://www.baidu.com");//使用openStream得到一输入流并由此构造一个BufferedReader对象BufferedReader br = new BufferedReader(new InputStreamReader( url.openStream()));String line = null;while(null != (line = br.readLine()))&#123; System.out.println(line);&#125;br.close(); 六、客户端/服务端编程1. 客户端1） 建立网络连接 客户端网络编程的第一步都是建立网络连接。在建立网络连接时需要指定连接到的服务器的IP地址和端口号，建立完成以后，会形成一条虚拟的连接，后续的操作就可以通过该连接实现数据交换了。 2） 交换数据 连接建立以后，就可以通过这个连接交换数据了。交换数据严格按照请求响应模型进行，由客户端发送一个请求数据到服务器，服务器反馈一个响应数据给客户端，如果客户端不发送请求则服务器端就不响应。 根据逻辑需要，可以多次交换数据，但是还是必须遵循请求响应模型。 3） 关闭网络连接 在数据交换完成以后，关闭网络连接，释放程序占用的端口、内存等系统资源，结束网络编程。 最基本的步骤一般都是这三个步骤，在实际实现时，步骤2会出现重复，在进行代码组织时，由于网络编程是比较耗时的操作，所以一般开启专门的现场进行网络通讯。 2. 服务端（1） 监听端口 服务器端属于被动等待连接，所以服务器端启动以后，不需要发起连接，而只需要监听本地计算机的某个固定端口即可。 这个端口就是服务器端开放给客户端的端口，服务器端程序运行的本地计算机的IP地址就是服务器端程序的IP地址。 2） 获得连接 当客户端连接到服务器端时，服务器端就可以获得一个连接，这个连接包含客户端的信息，例如客户端IP地址等等，服务器端和客户端也通过该连接进行数据交换。 一般在服务器端编程中，当获得连接时，需要开启专门的线程处理该连接，每个连接都由独立的线程实现。 3）交换数据 服务器端通过获得的连接进行数据交换。服务器端的数据交换步骤是首先接收客户端发送过来的数据，然后进行逻辑处理，再把处理以后的结果数据发送给客户端。简单来说，就是先接收再发送，这个和客户端的数据交换数序不同。 其实，服务器端获得的连接和客户端连接是一样的，只是数据交换的步骤不同。 当然，服务器端的数据交换也是可以多次进行的。 在数据交换完成以后，关闭和客户端的连接。 4）关闭连接 当服务器程序关闭时，需要关闭服务器端，通过关闭服务器端使得服务器监听的端口以及占用的内存可以释放出来，实现了连接的关闭。 3. 一个基础的网络类——InetAddress类该类的功能是代表一个IP地址，并且将IP地址和域名相关的操作方法包含在该类的内部。注： InetAddress 类没有明显的构造函数。为生成一个InetAddress对象，必须运用一个可用的工厂方法 工厂方法（factory method）仅是一个类中静态方法返回一个该类实例的约定。对于InetAddress，三个方法 getLocalHost( )、getByName( )以及getAllByName( )可以用来创建InetAddress的实例 如果这些方法不能解析主机名，它们引发一个UnknownHostException异常 七、TCP编程java.net.Socket类代表客户端连接，以java.net.ServerSocket类代表服务器端连接。在进行网络编程时，底层网络通讯的细节已经实现了比较高的封装，所以在程序员实际编程时，只需要指定IP地址和端口号码就可以建立连接了 1. 客户端1) 建立Socket连接 1Socket socket = new Socket(“www.sohu.com”,80); 2）按照“请求-响应”模型进行网络数据交换 在Java语言中，数据传输功能由Java IO实现，也就是说只需要从连接中获得输入流和输出流即可，然后将需要发送的数据写入连接对象的输出流中，在发送完成以后从输入流中读取数据即可。示例代码如下： 12OutputStream os = socket1.getOutputStream(); //获得输出流InputStream is = socket1.getInputStream(); //获得输入流 这里获得的只是最基本的输出流和输入流对象，还可以根据前面学习到的IO知识，使用流的嵌套将这些获得到的基本流对象转换成需要的装饰流对象，从而方便数据的操作。 3）关闭网络连接 1socket1.close(); 2. 服务端1）监听端口 1ServerSocket ss = new ServerSocket(10000); 2）获得连接 当有客户端连接到达时，建立一个和客户端连接对应的Socket连 接对象，从而释放客户端连接对于服务器端端口的占用 1Socket socket = ss.accept(); 该代码实现的功能是获得当前连接到服务器端的客户端连接。需要说明的是accept和前面IO部分介绍的read方法一样，都是一个阻塞方法，也就是当无连接时，该方法将阻塞程序的执行，直到连接到达时才执行该行代码。另外获得的连接会在服务器端的该端口注册，这样以后就可以通过在服务器端的注册信息直接通信，而注册以后服务器端的端口就被释放出来，又可以继续接受其它的连接了 3）按照“请求-响应”模型进行网络数据交换 这里获得的Socket类型的连接就和客户端的网络连接一样了，只是服务器端需要首先读取发送过来的数据，然后进行逻辑处理以后再发送给客户端，也就是交换数据的顺序和客户端交换数据的步骤刚好相反 12InputStream is = ss.getInputStream(); //获得输入流OutputStream os = ss.getOutputStream(); //获得输出流 4)关闭服务器端连接 1ss.close(); 八、UDP编程用户数据报协议使用该种方式无需建立专用的虚拟连接，由于无需建立专用的连接，所以对于服务器的压力要比TCP小很多，所以也是一种常见的网络编程方式。但是使用该种方式最大的不足是传输不可靠，当然也不是说经常丢失，就像大家发短信息一样，理论上存在收不到的可能 在Java API中，实现UDP方式的编程，包含客户端网络编程和服务器端网络编程，主要由两个类实现，分别是： DatagramSocket DatagramSocket类实现“网络连接”，包括客户端网络连接和服务器端网络连接。虽然UDP方式的网络通讯不需要建立专用的网络连接，但是毕竟还是需要发送和接收数据，DatagramSocket实现的就是发送数据时的发射器，以及接收数据时的监听器的角色。类比于TCP中的网络连接，该类既可以用于实现客户端连接，也可以用于实现服务器端连接 DatagramPacket DatagramPacket类实现对于网络中传输的数据封装，也就是说，该类的对象代表网络中交换的数据。在UDP方式的网络编程中，无论是需要发送的数据还是需要接收的数据，都必须被处理成DatagramPacket类型的对象，该对象中包含发送到的地址、发送到的端口号以及发送的内容等。其实DatagramPacket类的作用类似于现实中的信件，在信件中包含信件发送到的地址以及接收人，还有发送的内容等，邮局只需要按照地址传递即可。在接收数据时，接收到的数据也必须被处理成DatagramPacket类型的对象，在该对象中包含发送方的地址、端口号等信息，也包含数据的内容。和TCP方式的网络传输相比，IO编程在UDP方式的网络编程中变得不是必须的内容，结构也要比TCP方式的网络编程简单一些 1. 客户端1）建立连接： 12DatagramSocket ds = new DatagramSocket();//该客户端连接使用系统随机分配的一个本地计算机的未用端口号DatagramSocket ds = new DatagramSocket(5000);//一般在建立客户端连接时没有必要指定端口号码。 2）发送数据 在发送数据时，需要将需要发送的数据内容首先转换为byte数组，然后将数据内容、服务器IP和服务器端口号一起构造成一个DatagramPacket类型的对象，这样数据的准备就完成了了，发送时调用网络连接对象中的send方法发送该对象即可 3）UDP客户端编程中接收数据 首先构造一个数据缓冲数组，该数组用于存储接收的服务器端反馈数据，该数组的长度必须大于或等于服务器端反馈的实际有效数据的长度。然后以该缓冲数组为基础构造一个DatagramPacket数据包对象，最后调用连接对象的receive方法接收数据即可。接收到的服务器端反馈数据存储在DatagramPacket类型的对象内部 4）关闭连接 1ds.close(); 2. 服务端1）首先UDP方式服务器端网络编程需要建立一个连接，该连接监听某个端口： 1DatagramSocket ds = new DatagramSocket(10010);//由于服务器端的端口需要固定，所以一般在建立服务器端连接时，都指定端口号 2）接收客户端发送过来的数据 其接收的方法和客户端接收的方法一致，其中receive方法的作用类似于TCP方式中accept方法的作用，该方法也是一个阻塞方法，其作用是接收数据 1ds.receive();//接收数据。 接收到客户端发送过来的数据以后，服务器端对该数据进行逻辑处理，然后将处理以后的结果再发送给客户端，在这里发送时就比客户端要麻烦一些，因为服务器端需要获得客户端的IP和客户端使用的端口号，这个都可以从接收到的数据包中获得。示例代码如下： 1234//获得客户端的IPInetAddress clientIP = receiveDp.getAddress();//获得客户端的端口号Int clientPort = receiveDp.getPort(); 3)关闭连接 1ds.close()]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(九)多线程]]></title>
    <url>%2F2017%2F08%2F17%2Fjavase%2Fjava-thread%2F</url>
    <content type="text"><![CDATA[java基础之多线程线程是程序内的顺序控制流。一个程序里面不同的执行路径 多线程指的是在单个程序中可以同时运行多个同的线程执行不同的任务，只能使用分配给序的资源和环境 一、线程与进程的区别 进程 进程只是一个静态概念，机器上的一个class文件，机器上的一个exe文件等这些叫进程 线程与进程的区别 多个进程的内部数据和状态都是完全独立的,而多线程是共享一块内存空间和一组系统资源,有可能互相影响。线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换比进程切换的负担要小 每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销 线程可以看成是轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序技术器（pc），线程切换的开销小 多进程：在操作系统中能同时运行多个任务（程序） 多线程：在同一应用程序中有多个顺序流同时执行 多线程编程的目的 多线程编程的目的，就是最大限度地利用CPU资源 ，当某一线程的处理不需要占用CPU而只和I/O等资源打交道时，让需要占用CPU资源的其它线程有机会获得CPU资源。从根本上说，这就是多线程编程的最终目的 细节 真正的多线程是存在多个cpu多核系统中的，指的是当前时间点有多个线程同步执行 对于单核CPU来说，某一时刻只能有一个线程在执行（微观串行），从宏观角度来看，多个线程在同时执行（宏观并行） 单核的多线程 体现：因为cpu执行速度很快，它可以将多个线程在空闲时刻执行，达到多线程效果，但这不是真正的多线程 对于双核或双核以上的CPU来说，可以真正做到微观并行。 单进程，dos是单进程的 一个进程至少要包含一个线程 Java中如果我们自己没有产生线程，那么系统就会给我们产生一个线程（主线程，main方法就在主线程上运行），我们的程序都是由线程来执行的 二、java的线程实现java的线程是通过java.lang.Thread类来实现的。VM启动时会有main方法定义的线程。可以通过创建Thread的实例来创建新的线程。线程的实现有两种方式，第一种方式是继承Thread类，然后重写run方法；第二种是实现Runnable接口，然后实现其run方法。将我们希望线程执行的代码放到run方法中，然后通过start方法来启动线程，start方法首先为线程的执行准备好系统资源，然后再去调用run方法。当某个类继承了Thread类之后，该类就叫做一个线程类。 1. 线程实现Runnable接口 定义线程类实现Runnable接口 创建自己的线程类对象 1Thread myThread = new Thread(target);//target为Runnable接口类型 Runnable中只有一个方法： 1public void run()；//用于定义线程运行体 使用Runnable接口可以为多个线程提供共享的数据 在实现Runnable接口的类的run方法定义中可以使用Thread的静态方法 1public static Thread currentThread();//获取当前线程的引用 代码体现： 1234567891011121314151617181920public class TestThread &#123; public static void main(String args[]) &#123; Runner1 r = new Runner1(); //r.start(); //r.run(); Thread t = new Thread(r); t.start(); for(int i=0; i&lt;100; i++) &#123; System.out.println("Main Thread:------" + i); &#125; &#125;&#125;class Runner1 implements Runnable &#123; public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println("Runner1 :" + i); &#125; &#125;&#125; start方法和run方法的区别： start方法叫启动线程，上面的代码用start方法的结果： 由于start方法启动了一个线程，所以该线程和main方法交替执行 run方法叫方法调用，上面的代码用run方法的结果： run称为方法调用，当该方法执行完才继续进行main方法执行 2. 线程实现Thread子类 定义一个Thread的子类并重写其run方法 12345class MyThread extends Thread &#123; public void run()&#123; ... &#125;&#125; 然后生成该类的对象 1MyThread myThread = new MyThread(...); 代码体现： 123456789101112131415161718public class TestThread &#123; public static void main(String args[]) &#123; Runner1 r = new Runner1(); r.start(); //r.run(); for(int i=0; i&lt;100; i++) &#123; System.out.println("Main Thread:------" + i); &#125; &#125;&#125;class Runner1 extends Thread &#123; public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println("Runner1 :" + i); &#125; &#125;&#125; 3. 两种实现方法细节接口比较灵活，能使用接口最好使用接口，使用接口还可以从其他类继承，但使用继承只能单继承 4. Thread Thread类也实现了Runnable接口，因此实现了Runnable接口中的run方法； 当生成一个线程对象时，如果没有为其设定名字，那么线程对象的名字将使用如下形式：Thread-number,该number将是自动增加的，并被所有的Thread对象所共享（因为它是static的成员变量）。 当使用第一种方式来生成线程对象时，我们需要重写run方法，因为Thread类的run方法此时什么事情也不做。 当使用第二种方式生成线程对象时，我们需要实现Runnable接口的run方法，然后使用new Thread（new MyThread（））（假如MyThread已经实现了Runnable接口）来生成线程对象，这时的线程对象的run方法或调就会MyThread类的run方法，这样我们自己编写的run方法就执行了。 说明： 1234567Public void run()&#123;If(target!=null)&#123;Target.run();&#125;&#125; 当使用继承Thread生成线程对象时，target为空，什么也不执行，当使用第二种方式生成时，执行target.run（），target为runnable的实例对象，即为执行重写后的方法 总结：两种生成线程对象的区别： 两种方法均需执行线程的start方法为线程分配必须的系统资源、调度线程运行并执行线程的run方法 在具体应用中，采用哪种方法来构造线程体要视情况而定。通常，当一个线程已继承了另一个类时，就应该用第二种方法来构造，即实现Runnable接口。 三、线程的状态 线程控制基本方法： 123456789isAlive();//判断线程是否还活着（未终止）getPriority();//获得线程的优先级数值setPriority();//设置线程的优先级数值Thread.sleep();//将当前线程睡眠指定毫秒数join();//调用某线程的该方法，将当前线程与该线程合并，即等待该线程结束，再恢复当前线程的运行yield();//让出cpu，当前线程进入就绪队列等待调度wait();//当前线程进入对象的wait poolnotify();//唤醒对象的wait poll中的一个线程notifyAll();//唤醒对象的wait poll中的所有线程 1. sleep方法1public static void sleep(long millis) throwsInterruptedException&#123;&#125; 123456789101112131415161718192021222324public class TestInterrupt &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); try &#123;Thread.sleep(10000);&#125;//主线程休眠10秒钟后起来 catch (InterruptedException e) &#123;&#125; thread.interrupt(); //打断休眠 //thread.flag = false; &#125;&#125;class MyThread extends Thread &#123; boolean flag = true; public void run()&#123; while(flag)&#123; System.out.println("==="+new Date()+"==="); try &#123; sleep(1000);//一秒钟输出一次当前时间 &#125; catch (InterruptedException e) &#123; return;//主线程起来则该线程被打断，捕获到异常则return结束 &#125; &#125; &#125;&#125; 2. join方法123456789101112131415161718192021222324252627282930package Thread;public class TestJoin &#123; public static void main(String[] args) &#123; MyThread2 t1 = new MyThread2("abcde"); t1.start(); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123;&#125; for(int i=1;i&lt;=10;i++)&#123; System.out.println("i am main thread"); &#125; &#125;&#125;class MyThread2 extends Thread &#123; MyThread2(String s)&#123; super(s); &#125; public void run()&#123; for(int i =1;i&lt;=10;i++)&#123; System.out.println("i am "+getName()); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; return; &#125; &#125; &#125;&#125; 3. yield方法123456789101112131415161718192021public class TestYield &#123; public static void main(String[] args) &#123; MyThread3 t1 = new MyThread3("t1"); MyThread3 t2 = new MyThread3("t2"); t1.start(); t2.start(); &#125;&#125;class MyThread3 extends Thread &#123; MyThread3(String s)&#123; super(s); &#125; public void run()&#123; for(int i =1;i&lt;=100;i++)&#123; System.out.println(getName()+": "+i); if(i%10==0)&#123; yield(); &#125; &#125; &#125;&#125; 4. wait和notify wait与notify方法都是定义在Object类中，而且是final的，因此会被所有的Java类所继承并且无法重写。这两个方法要求在调用时线程应该已经获得了对象的锁，因此对这两个方法的调用需要放在synchronized方法或块当中 当线程执行了wait方法时，它会释放掉对象的锁 另一个会导致线程暂停的方法就是Thread类的sleep方法，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的 notify():唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者： 通过执行此对象的同步实例方法 通过执行在此对象上进行同步的 synchronized 语句的正文 对于 Class 类型的对象，可以通过执行该类的同步静态方法 一次只能有一个线程拥有对象的监视器。 5. 关于成员变量与局部变量 如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的（也就是说一个线程对成员变量的改变会影响到另一个线程） 如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝，一个线程对该局部变量的改变不会影响到其他的线程 6. 线程优先级线程优先级范围是1到10，缺省是5 123Thread.MIN_PRIORITY = 1;Thread.MAX_PRIORITY = 10;Thread.NORM_PRIORITY = 5; 12345678910111213141516171819202122232425public class TestPriority &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(new T1()); Thread t2 = new Thread(new T2()); t1.setPriority(Thread.NORM_PRIORITY + 3); t1.start(); t2.start(); &#125;&#125;class T1 implements Runnable &#123; public void run() &#123; for(int i=0; i&lt;1000; i++) &#123; System.out.println("T1: " + i); &#125; &#125;&#125;class T2 implements Runnable &#123; public void run() &#123; for(int i=0; i&lt;1000; i++) &#123; System.out.println("------T2: " + i); &#125; &#125;&#125; 7. 面试：wait和sleep的区别 wait时别的线程可以访问锁定对象，调用wait方法（Object的方法）时候必须锁定该对象，等待时会丢掉锁 sleep时别的线程不可以访问锁定对象，睡着也会抱着锁 四、线程的生命周期 由上图可以看出，一个线程由出生到死亡分为五个阶段： 1. 创建状态 当用new操作符创建一个新的线程对象时，该线程处于创建状态 处于创建状态的线程只是一个空的线程对象，系统不为它分配资源 2. 可运行状态 执行线程的start()方法将为线程分配必须的系统资源，安排其运行，并调用线程体—run()方法，这样就使得该线程处于可运行( Runnable )状态 这一状态并不是运行中状态（Running )，因为线程也许实际上并未真正运行 3. 不可运行状态当发生下列事件时，处于运行状态的线程会转入到不可运行状态 调用了sleep（）方法； 线程调用wait方法等待特定条件的满足 线程输入/输出阻塞 4. 返回可运行状态 处于睡眠状态的线程在指定的时间过去后 如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变 如果线程是因为输入/输出阻塞，等待输入/输出完成 5. 消亡状态当线程的run方法执行结束后，该线程自然消亡。 注意： 停止线程的方式：不能使用Thread类的stop方法来终止线程的执行。一般要设定一个变量，在run方法中是一个循环，循环每次检查该变量，如果满足条件则继续执行，否则跳出循环，线程结束。 不能依靠线程的优先级来决定线程的执行顺序。 五、线程同步实现线程同步的方法就是加锁，synchronized关键字修饰，表示该对象在任意时刻只能由一个线程访问。当synchronized关键字修饰一个方法的时候，该方法叫做同步方法 多线程并发是线程同步中比较常见的现象，java多线程为了避免多线程并发解决多线程共享数据同步问题提供了synchronized关键字 synchronized关键字： Java中的每个对象都有一个锁（lock）或者叫做监视器（monitor），当访问某个对象的synchronized方法时，表示将该对象上锁，此时其他任何线程都无法再去访问该synchronized方法了，直到之前的那个线程执行方法完毕后（或者是抛出了异常），那么将该对象的锁释放掉，其他线程才有可能再去访问该synchronized方法 如果一个对象有多个synchronized方法，某一时刻某个线程已经进入到了某个synchronized方法，那么在该方法没有执行完毕前，其他线程是无法访问该对象的任何synchronized方法的 如果某个synchronized方法是static的，那么当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在的对象所对应的Class对象，因为Java中无论一个类有多少个对象，这些对象会对应唯一一个Class对象，因此当线程分别访问同一个类的两个对象的两个static，synchronized方法时，他们的执行顺序也是顺序的，也就是说一个线程先去执行方法，执行完毕后另一个线程才开始执行 synchronized块，写法： 1234synchronized(object)&#123;//表示线程在执行的时候会对object对象上锁&#125; synchronized方法是一种粗粒度的并发控制，某一时刻，只能有一个线程执行该synchronized方法;synchronized块则是一种细粒度的并发控制，只会将块中的代码同步，位于方法内、synchronized块之外的代码是可以被多个线程同时访问到的 同步的线程状态图： 线程同步实例1123456789101112131415161718192021222324252627282930//非线程同步public class TestSync implements Runnable &#123; Timer timer = new Timer(); public static void main(String[] args) &#123; TestSync test = new TestSync(); Thread t1 = new Thread(test); Thread t2 = new Thread(test); t1.setName("t1"); t2.setName("t2"); t1.start(); t2.start(); &#125; public void run()&#123; timer.add(Thread.currentThread().getName()); &#125;&#125;class Timer&#123; private static int num = 0; public synchronized void add(String name)&#123; num ++; try &#123;Thread.sleep(1);&#125; catch (InterruptedException e) &#123;&#125; System.out.println(name+", 你是第"+num+"个使用timer的线程"); &#125;&#125;/*结果： t1, 你是第2个使用timer的线程 t2, 你是第2个使用timer的线程*/ 线程同步实例21234567891011121314151617181920212223242526272829303132333435363738394041424344//死锁public class TestDeadLock implements Runnable &#123; public int flag = 1; static Object o1 = new Object(), o2 = new Object(); public void run() &#123;System.out.println("flag=" + flag); if(flag == 1) &#123; synchronized(o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o2) &#123;//td1锁住o1之后，只要再锁住o2就完成了 System.out.println("1"); &#125; &#125; &#125; if(flag == 0) &#123; synchronized(o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized(o1) &#123;//td1锁住o2之后，只要再锁住o1就完成了 System.out.println("0"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; TestDeadLock td1 = new TestDeadLock(); TestDeadLock td2 = new TestDeadLock(); td1.flag = 1; td2.flag = 0; Thread t1 = new Thread(td1); Thread t2 = new Thread(td2); t1.start(); t2.start(); &#125;&#125; 线程同步实例31234567891011121314151617181920212223242526272829303132//面试：m1执行过程中m2能执行吗？public class TT implements Runnable &#123; int b = 100; public synchronized void m1() throws Exception&#123; b = 1000; Thread.sleep(5000); System.out.println("b = " + b); &#125; public void m2() throws Exception &#123; System.out.println(b); &#125; public void run() &#123; try &#123; m1(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; TT tt = new TT(); Thread t = new Thread(tt); t.start(); tt.m2();//若输出为100则说明m2不能执行，为1000（m1改为1000）则m2可以执行 &#125;&#125;/*结果： 1000*/ 线程同步实例412345678910111213141516171819202122232425262728293031323334353637//卧槽，晕了似懂非懂啊：m1加锁，m2加锁与不加锁的执行过程public class TT implements Runnable &#123; int b = 100; public synchronized void m1() throws Exception&#123; b = 1000; Thread.sleep(5000); System.out.println("b = " + b); &#125; //public synchronized void m2() throws Exception &#123;//m2加锁执行过程2 public void m2() throws Exception &#123; //m2不加锁执行过程1 Thread.sleep(2500); b = 2000; &#125; public void run() &#123; try &#123; m1(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; TT tt = new TT(); Thread t = new Thread(tt); t.start(); tt.m2(); System.out.println(tt.b); &#125;&#125;/*结果： 执行过程1---m2不加锁：m1锁定过程中m2可以执行，将b的值设为2000，所以tt.b输出2000，m1休眠之后中输出b=2000 执行过程2---m2加锁：tt.m2()方法执行完后m1方法才执行（m1执行时m2执行不了），将b的值设为1000，所以tt.b输出1000，m1中输出b=1000 结论：当两个方法修改同一个值时都应该加锁保持同步*/ 六、死锁问题定义：线程1锁住了对象A的监视器，等待对象B的监视器，线程2锁住了对象B的监视器，等待对象A的监视器，就造成了死锁。 导致死锁的根源在于不适当地运用“synchronized”关键词来管理线程对特定对象的访问。“synchronized”关键词的作用是，确保在某个时刻只有一个线程被允许执行特定的代码块，因此，被允许执行的线程首先必须拥有对变量或对象的排他性访问权。当线程访问对象时，线程会给对象加锁 Java中每个对象都有一把锁与之对应。但Java不提供单独的lock和unlock操作。下面分析死锁的两个过程“上锁”和“锁死” 上锁许多线程在执行中必须考虑与其他线程之间共享数据或协调执行状态，就需要同步机制。因此大多数应用程序要求线程互相通信来同步它们的动作，在 Java 程序中最简单实现同步的方法就是上锁。在 Java 编程中，所有的对象都有锁。线程可以使用synchronized 关键字来获得锁。在任一时刻对于给定的类的实例，方法或同步的代码块只能被一个线程执行。这是因为代码在执行之前要求获得对象的锁。 为了防止同时访问共享资源，线程在使用资源的前后可以给该资源上锁和开锁。给共享变量上锁就使得 Java 线程能够快速方便地通信和同步。某个线程若给一个对象上了锁，就可以知道没有其他线程能够访问该对象。即使在抢占式模型中，其他线程也不能够访问此对象，直到上锁的线程被唤醒、完成工作并开锁。那些试图访问一个上锁对象的线程通常会进入睡眠状态，直到上锁的线程开锁。一旦锁被打开，这些睡眠进程就会被唤醒并移到准备就绪队列中。 锁死如果程序中有几个竞争资源的并发线程,那么保证均衡是很重要的。系统均衡是指每个线程在执行过程中都能充分访问有限的资源，系统中没有饿死和死锁的线程。当多个并发的线程分别试图同时占有两个锁时，会出现加锁冲突的情形。如果一个线程占有了另一个线程必需的锁，互相等待时被阻塞就有可能出现死锁。 在编写多线程代码时，笔者认为死锁是最难处理的问题之一。因为死锁可能在最意想不到的地方发生，所以查找和修正它既费时又费力。例如，常见的例子如下面这段程序 12345678910111213public int sumArrays(int[] a1, int[] a2)&#123; int value = 0; int size = a1.length; if (size == a2.length) &#123; synchronized(a1) &#123; //1 synchronized(a2) &#123; //2 for (int i=0; i&lt;size; i++) value += a1[i] + a2[i]; &#125; &#125; &#125; return value;&#125; 这段代码在求和操作中访问两个数组对象之前锁定了这两个数组对象。它形式简短，编写也适合所要执行的任务；但不幸的是，它有一个潜在的问题。这个问题就是它埋下了死锁的种子 ThreadLocal类首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象另外，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题 八、生产者消费者问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class ProducerConsumer &#123; public static void main(String[] args) &#123; SyncStack ss = new SyncStack(); Producer p = new Producer(ss); Consumer c = new Consumer(ss); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(c).start(); &#125;&#125;class WoTou &#123; int id; WoTou(int id) &#123; this.id = id; &#125; public String toString() &#123; return "WoTou : " + id; &#125;&#125;class SyncStack &#123; //用栈（先进后出）模拟生产和吃馒头 int index = 0; WoTou[] arrWT = new WoTou[6]; public synchronized void push(WoTou wt) &#123; while(index == arrWT.length) &#123; try &#123; this.wait();//当前的正在访问的这个线程wait，Object的wait方法 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notifyAll(); arrWT[index] = wt; index ++; &#125; public synchronized WoTou pop() &#123; while(index == 0) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notifyAll(); index--; return arrWT[index]; &#125;&#125;class Producer implements Runnable &#123; SyncStack ss = null; Producer(SyncStack ss) &#123; this.ss = ss; &#125; public void run() &#123; for(int i=0; i&lt;20; i++) &#123; WoTou wt = new WoTou(i); ss.push(wt); System.out.println("生产了：" + wt); try &#123; Thread.sleep((int)(Math.random() * 200)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Consumer implements Runnable &#123; SyncStack ss = null; Consumer(SyncStack ss) &#123; this.ss = ss; &#125; public void run() &#123; for(int i=0; i&lt;20; i++) &#123;//三个生产者生产了60个，一个消费者消费了20个 WoTou wt = ss.pop(); System.out.println("消费了: " + wt); try &#123; Thread.sleep((int)(Math.random() * 1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(八)异常体系]]></title>
    <url>%2F2017%2F08%2F15%2Fjavase%2Fjava-exception%2F</url>
    <content type="text"><![CDATA[JAVA基础之异常体系异常是运行期出现的错误。异常的层次： 123456java.lang.Objectjava.lang.Throwablejava.lang.Exceptionjava.lang.RuntimeExceptionjava.lang.Errorjava.lang.ThreadDeath 一、异常的概念java异常是java提供的用于处理程序中错误的一种机制。java程序的执行过程中如果出现异常事件，java会自动生成一个异常对象，该异常对象封装了异常事件的信息并提交给java运行时系统，这个过程称为抛出（throw）异常。当javajava运行时系统接受到异常对象时，会寻找能处理这一异常的代码并把当前异常对象交给其处理，这一过程称为捕获（catch）异常 二、异常的分类 ThrowableThrowable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类(或其子类之一)的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型 两个子类的实例，Error 和 Exception，通常用于指示发生了异常情况。通常，这些实例是在异常情况的上下文中新近创建的，因此包含了相关的信息(比如堆栈跟踪数据)。 ExceptionException 类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件，表示程序本身可以处理的异常 运行时异常 RuntimeException类及其子类都被称为运行时异常，这种异常的特点是Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try…catch语句捕获它，也没有用throws字句声明抛出它，还是会编译通过 受检查异常 除了RuntimeException类及其子类外，其他的Exception类及其子类都属于受检查异常，这种异常的特点是要么用try…catch捕获处理，要么用throws语句声明抛出，否则编译不会通过 两者的区别 运行时异常表示无法让程序恢复运行的异常，导致这种异常的原因通常是由于执行了错误的操作。一旦出现错误，建议让程序终止。 受检查异常表示程序可以处理的异常。如果抛出异常的方法本身不处理或者不能处理它，那么方法的调用者就必须去处理该异常，否则调用会出错，连编译也无法通过。当然，这两种异常都是可以通过程序来捕获并处理的 Error称为错误，由java虚拟机生成并抛出，包括动态链接失败，虚拟机错误等，程序对其不做处理 Runtime Exception一类特殊的异常，如：除以0、数组下标越界等，可以处理也可以不处理，用户的显示声明或捕获对程序的可读性和运行效率影响大，因此由系统自动检测并将他们交给缺省的异常处理程序。 ThreadDeath调用 Thread 类中带有零参数的 stop 方法时，受害线程将抛出一个 ThreadDeath 实例。 仅当应用程序在被异步终止后必须清除时才应该捕获这个类的实例。如果 ThreadDeath 被一个方法捕获，那么将它重新抛出非常重要，因为这样才能让该线程真正终止。如果没有捕获 ThreadDeath，则顶级错误处理程序不会输出消息。 虽然 ThreadDeath 类是“正常出现”的，但它只能是 Error 的子类而不是 Exception 的子类，因为许多应用程序捕获所有出现的 Exception，然后又将其放弃 三、异常的捕获和处理当方法抛出的异常不是Runtime Exception时，则必须捕获处理，finally语句不管有没有异常都会执行 Catch语句12getMessage();//用来得到有关异常事件的信息printStackTrace();//用来跟踪异常事件发生时执行堆栈的内容 Finally语句finally语句为异常处理提供的统一的出口，无论try指定的程序是否抛出异常，finally都会执行。通常在finally中进行资源的清楚工作，如：关闭打开的文件，清除临时文件等 四、自定义异常 通过继承java.lang.Exception类声明自己的异常类 在方法适当的位置生成自定义异常的实例，并用throw语句抛出 在方法的声明部分用throws语句声明该方法可能抛出的异常 异常与重写的关系： 重写方法需要抛出与原方法所抛出异常类型一致的异常或不抛异常 12345678public void test2() throws MyException&#123; ... try &#123; ... &#125; catch (MyException e) &#123; throw e; //捕获了异常，然后又和盘托出，没有意义 &#125; &#125; 五、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.io.*public class TestEx &#123; public static void main(String[] args) &#123; try &#123; new TestEx().f2(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; /* int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[2]); try &#123; System.out.println(2/0); //用0做了除数，会抛出java.lang.ArithmeticException的异常 &#125; catch (ArithmeticException e) &#123; System.out.println("系统正在维护,请与管理员联系"); e.printStackTrace(); &#125; */ //TestEx te = new TestEx(); //te.m(0); /* try &#123; new TestEx().m(0); &#125; catch (ArithmeticException ae) &#123; ae.printStackTrace(); System.out.println("出错了"); &#125; */ FileInputStream in = null; try &#123; in = new FileInputStream("myfile.txt"); int b; b = in.read(); while (b != -1) &#123; System.out.print((char) b); b = in.read(); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(e.getMessage()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; void m(int i) throws ArithmeticException &#123; if(i==0) throw new ArithmeticException("被除数为0"); &#125; void f() throws FileNotFoundException , IOException &#123; FileInputStream in = new FileInputStream("myfile.txt"); int b; b = in.read(); while (b != -1) &#123; System.out.print((char) b); b = in.read(); &#125; &#125; void f2() throws IOException &#123; /* try &#123; f(); &#125; catch (FileNotFoundException e) &#123; System.out.println(e.getMessage()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; */ f(); &#125;&#125; 六、异常转型和异常链 异常转型 异常转型，实际上就是捕获到异常后，将异常以新的类型的异常再抛出，这样做一般为了异常的信息更直观。比如： 1234567891011public void run() throws MyException&#123; ... try&#123; ... &#125;catch(IOException e)&#123; ... throw new MyException(); &#125;finally&#123; ... &#125; &#125; 异常链 异常链，在JDK1.4以后版本中，Throwable类支持异常链机制。Throwable 包含了其线程创建时线程执行堆栈的快照。它还包含了给出有关错误更多信息的消息字符串。最后，它还可以包含 cause(原因)：另一个导致此 throwable 抛出的 throwable。它也称为异常链 设施，因为 cause 自身也会有 cause，依此类推，就形成了异常链，每个异常都是由另一个异常引起的。 通俗的说，异常链就是把原始的异常包装为新的异常类，并在新的异常类中封装了原始异常类，这样做的目的在于找到异常的根本原因。 123456789101112//通过Throwable的两个构造方法可以创建自定义的包含异常原因的异常类型：Throwable(String message, Throwable cause);//构造一个带指定详细消息和 cause 的新 throwable。Throwable(Throwable cause);//构造一个带指定 cause 和 (cause==null ? null :cause.toString())(它通常包含类和 cause 的详细消息)的详细消息的新 throwable。getCause();//返回此 throwable 的 cause;如果 cause 不存在或未知，则返回 null。initCause(Throwable cause);//将此 throwable 的 cause 初始化为指定值。//在Throwable的子类Exception中，也有类似的指定异常原因的构造方法：Exception(String message, Throwable cause);//构造带指定详细消息和原因的新异常。Exception(Throwable cause);//根据指定的原因和 (cause==null ? null : cause.toString()) 的详细消息构造新异常//因此，可以通过扩展Exception类来构造带有异常原因的新的异常类。 七、Java异常处理的原则和技巧 避免过大的try块，不要把不会出现异常的代码放到try块里面，尽量保持一个try块对应一个或多个异常 细化异常的类型，不要不管什么类型的异常都写成Excetpion catch块尽量保持一个块捕获一类异常，不要忽略捕获的异常，捕获到后要么处理，要么转译，要么重新抛出新类型的异常 不要把自己能处理的异常抛给别人 不要用try…catch参与控制程序流程，异常控制的根本目的是处理程序的非正常情况。]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(七)IO流]]></title>
    <url>%2F2017%2F08%2F13%2Fjavase%2Fjava-io%2F</url>
    <content type="text"><![CDATA[JAVA基础之IO流流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。下面是整个数据流结构： 一、java流的输入输出原理在java程序中，对于数据的输入输出操作以流（Stream）方式进行。 java有关流操作的类或接口： 二、流的分类 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 按照功能不同分为：节点流和处理流 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer J2SDK所提供的所有流类型位于包java.io内都分别集成自以上四种抽象流类型 三、输入流和输出流对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。 输入流和输出流是站在程序的角度划分的 InputStream 输入字节流InputStream ：（深色的为节点流，浅色为处理流） 继承自InputStream 的类都是用于向程序输入数据，数据单位为字节（8bit） InputStream 是所有的输入字节流的父类，它是一个抽象类 ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据 ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角） InputStream 常用方法： 12345678910//读取一个字节，并以整数形式返回（0-255），输入流末尾返回-1int read() throws IOException//读取一系列字节，并存储到一个数组buffer，返回实际读取的字节数int read(byte[] buffer) throws IOException//读取length个字节，从offset开始，返回实际读取的字节数int read(byte[] buffer,int offset,int length) throws IOException//关闭流，释放内存资源void close() throws IOException//跳过n个字节不读，返回实际调过的字节数long skip(long n) throws IOException 细节： 12345/*字节流的read()方法读取一个字节。为什么返回的不是byte类型，而是int类型呢？因为read方法读到末尾时返回的是-1，而在所操作的数据中的很容易出现连续多个1的情况，而连续读到8个1，就是-1，导致读取会提前停止。所以将读到的一个字节给提升为一个int类型的数值，但是只保留原字节，并在剩余二进制位补0对于write方法，可以一次写入一个字节，但接收的是一个int类型数值。只写入该int类型的数值的最低一个字节（8位）*/ OutputStream 输出字节流OutputStream : （深色的为节点流，浅色为处理流） 继承自OutputStream 的类都是用于向程序输出数据，数据单位为字节（8bit） OutputStream 是所有的输出字节流的父类，它是一个抽象类 ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据 ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流 OutputStream常用方法： 12345678910//向输出流中写入一个字节，该字节数据为参数b的低8位void write(int b) throws IOException//将一个字节类型的数组中的数据写入输出流void write(byte[] b) throws IOException//将一个字节类型的数组中的数据从指定位置offset开始的length个字节写入输出流void write(byte[] b，int offest,int length) throws IOException//关闭流，释放内存资源void close() throws IOException//将输出流中缓存的数据全部写出到目的地void flush() throws IOException 字节流的输入输出不对应得流 LineNumberInputStream 主要完成从流中读取数据时，会得到相应的行号，至于什么时候分行、在哪里分行是由改类主动确定的，并不是在原始中有这样一个行号。在输出部分没有对应的部分，我们完全可以自己建立一个LineNumberOutputStream，在最初写入时会有一个基准的行号，以后每次遇到换行时会在下一行添加一个行号，看起来也是可以的。好像更不入流了。 PushbackInputStream 的功能是查看最后一个字节，不满意就放入缓冲区。主要用在编译器的语法、词法分析部分。输出部分的BufferedOutputStream 几乎实现相近的功能。 StringBufferInputStream 已经被Deprecated，本身就不应该出现在InputStream 部分，主要因为String 应该属于字符流的范围。已经被废弃了，当然输出部分也没有必要需要它了！还允许它存在只是为了保持版本的向下兼容而已。 SequenceInputStream 可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。完全可以从IO 包中去除，还完全不影响IO 包的结构，却让其更“纯洁”――纯洁的Decorator 模式。 PrintStream 也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream 写入数据，本身内部实现还是带缓冲的。本质上是对其它流的综合运用的一个工具而已。一样可以踢出IO 包！System.out 和System.out 就是PrintStream 的实例！ 四、字节流和字符流字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别： 读写单位不同：字节流以字节（8bit）为单位，字符流以字符(16bit)为单位，根据码表映射字符，一次可能读多个字节 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据 结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流 Reader 字符输入流Reader ：（深色的为节点流，浅色为处理流） 继承自Reader 的类都是用于向程序输入数据，数据单位为字符（16bit） Reader 是所有的输入字符流的父类，它是一个抽象类 CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据 BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象 FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号 InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致 Reader 常用方法： 1//同InputStream Writer 字符输出流Writer：（深色的为节点流，浅色为处理流） 继承自Writer的类都是用于向程序输出数据，数据单位为字符（16bit） Writer 是所有的输出字符流的父类，它是一个抽象类 CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据 BufferedWriter 是一个装饰器为Writer 提供缓冲功能 PrintWriter 和PrintStream 极其类似，功能和使用也非常相似 OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似 Writer常用方法： 1234//同OutputStream//将一个字符串中的字符写入到输出流void write(String string) throws IOExceptionvoid write(String string,int offest,int length) throws IOException FileWriter FileWriter：该类没有特有的方法只有自己的构造函数。该类特点在于： 用于处理文本文件 该类中有默认的编码表 该类中有临时缓冲 构造函数：在写入流对象初始化时，必须要有一个存储数据的目的地 对于读取或者写入流对象的构造函数，以及读写方法，还有刷新关闭功能都会抛出IOException或其子类 细节：在java中，当指定绝对路径时，定义目录分隔符有两种方式： 反斜线但是一定要写两个 new FileWriter(“c:\ \demo.txt”); 正斜线/ 写一个即可 new FileWriter(“c:/demo.txt”); 五、节点流和处理流节点流 节点流为可以从一个特定的数据源（节点）读写数据（如：文件，内存） 节点流类型 FileInputStream 123456789101112131415161718192021222324252627public class TestFileInputStream&#123; public static void main(String[] args)&#123; int b = 0; FileInputStream in = null; try&#123; in = new FileInputStream("d:\\java\\io\\TestFileInputStream.java");//windows下的处理java的反斜杠，可直接使用/ //in.available();//获取关联的文件的字节数。 &#125;catch(FileNotFoundException e)&#123; syso("找不到指定文件"); system.exit(-1);//程序退出 &#125; try&#123; long num = 0; while((b=in.read()) != -1)&#123; syso((char)b); num++; &#125; in.close(); syso(); syso("共读了"+num+"个字节"); &#125;catch(IOException e1)&#123; syso("文件读取错误！"); system.exit(-1);//程序退出 &#125; &#125;&#125; FileReader同FileInputStream FileOutputStream 1234567891011121314151617181920212223public class TestFileOutputStream&#123; public static void main(String[] args)&#123; int b = 0; FileInputStream in = null; FileOutputStream out = null; try&#123; in = new FileInputStream("d:\\java\\io\\Test.java");//windows下的处理java的反斜杠，可直接使用/ out = new FileOutputStream("d:\\java\\io\\hello.java");//当找不到文件时，系统会自动创建，但不会创建目录 while((b=in.read()) != -1)&#123; out.write(b);//从Test中读出来写入hello中 &#125; in.close(); out.close(); &#125;catch(FileNotFoundException e)&#123; syso("找不到指定文件！"); system.exit(-1);//程序退出 &#125;catch(IOException e1)&#123; syso("文件复制错误！"); system.exit(-1);//程序退出 &#125; syso("文件已复制！"); &#125;&#125; FileWriter同FileOutputStream 处理流 处理流是连接在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更强大的读写功能 处理流类型 六、缓冲流缓冲流套接在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法 123456789//J2SDK提供了四种 缓冲流，其常用的构造方法为：BufferedReader(reader in);BufferedReader(reader in,int size);//自定义缓冲区大小BufferedWriter(Writer in);BufferedWriter(Writer in,int size);BufferedInputStream(InputStream in);BufferedInputStream(InputStream in,int size);BufferedOutputStream(OutputStream in);BufferedOutputStream(OutputStream in,int size); 缓冲输入流支持其父类的mark和reset方法 BufferedReader提供了readLine方法用于读取一行字符串（以\r或\n分隔），末尾返回null BufferedWriter提供了newLine用于写入一个行分隔符（跨平台的换行符） 对于输出的缓冲流，写出的数据会先在内存中缓存，使用flush方法会将内存中的数据立刻写出 在使用缓冲区对象时，要明确，缓冲的存在是为了增强流的功能而存在，所以在建立缓冲区对象时，要先有流对象存在 写入缓冲区对象 123456789//建立缓冲区对象必须把流对象作为参数传递给缓冲区的构造函数。BufferedWriter bufw = new BufferedWriter(new FileWriter("buf.txt"));bufw.write("abce");//将数据写入到了缓冲区。bufw.flush();//对缓冲区的数据进行刷新。将数据刷到目的地中。bufw.close();//关闭缓冲区，其实关闭的是被包装在内部的流对象。//如果文件体积不是很大byte[] buf = new byte[fis.available()];//创建一个刚刚好的缓冲区//但是这有一个弊端，就是文件过大，大小超出jvm的内容空间时，会内存溢出 读取缓冲区对象 12345678BufferedReader bufr = new BufferedReader(new FileReader("buf.txt"));String line = null;//按照行的形式取出数据。取出的每一个行数据不包含回车符。while((line=bufr.readLine())!=null)&#123;System.out.println(line);&#125;bufr.close(); BufferedInputStream 123456789101112131415161718192021222324252627public class TestBufferedInputStream&#123; public static void main(String[] args)&#123; try&#123; //windows下的处理java的反斜杠，可直接使用/ FileInputStream fis = new FileInputStream("d:\\java\\io\\hello.java"); BufferedInputStream bis = new BufferedInputStream(fis); int c = 0; syso(bis.read()); syso(bis.read()); bis.mark(100);//标记。从100字节开始读 for(int i=0;i &lt;=10 &amp;&amp; (c = bis.read()) != -1;i++)&#123; syso(c+" "); &#125; syso(); bis.reset();//重置到标记处 for(int i=0;i &lt;=10 &amp;&amp; (c = bis.read()) != -1;i++)&#123; syso(c+" "); &#125; bis.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; BufferedWriter 123456789101112131415161718192021222324public class TestBufferedWriter&#123; public static void main(String[] args)&#123; try&#123; BufferedWriter bw = new BufferedWriter(new FileWriter("d:\\java\\io\\hello.java")); BufferedReader bw = new BufferedReader(new FileReader("d:\\java\\io\\hello.java")); String s = null; for(int i=1;i &lt;= 100;i++)&#123; s = String.valueOf(Math.random()); bw.write(s); bw.newLine(); &#125; bw.flush(); while((s = br.readLine()) != null)&#123; syso(s); &#125; bw.close(); br.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; readLine()方法原理： 其实缓冲区中的该方法，用的还是与缓冲区关联的流对象的read方法。只不过，每一次读到一个字符，先不进行具体操作，先进行临时存储。当读取到回车标记时，将临时容器中存储的数据一次性返回 七、转换流 转换流的特点： 其是字符流和字节流之间的桥梁 可对读取到的字节数据经过指定编码转换成字符 可对读取到的字符数据经过指定编码转换成字节 InputStreamReader 需要和 InputStream 套接 OutputStreamWriter 需要和 OutputStream 套接 转换流在构造时可以指定其编码集合，例： InputStream isr = new InputStreamReader(System.in,”ISO8859_1”); 何时使用转换流？ 当字节和字符之间有转换动作时； 流操作的数据需要编码或解码时。 具体的对象体现： InputStreamReader:字节到字符的桥梁 OutputStreamWriter:字符到字节的桥梁 这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。 构造函数： 1234InputStreamReader(InputStream);//通过该构造函数初始化，使用的是本系统默认的编码表GBK。InputStreamReader(InputStream,String charSet);//通过该构造函数初始化，可以指定编码表。OutputStreamWriter(OutputStream);//通过该构造函数初始化，使用的是本系统默认的编码表GBK。OutputStreamWriter(OutputStream,String charSet);//通过该构造函数初始化，可以指定编码表。 InputStreamReader： 1234567891011121314151617181920public class TestInputStreamReader&#123; public static void main(String[] args)&#123; InputStreamReader isr = new InputStreamReader(System.in); Bufferedreader br = new Bufferedreader(isr); String s = null; try&#123; s = br.readLine(); while(s != null)&#123; if(s.equalsIgnoreCase("exit"))&#123; break; &#125; System.out.println(s.toUpperCase()); s = br.readLine(); &#125; br.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; OutputStreamWriter 12345678910111213141516171819public class TestOutputStreamWriter&#123; public static void main(String[] args)&#123; try&#123; OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("d:\\java\\io\\hello.java")); osw.write("axsckdkjdnvkjsgfjsfhva"); System.out.println(osw.getEncoding());//GBK--当前系统默认的编码（中文） osw.close(); //true表示在原文件上追加，不加true则会覆盖原来的内容 osw = new OutputStreamWriter(new FileOutputStream("d:\\java\\io\\hello.java",true),"ISO8859_1"); osw.write("axsckdkjdnvkjsgfjsfhva"); System.out.println(osw.getEncoding()); osw.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 八、数据流 DataInputStream继承自InputStream，需要嵌套在InputStream上，属于处理流 DataOutputStream继承自OutputStream，需要嵌套在OutputStream上，属于处理流 DataInputStream和DataOutputStream提供了可以存取与机器无关的java原始类型数据（如：int,double等）的方法 构造方法： 12DataInputStream(InputStream in);DataOutputStream(OutputStream out); 常用方法 12345678910111213141516171819//1.DataInputStream//操作基本数据类型的方法：int readInt();//一次读取四个字节，并将其转成int值。boolean readBoolean();//一次读取一个字节。short readShort();long readLong();//剩下的数据类型一样。String readUTF();//按照utf-8修改版读取字符。注意，它只能读writeUTF()写入的字符数据。//2.DataOutputStream//操作基本数据类型的方法:writeInt(int);//一次写入四个字节。//注意和write(int)不同。write(int)只将该整数的最低一个8位写入。剩余三个8位丢弃。writeBoolean(boolean);writeShort(short);writeLong(long);//剩下是数据类型也也一样。writeUTF(String);//按照utf-8修改版将字符数据进行存储。只能通过readUTF读取。//通常只要操作基本数据类型的数据。就需要通过DataStram进行包装。通常成对使用 DataInputStream 1234567891011121314151617181920212223public class TestDataInputStream&#123; public static void main(String[] args)&#123; ByteArrayOutputStream baos = new ByteArrayOutputStream();//字节数组 DataOutputStream dos = new DataOutputStream(baos); try&#123; dos.writeDouble(Math.random()); dos.writeBoolean(true); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); System.out.println(bais.available()); DataInputStream dis = new DataInputStream(bais); System.out.println(dis.readDouble()); System.out.println(dis.readBoolean()); dos.close(); dis.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 九、Print流打印流，所以只有输出流 PrintWriter和PrintStream提供了重载的print和println方法用于多种数据类型的输出 PrintWriter和PrintStream的输出操作不会抛异常，通过检测错误状态获取错误信息 PrintWriter和PrintStream有自动flush功能 构造方法： 1234567PrintWriter(Writer out);PrintWriter(Writer out,boolean autoFlush);PrintWriter(OutputStream out);PrintWriter(OutputStream out,boolean autoFlush);PrintStream(OutputStream out);PrintStream(OutputStream out,boolean autoFlush); PrintStream 1234567891011121314151617181920212223public class TestPrintStream&#123; public static void main(String[] args)&#123; PrintStream ps = null; try&#123; FileOutputStream fos = new FileOutputStream("d:\\java\\io\\hello.java"); ps = new PrintStream(fos); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; if(ps != null)&#123; System.setOut(ps);//setOut表示将out指向ps &#125; int in = 0; for(char c=0;c &lt;= 6000;c++)&#123; System.out.print(c+" "); if(in++ &gt;= 100)&#123; System.out.println(); in = 0; &#125; &#125; &#125;&#125; PrintStream 1234567891011121314151617181920public class TestPrintStream&#123; public static void main(String[] args)&#123; String fileName = args[0]; if(fileName != null)&#123; list(fileName,System.out); &#125; public static void list(String f,PrintStream ps)&#123; try&#123; BufferedReader br = new BufferedReader(new FileReader(f)); String s = null; while((s = br.readLine()) != null)&#123; ps.println(s); &#125; br.close(); &#125;catch(IOException e)&#123; ps.println("无法读取文件"); &#125; &#125;&#125; PrintWriter 123456789101112131415161718192021222324public class TestPrintWriter&#123; public static void main(String[] args)&#123; String s = null; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try&#123; FileWriter fw = new FileWriter("d://logfile.log",true); PrintWriter log = new FileWriter(fw); while((s = br.readLine()) != null)&#123; if(s.equalsIgnoreCase("exit"))&#123; break; &#125; System.out.println(s.toUpperCase()); log.println("-----"); log.println(s.toUpperCase()); log.flush(); &#125; log.println("---"+new Date()+"--"); log.flush(); log.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;&#125; 十、Object流直接将Object（整个）写入或读出 ObjectInputStream ObjectOutputStream 可以通过这两个流对象直接操作已有对象并将对象进行本地持久化存储。存储后的对象可以进行网络传输 1234567891011121314151617181920212223public class TestPrintWriter&#123; public static void main(String[] args)&#123; T t = new T(); t.k = 8; FileOutputStream fos = new FileOutputStream("d:\\java\\io\\hello.java"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(t); oos.flush(); oos.close(); FileInputStream fis = new FileInputStream("d:\\java\\io\\hello.java"); ObjectInputStream ois = new ObjectInputStream(fis); T tReader = (T)ois.readObject(); System.out.println(tReader.i+" "+tReader.j+" "+tReader.d+" "+tReader.k); &#125;&#125;class T implements Serializable&#123; int i = 10; int j = 9; double d = 2.3; int k = 15;&#125; Serializable 该接口其实就是一个没有方法的标记接口。用于给类指定一个UID。 该UID是通过类中的可序列化成员的数字签名运算出来的一个long型的值。只要是这些成员没有变化，那么该值每次运算都一样。 该值用于判断被序列化的对象和类文件是否兼容。 如果被序列化的对象需要被不同的类版本所兼容。可以在类中自定义UID。 定义方式：static final long serialVersionUID = 42L; 注意：对应静态的成员变量，不会被序列化。对应非静态也不想被序列化的成员而言，可以通过transient关键字修饰。通常，这两个对象成对使用 Transienttransient修饰的成员变量在序列化时不予考虑，不进行操作 Externalizable自己控制自己的序列化过程。Serializable是JDK控制的序列化过程 方法： 1234//从objectInput读出来void readExternal(objectInput in);//把自己写出去void writeExternal(objectOutput out); 十一、集合对象Properties类似于HashTable，Properties:该集合不需要泛型，因为该集合中的键值对都是String类型 常见方法： 1234567891011121314151617181920//1.存入键值对setProperty(key,value);//2.获取指定键对应的值value getProperty(key);//3.获取集合中所有键元素Enumeration propertyNames();Set&lt;String&gt; stringPropertyNames();//在jdk1.6版本给该类提供一个新的方法//4.列出该集合中的所有键值对，可以通过参数打印流指定列出到的目的地list(PrintStream);list(PrintWriter);//例：list(System.out);//将集合中的键值对打印到控制台list(new PrintStream("prop.txt"));//将集合中的键值对存储到prop.txt文件中//5.可以将流中的规则数据加载进行集合，并称为键值对load(InputStream);load(Reader);//jdk1.6版本。提供了新的方法//注意：流中的数据要是"键=值" 的规则数据//6.可以将集合中的数据进行指定目的的存储store(OutputStram,String comment);store(Writer ,String comment);//jdk1.6版本。提供了新的方法,使用该方法存储时，会带着当时存储的时间 十二、File该类的出现是对文件系统的中的文件以及文件夹进行对象的封装。可以通过对象的思想来操作文件以及文件夹 构造函数： 123File(String filename);//将一个字符串路径(相对或者绝对)封装成File对象，该路径是可存在的，也可以是不存在。File(String parent,String child);File(File parent,String child); separator 跨平台的目录分隔符，如： 1File file = new File("c:"+File.separator+"abc"+File.separator+"a.txt"); 常见方法： 1234567891011121314151617181920212223242526272829303132333435//1.创建boolean createNewFile()throws IOException;//创建文件，如果被创建的文件已经存在，则不创建。boolean mkdir();// 创建文件夹。boolean mkdirs();// 创建多级文件夹。//2.删除boolean delete();//可用于删除文件或者文件夹。//注意：对于文件夹只能删除不带内容的空文件夹，//对于带有内容的文件夹，不可以直接删除，必须要从里往外删除。void deleteOnExit():;//删除动作交给系统完成。无论是否反生异常，系统在退出时执行删除动作。//3.判断boolean canExecute();boolean canWrite();boolean canRead();boolean exists();//判断文件或者文件夹是否存在。boolean isFile();// 判断File对象中封装的是否是文件。boolean isDirectory();//判断File对象中封装的是否是文件夹。boolean isHidden();//判断文件或者文件夹是否隐藏。在获取硬盘文件或者文件夹时，//对于系统目录中的文件，java是无法访问的，所以在遍历，可以避免遍历隐藏文件。//4.获取getName();//获取文件或者文件夹的名称。getPath();//File对象中封装的路径是什么，获取的就是什么。getAbsolutePath();//无论File对象中封装的路径是什么，获取的都是绝对路径。getParent():;//获取File对象封装文件或者文件夹的父目录。//注意：如果封装的是相对路径，那么返回的是null.long length();//获取文件大小。longlastModified();//获取文件或者文件最后一次修改的时间。static File[] listRoots();//获取的是被系统中有效的盘符。String[] list();//获取指定目录下当前的文件以及文件夹名称。String[] list(Filenamefilter);//可以根据指定的过滤器，过滤后的文件及文件夹名称。File[] listFiles();//获取指定目录下的文件以及文件夹对象。//5.重命名renameTo(File);File f1 = new File("c:\\a.txt");File f2 = new File("c:\\b.txt");f1.renameTo(f2);//将c盘下的a.txt文件改名为b.txt文件。 十三、操作数组的流对象 操作字节数组 12345ByteArrayInputStreamByteArrayOutputStreamtoByteArray();toString();writeTo(OutputStream); 操作字符数组 12345678CharArrayReaderCharArrayWriter/*对于这些流，源是内存。目的也是内存。而且这些流并未调用系统资源。使用的就是内存中的数组。所以这些在使用的时候不需要close。操作数组的读取流在构造时，必须要明确一个数据源。所以要传入相对应的数组。对于操作数组的写入流，在构造函数可以使用空参数。因为它内置了一个可变长度数组作为缓冲区*/ ​]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA正则表达式]]></title>
    <url>%2F2017%2F08%2F12%2FregularExpression%2FregularExpression01%2F</url>
    <content type="text"><![CDATA[正则表达式正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。给定一个正则表达式和另一个字符串，我们可以达到如下的目的： 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”） 可以通过正则表达式，从字符串中获取我们想要的特定部分 一、正则表达式常见规则 字符 | X | 字符x || —- | —– || \ \ | 反斜线字符 || \t | 制表 || \n | 换行 || \r | 回车 || \f | 换页 | 字符类 | [abc] | a、b或c || ————– | ——— || [a-zA-Z] | a到z或A到Z || [a-z&amp;&amp;[def]] | d、e或f(交集) || [^abc] | 非a、b、c || [a-d[m-p]] | a到d或m到p || [a-z&amp;&amp;[ ^bc]] | a到z除b、c || [a-z&amp;&amp;[ ^m-p]] | a-z除m到p | 预定义字符类 | . | 任何字符 || —- | —————— || \d | 数字[0-9] || \D | 非数字 || \s | 空白字符[\t\n\f\r\xOB] || \S | 非空白字符 || \w | 单词字符[a-zA-Z_0-9] || \W | 非单词字符 | 边界匹配器 | ^ | 行的开头 || —- | ——– || $ | 行的结尾 || \b | 单词边界 || \B | 非单词边界 || \A | 输入的开头 || \G | 上一个匹配的结尾 || \z | 输入的结尾 || \Z | 输出的结尾 | Greedy数量词 | x? | 至多一次 || —— | —- || x* | 零或多次 || x+ | 至少一次 || x{n} | 恰好n次 || x{n,} | 至少n次 || x{n,m} | n到m次 | 正则表达式组概念 | () | 表示组，组后面\数组表示组编号，组零表示整个表达式 || —- | ————————- || {} | 表示重复操作 || [] | 用于定义字符集 | 二、正则表达式匹配其使用的就是String类中的matches方法。例： 12String regex = "1[358][0-9]&#123;9&#125;";//匹配电话号码//String regex = "1[358]\\d&#123;9&#125;"; 三、正则表达式切割其使用的就是String类中的split方法。例： 123456String str = "atttbmmc";//切割字符串str.split("&#123;.&#125;\\1+");//任意字符重复时切割/*1.&#123;.&#125;表示复用的，重复的[.]任意字符2.\\1表示，第一个\表示在字符串中需要转义，第二个\表示将1转义成组编号，表示第一组*/ 四、正则表达式替换其使用的就是String类中的replaceAll方法。例： 123456String str = "zhangsantttlisimmm";str = str.replaceAll("(.)\\1+","#"); //将叠词替换成#str = str.replaceAll("(.)\\1+","$1");//获取第一个叠词前面的内容String tel = "15800001111";//158****1111tel = tel.replaceAll("(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)","$1****$2"); 五、正则表达式获取类Pattern，java.util.regex包。 将正则规则进行对象的封装 1Pattern p = Pattern.compile("a*b"); 通过正则对象的matches方法和字符串相关联，获取要对字符串操作的匹配器对象Matcher 1Matcher m = p.matcher("aaaaab"); 通过Matcher匹配器对象的方法对字符串进行操作 1boolean b = m.matches(); 例： 1234567891011121314String str = "da jia hao,ming tian bu fang jia";//获取三个字母的单词String regex = "\\b[a-z]&#123;3&#125;\\b";//1.将正则封装成对象Pattern p = Pattern.compile(regex);//2.通过正则对象获取匹配器对象Matcher m = p.matcher(str);//3.使用Matcher匹配器对象的方法对字符串进行操作，既然要获取三个字母的单词，则查找find()while(m.find())&#123; syso(m.group());//获取匹配的子序列&#125;//匹配的起始索引m.start();//3 jia---[3,6)//匹配的结束索引m.end();//6 六、正则表达式练习 字符串替换 12345String str = "我我...我..要要要...学学学...编程程";//1.将字符串.去掉str = str.replaceAll("\\.+","");//2.替换叠词str = str.replaceAll("(.)\\1+","$1"); 对ip地址排序 123456789101112131415161718String ip_str = "192.168.10.34 127.0.0.1 3.3.3.3 105.70.11.55";//1.将ip地址切出String[] ips = ip_str.split(" +");//空格//2.为了让ip可以按照字符串顺序比较（TreeSet自带），只要让ip的每一段位数相同，补零ip_str = ip_str.replaceAll("(\\d+)","00$1");//3.然后每一段保留位数3位ip_str = ip_str = .replaceAll("0*(\\d&#123;3&#125;)","$1");//4.再将ip地址切出String[] ips = ip_str.split(" +");//空格//5.排序TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;();for(String ip :ips)&#123; ts.add(ip);&#125;//ip地址复原for(String ip :ts)&#123; syso(ip.replaceAll("0*(\\d+)","$1"));&#125; 对邮箱校验 123456String mail = "abc1@sina.com";String regex = "[a-zA-Z0-9_]+@[a-zA-Z0-9]+(\\.[a-zA-Z]&#123;1,3&#125;)+";regex = "\\W+@\\w+(\\.\\w+)+";//1@1.1，笼统校验//mail.indexof("@") != -1;boolean b = mail.matches(regex);syso(mail+":"+b); 爬虫练习 网页爬虫：其实就是一个程序用于在互联网中获取符合指定规则的数据。例：爬邮箱地址，本地 123456789101112131415161718192021222324public static List&lt;String&gt; getMails() throws IOException&#123; //1.读取源文件 BufferedReader bufr = new BufferedReader(new FileReader("c:\\mail.html")); //2.对读取的数据进行规则的匹配，从中获取符合规则数据 String mail_regex = "\\W+@\\w+(\\.\\w+)+"; Pattern p = Pattern.compile(mail_regex); String line = null; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); while((line = bufr.readLine()) != null)&#123;//读每行数据 Matcher m = p.matcher(line);//读一行匹配一行 //3.获取到加到集合 while(m.find())&#123;//匹配器 list.add(m.group()); &#125; &#125; return list;&#125;public static void main(String[] args)throws IOException&#123; List&lt;String&gt; list = getMails(); for(String mail : list)&#123; syso(mail); &#125;&#125; 爬网络的话，改变源文件 12URL url = new URL("http://baidu.com");BufferedReader bufr = new BufferedReader(new InputStreamReader(url.openStream())); ​ ​ ​ ​]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>RegularExpression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（六）枚举类]]></title>
    <url>%2F2017%2F08%2F08%2Fjavase%2Fjava-enum%2F</url>
    <content type="text"><![CDATA[java基础之枚举类枚举类型是JDK5.0的新特征，常见使用于switch语句 一、枚举类的定义123public enum Color&#123;RED,BLUE,BLACK,YELLOW,GREEN&#125; 显然，enum很像特殊的class，实际上enum声明定义的类型就是一个类。 而这些类都是类库中Enum类的子类，代码编译之后发现，编译器将 enum类型单独编译成了一个字节码文件：Color.class 123456789final enum hr.test.Color &#123;// 所有的枚举值都是类静态常量public static final enum hr.test.Color RED;public static final enum hr.test.Color BLUE;public static final enum hr.test.Color BLACK;public static final enum hr.test.Color YELLOW;public static final enum hr.test.Color GREEN;private static final synthetic hr.test.Color［］ ENUM$VALUES;&#125; Color枚举类就是class，而且是一个不可以被继承的final类。其枚举值（RED,BLUE…）都是Color类型的类静态常量， 我们可以通过下面的方式来得到Color枚举类的一个实例：Color c=Color.RED 二、枚举类的构造器 构造器只是在构造枚举值的时候被调用 123456789101112131415enum Color&#123;RED（255，0，0），BLUE（0，0，255），BLACK（0，0，0），YELLOW（255，255，0），GREEN（0，255，0）;//构造枚举值，比如RED（255，0，0）private Color（int rv，int gv，int bv）&#123;this.redValue=rv;this.greenValue=gv;this.blueValue=bv;&#125;public String toString（）&#123; //覆盖了父类Enum的toString（）return super.toString（）+“（”+redValue+“，”+greenValue+“，”+blueValue+“）”;&#125;private int redValue; //自定义数据域，private为了封装。private int greenValue;private int blueValue;&#125; 构造器只能私有private，绝对不允许有public构造器。 这样可以保证外部代码无法新构造枚举类的实例 三、枚举类的方法12345678910111213141516171819202122232425//ordinal方法： 返回枚举值在枚举类种的顺序。这个顺序根据枚举值声明的顺序而定。Color.RED.ordinal（）; //返回结果：0Color.BLUE.ordinal（）; //返回结果：1//compareTo方法： Enum实现了java.lang.Comparable接口，因此可以比较象与指定对象的顺序。Enum中的compareTo返回的是两个枚举值的顺 序之差。当然，前提是两个枚举值必须属于同一个枚举类，否则会抛出ClassCastException异常Color.RED.compareTo（Color.BLUE）; //返回结果 -1//values方法： 静态方法，返回一个包含全部枚举值的数组。Color［］ colors=Color.values（）;for（Color c:colors）&#123;System.out.print（c+“,”）;//返回结果：RED,BLUE,BLACK,YELLOW,GREEN...&#125;//toString方法： 返回枚举常量的名称。Color c=Color.RED;System.out.println（c）;//返回结果： RED//valueOf方法： 这个方法和toString方法是相对应的，返回带指定名称的指定枚举类型的枚举常量。Color.valueOf（“BLUE”）; //返回结果： Color.BLUE//equals方法： 比较两个枚举类对象的引用。//JDK源代码：public final boolean equals（Object other） &#123;return this==other;&#125;]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(五)反射机制]]></title>
    <url>%2F2017%2F08%2F08%2Fjavase%2Fjava-reflex%2F</url>
    <content type="text"><![CDATA[JAVA基础之反射java反射机制是在运行状态中，对于任意一个类（class文件），都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java的反射机制。可以理解为对类的解刨 在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中 –Class类：代表一个类 –Field 类：代表类的成员变量（成员变量也称为类的属性） –Method类：代表类的方法 –Constructor 类：代表类的构造方法 –Array类：提供了动态创建数组，以及访问数组的元素的静态方法 一、反射使用场景 将名称配置在配置文件中 如果想要对指定名称的字节码文件进行操作（扩展新功能），这时就使用到了反射技术 反射就是拿到字节码的文件中的内容 想要对一个类文件进行操作，只要获取到该类的字节码文件即可。Class类用来描述字节码文件，可以获取字节码文件中的所有内容，反射就是依靠该类来完成 二、获取Class对象的三种方式 Object类中的getClass方法 这种方法比较麻烦，必须要明确具体的类，并创建了对象 123Person p = new Person();//Person p1 = new Person();Class class = p.getClass();//Class class1 = p1.getClass();//class == class1 .class静态属性 这样方法相对简单，任何数据类型都具备一个静态的属性.class来获取期对应的class对象，但还是要明确用到类中的静态成员，不够扩展 123Class class = Person.classClass class1 = Person.class//class == class1 forName方法 这种方法更为扩展，只要通过给定的类的字符串名称就可以获取该类 12String className = "Person" //包名.类名Class class = Class.forName(className); 该方法声明时需要抛classNotFoundException 三、获取Class中的构造函数 无参 123456789//获取类的字符串名称String name = "com.Person";//寻找该名称的类文件，并加载进内存，并产生class对象Class class = Class.forName(name);//产生此class对象的实例Object obj = class.newInstance();//若无空参数构造函数，则抛InstantiationException，初始化异常//若空参数为private，则抛IllegalAccessException，无效访问异常 有参 12345678910com.Person p = new com.Person("小强",22);/*1.当要获取指定名称对应类中的所体现的对象时，2.而该对象初始化不使用空参数构造3.可以通过指定的构造函数进行初始化4.通过字节码文件对象获取构造函数5.方法是：*/getConstructor(paramter types);getDeclaredConstructor(paramter types); //可以访问私有的 例： 123456String name = "com.Person";Class class = Class.forName(name);//获取到指定的构造函数Constructor constructor = class.getConstructor(String.class,int.class);//通过该构造器对象的newInstance方法进行对象的初始化Object obj = constructor.newInstance("小强",22); 四、获取Class中的字段123456789//方法Field field = class.getField("age");//获取公有的field = class.getDeclaredField("name");//可以获取私有的//字段设置、获取值field.setAccessible(true);//权限检查，暴力访问//通过对象设、获取值Object obj = class.newInstance();field.set(obj,87);Object o = field.get(obj); 五、获取Class中的方法 获取Class中的公有函数 1Method[] methods = class.getMethods(); 获取Class中本类中的函数，包括私有的 1Method[] methods = class.getDeclaredMethods(); 取一个无参方法 123456789//获取空参Method method = class.getMethod("show",null);//运行该方法Object obj = class.newInstance();method.invoke(obj,null);//带有给字段赋值的Constructor constructor = class.getConstructor(String.class,int.class);Object obj = constructor.newInstance("小明"，27);method.invoke(obj,null); 取一个有参方法 123Method method = class.getMethod("paramMethod",String.class,int.class);Object obj = class.newInstance();method.invoke(obj,"小强",39); 六、-Array类Integer.TYPE返回的是int，而Integer.class返回的是Integer类所对应的Class对象。java.lang.Array 类提供了动态创建和访问数组元素的各种静态方法 1234//一维数组的简单创建，设值，取值Object array = Array.newInstance(classType, 10);Array.set(array, 5, "hello");String str = (String)Array.get(array, 5); 七、反射练习123456789101112131415161718//扩展PCIMainboard mb = new Mainboard();File configFile = new File("pci.properties");Properties prop = new Properties();//将流对象加载进集合FileInputStream fis = new FileInputStream(configFile);prop.load(fis);for(int x=0; x&lt;prop.size(); x++)&#123; String pciName = prop.getProperty("pci"+(x+1)); if(name != null)&#123; //用Class加载这个pci子类 Class class = Class.forName(pciName); PCI p = (PCI)class.newInstance(); mb.usePCI(p); &#125;&#125;fis.close();]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(四)泛型]]></title>
    <url>%2F2017%2F08%2F07%2Fjavase%2Fjava-extensive%2F</url>
    <content type="text"><![CDATA[java基础之泛型泛型（Generic type 或者generics）是对 Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样。泛型是JDK1.5出现的安全机制。好处： 将运行期间的问题classCastException转移到了编译时期 避免了强制转换的问题 潜在的性能收益。泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的JVM 的优化带来可能。 泛型简介 使用场景 &lt;&gt;是一个用于接受具体的引用数据类型的参数范围 泛型技术是给编译器使用的技术，用于编译时期，确保类型的安全 泛型的擦除和补偿 擦除：运行时会将泛型去掉，生成的class文件是不带泛型的，这个是为了兼容运行时的类加载器，即不改变原来的运行时的类加载器，原来怎么运行，现在还怎么运行 补偿：在运行时，通过获取元素的类型进行转换动作，不用使用者再强制转换 使用TreeSet集合 使用TreeSet集合，所使用的泛型的引用类必须实现comparable接口，该接口也有泛型，类型是该引用类型Comparator，例如： 1TreeSet&lt;Person&gt; ts = new TreeSet&lt;Person&gt;(); 定义的比较器实现comparator接口 123456public class ComparatorByName implements Comparator&lt;Person&gt;&#123; public int compare(Person p1, Person p2)&#123; int temp = p1.getName().compareTo(p2.getName()); return temp == 0?p1.getAge()-p2.getAge():temp; &#125;&#125; 定义的引用类实现comparable接口 1234567public class Person implements Comparable&lt;Person&gt;&#123; //里面实现自定义的比较方法 public int compareTo(Person p)&#123; int temp = this.age-p.age; return temp == 0?this.name.compareTo(p.name):temp; &#125;&#125; 泛型里面只能写引用数据类型，基本数据类型使用包装类 泛型不是协变的 关于泛型的混淆，一个常见的来源就是假设它们像数组一样是协变的。其实它们不是协变的。List不是List的父类型。 如果 A 扩展 B，那么 A 的数组也是 B 的数组，并且完全可以在需要B[]的地方使用A[]： 12Integer[] intArray = new Integer[10]; Number[] numberArray = intArray; 上面的代码是有效的，因为一个Integer是一个Number，因而一个Integer数组是一个Number数组。 但是对于泛型来说，下面的代码是无效的 12List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; numberList = intList; // invalid 泛型类在JDK1.5之后，使用泛型来接收类中要操作的引用数据类型，这就是泛型类（自定义泛型类） 123456789public class Tool&lt;QQ&gt;&#123; private QQ q; public QQ getObject()&#123; return q; &#125; public void setObject(QQ object)&#123; this.q = object; &#125;&#125; 使用场景 当类中的操作的引用数据类型不确定的时候，就用泛型类表示，当不使用泛型，就使用object（需要强转） 使用泛型比object安全，将运行时错误提前到编译期 12345678public class Test&#123; public static void main(String[] args)&#123; Tool&lt;Student&gt; tool = new Tool&lt;Student&gt;(); tool.setObject(new Student()); Student stu = tool.getObject(); //Student stu = (Student)tool.getObject();使用了泛型不用强转 &#125;&#125; 泛型方法泛型方法是跟着对象走的 非泛型方法 1234567public void show(String str)&#123; syso("show:"+str);&#125;Tool&lt;String&gt; tool = new Tool&lt;String&gt;();tool.show("abc");tool.show(new Integer(4));//类型报错 泛型方法 1234567public &lt;W&gt; void show(W str)&#123;//等同于object,所以可以自己定义W syso("show:"+str);&#125;//将泛型定义在方法上，类似于object，传什么就show什么Tool&lt;String&gt; tool = new Tool&lt;String&gt;();tool.show("abc");tool.show(new Integer(4));//因为是自定义泛型方法，不会报错 泛型定义在方法上等同于object，不能使用具体对象的方法，只能使用object的方法 当方法静态时，不能访问类上定义的泛型（静态不需要对象，泛型需要对象明确），所以静态方法使用泛型只能定义在方法上 123456public static &lt;Y&gt; void method(Y obj)&#123; syso(obj);&#125;//使用tool.method("haha");tool.method(new Integer(9)); 泛型接口 泛型接口 123public interface Inter&lt;T&gt;&#123; public void show(T t);&#125; 泛型接口使用1 12345678910public class InterImp1 implements Inter&lt;String&gt;&#123; public void show(String str)&#123; syso("show:"+str); &#125;&#125; public static void main(String[] args)&#123; InterImp1 in = new InterImp1(); in.show("abc"); &#125; 泛型接口使用2 12345678910public class InterImp2 implements Inter&lt;Q&gt;&#123; public void show(Q q)&#123; syso("show:"+q); &#125;&#125; public static void main(String[] args)&#123; InterImp2&lt;Integer&gt; in = new InterImp2&lt;Integer&gt;(); in.show(5); &#125; 泛型通配符？，未知类型 通配符的基本使用 12345678910111213ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();al.add("abc");ArrayList&lt;Integer&gt; al2 = new ArrayList&lt;Integer&gt;();al2.add(5);printCollection(a1);printCollection(a2);public static void printCollection(Collection&lt;?&gt; al)&#123; Iterator&lt;?&gt; it = al.iterator(); while(it.hasNext())&#123; syso(it.next()); //这里不能用？str = it.next(); &#125;&#125; 类似的将泛型定义在方法上 1234567public static &lt;T&gt; void printCollection(Collection&lt;T&gt; al)&#123; Iterator&lt;T&gt; it = al.iterator(); while(it.hasNext())&#123; T str = it.next(); syso(str); &#125;&#125; T和？的区别 12345678public static &lt;T&gt; void printCollection(Collection&lt;T&gt; al)&#123; Iterator&lt;T&gt; it = al.iterator(); while(it.hasNext())&#123; T str = it.next(); syso(str);//区别就是可以对T的类型进行操作 syso(it.next())//?的使用，类似于object，只有调用object方法都可以it.next().toString(); &#125;&#125; 泛型的限定 泛型的上限 — ? extends E 当引用类型（泛型类型）为Student和Worker时 1public static void printCollection(Collection&lt;? extends Person&gt; al)&#123;&#125; ? extends Person表示类型只接收Person及其子类 12345Iterator&lt;? extends Person&gt; it = al.iterator(); while(it.hasNext())&#123; Person p = it.next();//限定后可以使用父类方法 syso(p.getName()+":"+p.getAge()); &#125; 上限体现 12345678class MyCollection&lt;E&gt;&#123; public void add(E e)&#123; &#125; public void addAll(MyCollection&lt;? extends E&gt; e)&#123; &#125;&#125; 存元素一般都是上限，这样取出元素都是按照上限类型来运算的，不会出现安全隐患 泛型的下限 — ? super E ? super student表示类型只接收student及其父类 123456public static void printCollection(Collection&lt;? super Student&gt; al)&#123; Iterator&lt;? super Student&gt; it = al.iterator(); while(it.hasNext())&#123; syso(it.next()); &#125;&#125; 下限体现 123class TreeSet&lt;Student&gt;&#123; TreeSet(Comparator&lt;? super Student&gt; comp);&#125; 通常对集合中的元素进行取出操作时，可以使用下限（存什么类型用什么类型接收，存什么类型用父类型接收） 与object最大的区别就是安全，object全存，泛型限定部分存取]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(二)常用类]]></title>
    <url>%2F2017%2F07%2F27%2Fjavase%2Fjava-commonClass%2F</url>
    <content type="text"><![CDATA[JAVA基础之常用类之前很容易忽视的几个java常用类，在jdk1.1之后，应使用Calendar类实现日期和时间字段之间转换，使用DateFormat类来格式化和解析日期字符串 Object所有类的基类，是不断抽取而来的，具备所有对象都具备的内容 equals 本质上还是调用 “==”，比较对象的地址值 重写该方法，进行向下类型转型，需要注意转换异常，进行健壮性判断 hashCode hashCode方法的常规协定，该协定声明相等的对象必须具有相等的哈希码 System类不能被实例化，都是static方法 12long currentTimeMillis(); //获取当前时间的毫秒值Properties getProperties();//获取当前系统属性 获取系统的属性信息，并存储到Properties集合中，该集合中存储的都是String类型的键和值，最好使用他自己的存储和取出的方法操作元素 Runtime 类没有构造方法，说明该类不可以创建对象，又发现还有一个非静态的方法，说明该类应该提供静态的返回该类对象的方法，而且只有一个，说明Runtime类使用了单例设计模式（保证运行时java对象唯一性） 1234567Runtime r = Runtime.getRuntime();//运行时对象产生r.exec("nodepad.exe"); //执行executer.exec("notepad.exe c: \\Runtime.java");//用程序解析文件Process p = r.exe("nodepad.exe");Thread.sleep(5000);p.destroy(); //销毁nodepad.exe这个进程 DateFormat类不能创建实例对象 format方法 将日期对象转换成日期格式字符串 123456789String myString = DateFormat.getDateInstance().format(myDate); //日期String myString = DateFormat.getDateTimeInstance().format(myDate); //时间//具有默认风格FULL,LONG等DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);String myString = dateFormat.format(myDate);//自定义风格SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy:mm:dd");//SimpleDateFormat是DateFormat的子类，可以创建对象String myString = dateFormat.format(myDate); ​ parse方法 将日期格式的字符串转换成日期对象 123456789String str_date = "2017-07-28";DateFormat dateFormat = DateFormat.getDateInstance();//默认的，可以解析--Date date = dateFormat.parse(str_date);//自定义风格str_date = "2017---07---28";dateFormat = new SimpleDateFormat("yyyy---MM---dd");//年月日str_date = "2017年7月28号";dateFormat = DateFormat.getDateInstance(DateFormat.LONG); ​ Calendar类日历类，替代Date类 12345678910Calendar c = Calendar.getInstance();int year = c.get(Calendar.YEAR);int month = c.get(Calendar.MONTH)+1; //注意月份要+1int day = c.get(Calendar.DAY_OF_MONTH);int week = getWeek(c.get(Calendar.DAY_OF_WEEK));//设置日期c.set(2017,7,28);//偏移c.add(Calendar.YEAR,2);c.add(Calendar.YEAR,-2); 包装类Java为基本类型提供包装类，这使得任何接受对象的操作也可以用来操作基本类型，直接将简单类型的变量表示为一个类，在执行变量类型的相互转换时，我们会大量使用这些包装类。java是一种面向对象语言，java中的类把方法与数据连接在一起，并构成了自包含式的处理单元。但在java中不能定义基本类型(primitive type)，为了能将基本类型视为对象来处理，并能连接相关的方法，java为每个基本类型都提供了包装类，这样，我们便可以把这些基本类型转化为对象来处理了。这些包装类有：Boolean，Byte，Short，Character，Integer，Long，Float等 java是可以直接处理基本类型的，但是在有些情况下我们需要将其作为对象来处理，这时就需要将其转化为包装类了。所有的包装类(Wrapper Class)都有共同的方法，他们是： 带有基本值参数并创建包装类对象的构造函数。如可以利用Integer包装类创建对象 1Integer obj = new Integer(145); 带有字符串参数并创建包装类对象的构造函数 1new Integer("45"); 生成字符串表示法的toString()方法 1obj.toString(); 对同一个类的两个对象进行比较的equals()方法 1obj1.eauqls(obj2); 生成哈稀表代码的hashCode方法 1obj.hasCode(); 将字符串转换为基本值的 parseType方法 1Integer.parseInt(args[0]); 注意：Character没有parse方法，但有forDigit方法 可生成对象基本值的typeValue方法 1obj.intValue(); 包装类对象比较大小使用compareTo方法（1 0 -1） 进制转换 十进制转其他进制 1234Integer.toBinaryString(2); //二进制Integer.toOctalString(8); //八进制Integer.toHexString(16); //十六进制Integer.toString(100,4); //四进制 其他转十进制 12Integer.parseInt("110",2); //二进制转十进制Integer.parseInt("3c",16); //十六进制转十进制 包装类的自动装箱拆箱 装箱：基本数据类型赋值给引用数据类型叫装箱 自动装箱的过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中 12Integer i = 4；//Integer i = new Integer(4); 拆箱：当基本数据类型和引用数据类型做运算时 自动拆箱的过程：每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用intValue()和doubleValue()方法 12Integer i = 4;int k = i + 6; 当Integer i = null时，拆箱时会调用intValue方法会产生异常，需要进行健壮性判断 Integer的自动装拆箱注意细节 123Integer a = 100;Integer b = 100;System.out.println(a==b); //true 比较的时候，还是比较对象的reference，但是自动装箱时，java在编译的时候 Integer a = 100；被翻译成Integer a = Integer.valueOf(100)。结果为true的原因就是这个valueOf方法 123456789101112131415161718public static Integer valueOf(int i) &#123; final int offset = 128; if (i &gt;= -128 &amp;&amp; i &lt;= 127) &#123; // must cache return IntegerCache.cache[i + offset]; &#125; return new Integer(i);&#125; private static class IntegerCache &#123; private IntegerCache()&#123; &#125; static final Integer cache[] = new Integer[-(-128) + 127 + 1];//将cache[]变成静态 static &#123;//初始化一次，在对象间共享，也就是不同的对象共享同一个static数据 for(int i = 0; i &lt; cache.length; i++) cache = new Integer(i - 128);//初始化cache[i] &#125;&#125; 根据上面的jdk源码，java为了提高效率，IntegerCache类中有一个数组缓存 了值从-128到127的Integer对象。当我们调用Integer.valueOf（int i）的时候，如果i的值是&gt;=-128且&lt;=127时，会直接从这个缓存中返回一个对象，否则就new一个Integer对象。]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(三)集合框架]]></title>
    <url>%2F2017%2F07%2F25%2Fjavase%2Fjava-collection%2F</url>
    <content type="text"><![CDATA[JAVA基础之集合框架面向对象对事物的体现都是以对象的形式，集合为了方便对多个对象进行操作，对对象进行存储的最常用的一种方式。集合就是存放对象的容器。 数组也可以存储对象，但数组长度是固定的，集合的长度可变；数组也可以存储基本数据类型，集合只能存储对象（通过存储数组对象[]实现存储基本数据类型）。 容器划分： 数组 同类型 arr[0]…arr[i] StringBuffer/StringBuilder 类型、个数无所谓，最终必须转成字符串才可以用（”lisi”,true,6）—&gt; “lisitrue6” 对象 数据多用对象存 “李四”，23 —&gt; new Person(“李四”，23) 集合 对象多了就用集合存 集合框架体系 集合中的结构和几个实现类： collection特有的方法retainall表示取交集，将不同的删除，而removeall是将相同的删除 SortedSet和SortedMap接口对元素按指定规则排序，SortedMap是对key列进行排序 Iterator迭代器 Iterator接口就是对所有collection容器进行元素取出的公共接口 实现原理：内部类实现（一个事物直接访问另一个事物的内部属性） 用法： 12345678Iterator it = coll.iterator();while(it.hasNext())&#123; //it对象在while外面，占内存&#125;//for循环使用for(Iterator it = coll.iterator();it.hasNext();)&#123; &#125; 该对象必须依赖于具体容器，因为每一个容器的数据结构都不同。所以该迭代器对象是在容器中进行内部实现的。对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是容器的iterator方法 Collection接口Collection 接口用于表示任何对象或元素组。想要尽可能以常规方式处理一组元素时，就使用这一接口。Collection不提供get()方法。如果要遍历Collectin中的元素，就必须用Iterator。Collection为单列集合。该接口的常规操作： 单元素添加、删除操作： 12boolean add(Object o);//将对象添加给集合boolean remove(Object o);//如果集合中有与o相匹配的对象，则删除对象o 查询操作： 1234int size();//返回当前集合中元素的数量boolean isEmpty();//判断集合中是否有任何元素boolean contains(Object o);//查找集合中是否含有对象oIterator iterator();//返回一个迭代器，用来访问集合中的各个元素 组操作 ：作用于元素组或整个集合 12345boolean containsAll(Collection c);// 查找集合中是否含有集合c 中所有元素boolean addAll(Collection c);//将集合c 中所有元素添加给该集合void clear();//删除集合中所有元素void removeAll(Collection c);//从集合中删除集合c 中的所有元素void retainAll(Collection c);//从集合中删除集合c 中不包含的元素 Collection转换为Object数组 ： 12Object[] toArray();//返回一个内含集合所有元素的arrayObject[] toArray(Object[] a);//返回一个内含集合所有元素的array。运行期返回的array和参数a的型别相同，需要转换为正确型别。 List集合list是一个有序的，元素可重复的面向位置操作的集合，元素都有索引，list的特点就是可以操作角标 List的基本操作： 123456789101112131415//增void add(int index, Object element);//在指定位置index上添加元素elementboolean addAll(int index, Collection c);//将集合c的所有元素添加到指定位置index//删Object remove(int index);//删除指定位置上的元素//改Object set(int index, Object element);//用元素element取代位置index上的元素，并且返回旧的元素//获取Object get(int index);//返回List中指定位置的元素int indexOf(Object o);//返回第一个出现元素o的位置，否则返回-1int lastIndexOf(Object o);//返回最后一个出现元素o的位置，否则返回-1List subList(int fromIndex, int toIndex);//返回从指定位置fromIndex（包含）到toIndex（不包含）范围中各个元素的列表视图//处理集合的子集ListIterator listIterator();//返回一个列表迭代器，用来访问列表中的元素ListIterator listIterator(int index);//返回一个列表迭代器，用来从指定位置index开始访问列表中的元素 对子列表的更改（如 add()、remove() 和 set() 调用）对底层 List 也有影响。ArrayList 和 LinkedList 都实现 Cloneable 接口，都提供了两个构造函数，一个无参的，一个接受另一个Collection ListIterator接口 ListIterator是List的实现子接口。当集合和迭代器同时操作元素时，会抛出ConcurrentModificationException，所以这时需要使用list内部迭代器 12345678Iterator it = list.iterator();while(it.hasNext())&#123; Object obj = it.next(); if(obj.equals("abc1"))&#123; list.add("abc2");//增加了集合长度，但迭代器还是安装之前的长度迭代 //而且collection的迭代器没有add方法 &#125;&#125; Iterator的方法：hasNext()，next()，remove()—&gt;返回迭代器最后一个元素 使用Iterator接口的子接口ListIterator完成迭代器中元素的更多操作 1234567891011ListIterator it = list.listIterator();//获取列表迭代器对象，从头开始遍历；listIterator(int index)从指定位置开始遍历while(it.hasNext())&#123; Object obj = it.next(); if(obj.equals("abc1"))&#123; it.add("abc2");//使用迭代器添加，它可以实现在迭代过程中对元素的增删改查，只有list集合具备该迭代功能 //listIterator的其他方法 //previous() 返回列表中的前一个元素 //hasPrevious() 逆向遍历 //... &#125;&#125; List常用子类只有Vector是同步的 Vector内部是数组数据结构，长度可变，同步的，线程安全的，效率慢（100%延长数组长度） ArrayList替代了Vector；Iterator替代了Enumeration，Enumeration使用： 1234Enumeration en = v.elements();while(en.hasMoreElements())&#123; Object obj = en.nextElement();&#125; Enumeration接口与Iterator接口的功能是一样的，只是Iterator多了clear方法 ArrayList内部是数组数据结构，不同步的，查询效率高 ArrayList类封装了一个动态再分配的Object[]数组。每个ArrayList对象有一个capacity。这个capacity表示存储列表中元素的数组的容量。当元素添加到ArrayList时，它的capacity在常量时间内自动增加。在向一个ArrayList对象添加大量元素的程序中，可使用ensureCapacity方法增加capacity。这可以减少增加重分配的数量： 1234void ensureCapacity(int minCapacity);// 将ArrayList对象容量增加minCapacityvoid trimToSize();// 整理ArrayList对象容量为列表当前大小。程序可使用这个操作减少ArrayList对象存储空间。void removeRange(int fromIndex, int toIndex);// 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。//如果fromIndex与toIndex相当，则此操作无效 存储的自定义对象，在取出的时候进行强转，不强转可能输出的是哈希值 ArrayList判断元素是否相同用的equals方法 LinkedList内部是链表数据结构，不同步，增删元素速度快，主要处理列表两端元素的方法 123456789//使用这些新方法，可以把 LinkedList 当作一个堆栈、队列或其它面向端点的数据结构void addFirst(Object o);//将对象o添加到列表的开头boolean offerFirst(Object o);//在此列表的开头插入指定的元素。Object getFirst();//返回列表开头的元素Object peekFirst();//获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。Object removeFirst();//删除并且返回列表开头的元素Object pollFirst();//获取并移除此列表的第一个元素；如果此列表为空，则返回 null。LinkedList();//构建一个空的链接列表LinkedList(Collection c);//构建一个链接列表，并且添加集合c的所有元素 练习： 使用LinkedList模拟一个堆栈或队列的数据结构 堆栈：先进后出 FILO 队列：先进先出 FIFO 12345678910111213141516calss DuiLie&#123; private LinkedList link; public DuiLie()&#123; link = new LinkedList(); &#125; public void myAdd(Object obj)&#123; link.addLast(obj); //link.addFirst(obj);addFirst，removeFirst相同就是堆栈，相反就是队列 &#125; public Object myGet()&#123; return link.removeFirst(); &#125; public boolean isNull()&#123; return link.isEmpty(); &#125;&#125; 测试类： 123456789101112public class LinkedTest&#123; public static void main(String[] args)&#123; DuiLie dl = new DuiLie(); dl.myAdd("a"); dl.myAdd("b"); dl.myAdd("c"); dl.myAdd("d"); while(!dl.isNull())&#123; syso(dl.myGet()); &#125; &#125;&#125; Set集合元素无序并且不可重复，取元素只能迭代Iterator，Set接口中的方法和Collection中的一致。它的常用具体实现有HashSet和TreeSet类。HashSet能快速定位一个元素，但是你放到HashSet中的对象需要实现 hashCode()方法，它使用了哈希码的算法。而TreeSet则将放入其中的元素按序存放，这就要求你放入其中的对象是可排序的，这就用 到了集合框架提供的另外两个实用类Comparable和Comparator。一个类是可排序的，它就应该实现Comparable接口。有时多个类具 有相同的排序算法，那就不需要在每分别重复定义相同的排序算法，只要实现Comparator接口即可。 哈希表Hash表是一种数据结构，用来查找对象。Hash表为每个对象计算出一个整数，称为Hash Code(哈希码)。Hash表是个链接式列表的阵列。每个列表称为一个buckets(哈希表元)。对象位置的计算index = HashCode % buckets (HashCode为对象哈希码，buckets为哈希表元总数) 当你添加元素时，有时你会遇到已经填充了元素的哈希表元，这种情况称为Hash Collisions(哈希冲突)。这时，你必须判断该元素是否已经存在于该哈希表中。如果哈希码是合理地随机分布的，并且哈希表元的数量足够大，那么哈希冲突的数量就会减少。同时，你也可以通过设定一个初始的哈希表元数量来更好地控制哈 希表的运行。初始哈希表元的数量为 buckets = size * 150% + 1 (size为预期元素的数量)。如果哈希 表中的元素放得太满，就必须进行rehashing(再哈希)。再哈希使哈希表元数增倍，并将原有的对象重新导入新的哈希表元中，而原始的哈希表元被删 除。load factor(加载因子)决定何时要对哈希表进行再哈希。在Java编程语言中，加载因子默认值为0.75，默认哈希表元为101。 Comparable在“集合框架”中有两种比较接口：Comparable接口和Comparator接口。像String和Integer等Java内建类实现 Comparable接口以提供一定排序方式，但这样只能实现该接口一次。对于那些没有实现Comparable接口的类、或者自定义的类，您可以通过 Comparator接口来定义您自己的比较方式 在java.lang包中，Comparable接口适用于一个类有自然顺序的时候。假定对象集合是同一类型，该接口允许把集合排序成自然顺序。 int compareTo(Object o): 比较当前实例对象与对象o，如果位于对象o之前，返回负值，如果两个对象在排序中位置相同，则返回0，如果位于对象o后面，则返回正值 8种基本类型自然排序 | 类 | 排序 || —————————————- | —————— || BigDecimal,BigInteger,Byte, Double, Float,Integer,Long,Short | 按数字大小排序 || Character | 按 Unicode 值的数字大小排序 || String | 按字符串中字符 Unicode值排序 | 利用Comparable接口创建您自己的类的排序顺序，只是实现compareTo()方法的问题。通常就是依赖几个数据成员的自然排序。同时类也应该覆盖equals()和hashCode()以确保两个相等的对象返回同一个哈希码 Comparator若一个类不能用于实现java.lang.Comparable，或者你不喜欢缺省的Comparable行为并想提供自己的排序顺序(可能多种排序方式)，你可以实现Comparator接口，从而定义一个比较器 int compare(Object o1, Object o2): 对两个对象o1和o2进行比较，如果o1位于o2的前面，则返回负值，如果在排序顺序中认为o1和o2是相同的，返回0，如果o1位于o2的后面，则返回正值 boolean equals(Object obj): 指示对象obj是否和比较器相等。 该方法覆写Object的equals()方法，检查的是Comparator实现的等同性，不是处于比较状态下的对象。 HashSet内部数据结构是哈希表，不同步的，哈比表确定两个元素是否相同的逻辑： 判断两个元素的哈希值是否相同，如果相同再判断两个对象的内容是否相同 判断哈希值用hashCode方法，判断内容用equals方法 两个小细节（重写hashCode和equals方法） 保证哈希值唯一 123public int hashCode()&#123; return name.hashCode()+age*x;//*一个数&#125; 提高equals效率 12345678public boolean equals(Object obj)&#123; if(this == obj) return true;//当是同一个对象时直接返回true if(!(obj instanceof Person))&#123; throw new ClassCastException("类型错误"); &#125; Person p = (Person)obj; return this.name.equals(p.name)&amp;&amp;this.age==p.age;&#125; 构造方法： HashSet(): 构建一个空的哈希集 HashSet(Collection c): 构建一个哈希集，并且添加集合c中所有元素 HashSet(int initialCapacity): 构建一个拥有特定容量的空哈希集 HashSet(int initialCapacity, float loadFactor): 构建一个拥有特定容量和加载因子的空哈希集。LoadFactor是0.0至1.0之间的一个数 TreeSet基于TreeMap的NavigableSet实现，是不同布的，使用元素的自然顺序排序，或根据创建set时提供的comparator进行排序，具体取决于使用的构造函数 存储自定义对象 自定义类需要实现comparable接口，此接口强行实现它的每个类的对象进行整体排序，这种排序称为类的自然排序，类的compareTo方法称为自然比较方法。 compareTo方法也来自comparable接口，只要对象进行比较，就实现此接口 对象比较返回int（正，0，负），0为相同 引用类型强转前都必须进行健壮性判断，否则会抛ClassCastException TreeSet判断元素唯一性 TreeSet判断元素唯一性的方式就是根据比较方法的返回结果，0表示相同，与hashCode和equals方法无关，相同则不存 TreeSet对元素进行排序的方式 让元素自身具备比较功能，就需要实现comparable接口，覆盖compareTo方法 123456//compareTo方法举例public int compareTo(Object o)&#123; Person p = (Person)o; int temp = this.age-p.age; return temp == 0?this.name.compareTo(p,name):temp;//此处的compareTo是String类的方法&#125; 如果不要按照对象中具备的自然顺序进行排序，或对象不具备自然顺序，则可以使用comparator接口（compar和equals方法），让集合自身具备比较功能 123456789101112//定义一个类实现Comparator接口，将该类对象作为参数传递给TreeSet集合的构造函数public class ComparatorByName implements Comparator&#123; // ...&#125;TreeSet ts = new TreeSet(new ComparatorByName());//覆盖compare方法public int compare(Object o1,Object o2)&#123; Person p1 = (Person)o1; Person p2 = (Person)o2; int temp = p1.getName().comparaTo(p2.getName()); return temp == 0?p1.getAge()-p2.getAge():temp;&#125; TreeSet构造函数 TreeSet():构建一个空的树集 TreeSet(Collection c): 构建一个树集，并且添加集合c中所有元素 TreeSet(Comparator c): 构建一个树集，并且使用特定的比较器对其元素进行排序 TreeSet(SortedSet s): 构建一个树集，添加有序集合s中所有元素，并且使用与有序集合s相同的比较器排序 comparator比较器没有任何数据，它只是比较方法的存放器。这种对象有时称为函数对象。函数对象通常在“运行过程中”被定义为匿名内部类的一个实例。 LinkedHashSet具有可预知迭代顺序的set接口的哈希表和链接列表实现，按照元素的插入顺序迭代，希表元中的各个元素是通过双重链接式列表链接在一起的 构造方法： LinkedHashSet(): 构建一个空的链接式哈希集 LinkedHashSet(Collection c): 构建一个链接式哈希集，并且添加集合c中所有元素 LinkedHashSet(int initialCapacity): 构建一个拥有特定容量的空链接式哈希集 LinkedHashSet(int initialCapacity, float loadFactor): 构建一个拥有特定容量和加载因子的空链接式哈希集 为优化HashSet空间的使用，您可以调优初始容量和负载因子。TreeSet不包含调优选项，因为树总是平衡的 注意： 如果在s.contains(e)返回true之后立即调用s.add(e)，则元素e会被重新插入到Set集合中 所以有了这个子类，List和Set的区别从有序无序重点转移到了元素的唯一性 SortedSet“集合框架”提供了个特殊的Set接口：SortedSet，它保持元素的有序顺序。SortedSet接口为集的视图(子集)和它的两端（即头和尾） 提供了访问方法。当您处理列表的子集时，更改视图会反映到源集。此外，更改源集也会反映在子集上。发生这种情况的原因在于视图由两端的元素而不是下标元素 指定，所以如果您想要一个特殊的高端元素（toElement）在子集中，您必须找到下一个元素 添加到SortedSet实现类的元素必须实现Comparable接口，否则您必须给它的构造函数提供一个Comparator接口的实现。TreeSet类是它的唯一一份实现 因为集必须包含唯一的项，如果添加元素时比较两个元素导致了0返回值（通过Comparable的compareTo方法或Comparator 的compare方法），那么新元素就没有添加进去。如果两个元素相等，那还好。但如果它们不相等的话，您接下来就应该修改比较方法，让比较方法和 equals() 的效果一致。 SortedSet的一些方法： Comparator comparator(): 返回对元素进行排序时使用的比较器，如果使用Comparable接口的compareTo()方法对元素进行比较，则返回null Object first(): 返回有序集合中第一个(最低)元素 Object last(): 返回有序集合中最后一个(最高)元素 SortedSet subSet(Object fromElement, Object toElement): 返回从fromElement(包括)至toElement(不包括)范围内元素的SortedSet视图(子集) SortedSet headSet(Object toElement): 返回SortedSet的一个视图，其内各元素皆小于toElement SortedSet tailSet(Object fromElement): 返回SortedSet的一个视图，其内各元素皆大于或等于fromElement AbstractSet抽象类AbstractSet类覆盖了Object类的equals()和hashCode()方法，以确保两个相等的集返回相同的哈希码。若两个集大小相等 且包含相同元素，则这两个集相等。按定义，集的哈希码是集中元素哈希码的总和。因此，不论集的内部顺序如何，两个相等的集会有相同的哈希码 Map集合Map是一种把键对象和值对象进行关联的容器，键必须唯一，值可以重复。Map有两种比较常用的实现：HashMap和TreeMap。HashMap也用到了哈希码的算法，以便快速查找一个键，TreeMap则是对键按序存放，因此它便有一些扩展的方法，比如firstKey()，lastKey()等，还可以从TreeMap中指定一个范围以取得其子Map。Map为双列集合。常见操作： 1234567891011121314//添加value put(k,v);//返回前一个和k关联的值，如果没有则返回null //将互相关联的一个关键字与一个值放入该映像。如果该关键字已经存在，那么与此关键字相关的新值将取代旧值。方法返回关键字的旧值。 //如果关键字原先并不存在，则返回null//删除void clear();value remove(k);//判断boolean containsKey(k);boolean containsValue(v);boolean isEmpty();//获取value get(k);//没有该键则返回nullint size(); 视图操作 ：处理映像中键/值对组 keySet：返回映像中所有关键字（k）的视图集 因为映射中键的集合是唯一的，用Set支持。可以从视图中删除元素，同时，关键字和它的值将从源映像中被删除，但不能添加任何元素。 12Set&lt;Integer&gt; keySet = map.keySet();Iterator&lt;Integer&gt; it = keySet.iterator(); entrySet：返回Map.Entry对象的视图集，即映像中的关键字/值对 因为映射是唯一的，用Set支持。还可以从视图中删除元素，同时，这些元素将从源映像中被删除，但是不能添加任何元素。 通过map转成set就可以迭代。entrySet方法将键值的映射关系作为对象存储到了set集合中，而这个映射关系类型就是map.Entry 1234567Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entrySet = map.entrySet();Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it = entrySet.iterator();while(it.hasNext())&#123; Map.Entry&lt;Integer,String&gt; entry = it.next(); Integer key = entry.getKey(); String value = entry.getValue();&#125; values：返回映像中所有值的视图集 Collection values()因为映射中值的集合不是唯一的，用Collection支持。可以从视图中删除元素，同时，值和它的关键字将从源映像中被删除，但是不能添加任何元素。 12Collection&lt;String&gt; values = map.values();Iterator&lt;String&gt; it = values.iterator(); Map.Entry接口通过这个集合的迭代器，您可以获得每一个条目(唯一获取方式)的键或值并对值进行更改。当条目通过迭代器返回后，除非是迭代器自身的remove()方 法或者迭代器返回的条目的setValue()方法，其余对源Map外部的修改都会导致此条目集变得无效，同时产生条目行为未定义。基本操作： Object getKey(): 返回条目的关键字 Object getValue(): 返回条目的值 Object setValue(Object value): 将相关映像中的值改为value，并且返回旧值 SortedMap接口集合框架提供了个特殊的Map接口：SortedMap，它用来保持键的有序顺序 SortedMap接口为映像的视图(子集)，包括两个端点提供了访问方法。除了排序是作用于映射的键以外，处理SortedMap和处理SortedSet一样 添加到SortedMap实现类的元素必须实现Comparable接口，否则您必须给它的构造函数提供一个Comparator接口的实现。TreeMap类是它的唯一一份实现 因为对于映射来说，每个键只能对应一个值，如果在添加一个键/值对时比较两个键产生了0返回值（通过Comparable的compareTo方法或通过Comparator的compare方法），那么，原始键对应值被新的值替代。如果两个元素不相等，就应该修改比较方法，让比较方法和 equals() 的效果一致 基本操作： Comparator comparator(): 返回对关键字进行排序时使用的比较器，如果使用Comparable接口的compareTo()方法对关键字进行比较，则返回null Object firstKey(): 返回映像中第一个(最低)关键字 Object lastKey(): 返回映像中最后一个(最高)关键字 SortedMap subMap(Object fromKey, Object toKey): 返回从fromKey(包括)至toKey(不包括)范围内元素的SortedMap视图(子集) SortedMap headMap(Object toKey): 返回SortedMap的一个视图，其内各元素的key皆小于toKey SortedSet tailMap(Object fromKey): 返回SortedMap的一个视图，其内各元素的key皆大于或等于fromKey AbstractMap抽象类和其它抽象集合实现相似，AbstractMap 类覆盖了equals()和hashCode()方法以确保两个相等映射返回相同的哈希码。如果两个映射大小相等、包含同样的键且每个键在这两个映射中对 应的值都相同，则这两个映射相等。映射的哈希码是映射元素哈希码的总和，其中每个元素是Map.Entry接口的一个实现。因此，不论映射内部顺序如何， 两个相等映射会报告相同的哈希码。 HashTable内部结构是哈希表，同步的(Vector是单列，对应的双列是HashTable） 任何非null作为键和值 子类properties：用来存储键值对型的配置文件信息，可以和IO技术结合 HashMap内部结构是哈希表，不同步的，允许null作为键和值 在Map 中插入、删除和定位元素，HashMap 是最好的选择 使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现 为了优化HashMap空间的使用，可以调优初始容量和负载因子 基本操作： HashMap(): 构建一个空的哈希映像 HashMap(Map m): 构建一个哈希映像，并且添加映像m的所有映射 HashMap(int initialCapacity): 构建一个拥有特定容量的空的哈希映像 HashMap(int initialCapacity, float loadFactor): 构建一个拥有特定容量和加载因子的空的哈希映像 TreeMap内部结构是二叉树，基于红黑树的NavigableMap实现，不同步的 可以对map集合中的键进行排序，根据键的自然顺序排序或提供的comparator方法排序，具体取决于使用的构造函数。 TreeMap实现SortedMap接口 按自然顺序或自定义顺序遍历键，TreeMap会更好 TreeMap没有调优选项，因为该树总处于平衡状态。 基本操作： TreeMap():构建一个空的映像树 TreeMap(Map m): 构建一个映像树，并且添加映像m中所有元素 TreeMap(Comparator c): 构建一个映像树，并且使用特定的比较器对关键字进行排序 TreeMap(SortedMap s): 构建一个映像树，添加映像树s中所有映射，并且使用与有序映像s相同的比较器排序 LinkedHashMapLinkedHashMap扩展HashMap，以插入顺序将关键字/值对添加进链接哈希映像中。像LinkedHashSet一样，LinkedHashMap内部也采用双重链接式列表 基本操作： LinkedHashMap(): 构建一个空链接哈希映像 LinkedHashMap(Map m): 构建一个链接哈希映像,并且添加映像m中所有映射 LinkedHashMap(int initialCapacity): 构建一个拥有特定容量的空的链接哈希映像 LinkedHashMap(int initialCapacity, float loadFactor): 构建一个拥有特定容量和加载因子的空的链接哈希映像 LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder): 构建一个拥有特定容量、加载因子和访问顺序排序的空的链接哈希映像 如果将accessOrder设置为true,那么链接哈希映像将使用访问顺序而不是插入顺序来迭代各个映像 每次调用get或者put方法时，相关的映射便从它的当前位置上删除，然后放到链接式映像列表的结尾处（只有链接式映像列表中的位置才会受到影响，哈希表元则不受影响。哈希表映射总是待在对应于关键字的哈希码的哈希表元中） 该特性对于实现高速缓存的“删除最近最少使用”的原则很有用。例如，你可以希望将最常访问的映射保存在内存中，并且从数据库中读取不经常访问的对象。 当你在表中找不到某个映射，并且该表中的映射已经放得非常满时，你可以让迭代器进入该表，将它枚举的开头几个映射删除掉。这些是最近最少使用的映射 protected boolean removeEldestEntry(Map.Entry eldest): 如果你想删除最老的映射，则覆盖该方法，以便返回true 当某个映射已经添加给映像之后，便调用该方法。它的默认实现方法返回false，表示默认条件 下老的映射没有被删除 你可以重新定义本方法，以便有选择地在最老的映射符合某个条件，或者映像超过了某个大小时，返回true。 集合框架总结集合框架中还有两个很实用的公用 类：Collections和Arrays。Collections提供了对一个Collection容器进行诸如排序、复制、查找和填充等一些非常有用 的方法，Arrays则是对一个数组进行类似的操作 Collections都是静态方法。具体操作： 1234567891011121314151617181920212223242526272829303132333435363738//1.排序（自然排序）Collections.sort(list);//原理：static&lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)//2.排序（指定比较器）Collections.sort(list,new comparatorA);//原理：static&lt;T&gt; void sort(List&lt;T&gt; list,Comparable&lt;? super T&gt; c);//3.指定位置交换元素Collections.swap(list,i,j);//4.折半(前提是有序，可用sort先排序)int index = Collections.binarySearch(list,"aaa");//index==-num,负表示没找到，num表示应该插入的位置//5.最值Collections.max(list);Collections.max(list,new comparatorByLength());//6.逆序TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(Collections.reverseOrder());//7.替换Collections.replaceAll(list,oldv,newv);//8.随机元素Collections.shuffle(list);//9.将非同步方法转同步方法Collections.synchronizedCollection(Collection&lt;T&gt; c); //list/set/map/* *** 原理:给非同步的集合加锁 *** */class MyCollection&#123; public static List synList(List list)&#123; return new MyList(list); &#125; private class MyList implements List&#123; private List list; private static final Object lock = new Object(); MyList(List list)&#123; this.list = list; &#125; public boolean add (Object obj)&#123; synchronized(lock)&#123; return list.add(obj); &#125; &#125; //remove方法同上add方法 &#125;&#125; Arrays集合框架的工具类，都是静态方法 toString方法 Arrays.toString(arr)； 123456789101112131415//toString的经典实现public static String myToString(int[] arr)&#123; int imax = arr.length-1; if(imax == -1) return "[]"; StringBuilder b = new StringBuilder(); b.append('['); for(int i=0;;i++)&#123;//省略条件判断，提高效率 b.append(a[i]); if(i == imax)&#123; return b.append(']').toString(); &#125;else&#123; b.append(","); &#125; &#125;&#125; asList方法 将数组转成集合，可以使用集合中的方法操作数组元素 Arrays.asList(arr)； 注：数组长度固定，所以集合的增删方法不适用，否则抛unSupportedOperationException 如果数组中的元素是对象，那么转成集合时直接将数组中的元素作为集合中的元素进行存储 如果数组中的元素是基本数据类型，那么会将该数组作为集合中的对象进行存储，例： 12int[] arr = &#123;1,2,3,4,5&#125;;List&lt;int[]&gt; list = Arrays.asList(arr); toArray方法 集合转数组，使用collection接口中的toArray方法，可以对集合中的元素操作的方法进行限定，不允许增删。toArray方法需要 集合小结 array：类似数组，查询快（有角标） link：链表，增删快，add、get、remove + first、last方法 hash：哈希表，唯一性，需要覆盖hashCode和equals方法 tree：二叉树，排序，两个接口comparable和comparator]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(一)基础知识总结]]></title>
    <url>%2F2017%2F07%2F22%2Fjavase%2Fjava-javase01%2F</url>
    <content type="text"><![CDATA[JAVA基础知识总结打算在最近这段时间把java知识系统的复习下，后面分模块总结。 基础 java跨平台原理：不同操作系统下有不同的JVM 注释：/* …… / 这种注释主要是为支持JDK工具javadoc采用的 JRE:：java运行环境，包含JVM和核心类库 JDK：java开发工具，包含JRE，编译工具（javac.exe），打包工具（jar.exe）等 运算符 逻辑运算符： ^按位异或（t ^f –t，t ^t –f，f^f –f） ~按位非 （数字42的二进制：00101010 ——&gt; 11010101） &amp;&amp;与&amp;区别：&amp;&amp;是短路，左式为false则不计算右式，&amp;左右两边式子都计算（||同&amp;&amp;） 》与》&gt;的区别：都是右移，后者无符号右移，空位用0填充 算术运算符： +、-、*、/、% 称为二元运算符 ++、– 称为一元运算符 ​ 局部代码块：{ }内的变量在局部代码块内生效 定义局部变量的生命周期 —— 性能优化 if和switch区别：对于几个固定的值进行判断，建议使用switch，因为switch语句会将具体的答案都加载进内存，效率相对高一点 do while 特点：不管条件是否满足，循环体至少执行一次 java基本数据类型 类型 位长/b 默认值 取值范围 boolean 1 false true/false byte 8 0 -128~127 char 16 \u0000(空) \u0000~\uffff(0~65535) short 16 0 -32768~32767 int 32 0 -2^31~2^31-1 long 64 0 -2^63~2^63-1 float 32 0.0 1.4E-45~3.4028235E38 double 64 0.0 …… java引用类型 引用类型是一个对象类型的，它的值是指向内存空间的一个引用，就是地址。基本类型和引用类型的不同处理： 基本类型在声明的时候系统就已经自动给它分配空间 例：int i; i = 1; 引用类型在声明的时候，只给变量分配了引用空间，数据空间未分配。所以引用类型必须通过实例化开辟数据空间，才能对变量所指向的对象进行访问 例 ：Hexo hexo; hexo = new Hexo(); 变量类型转换 java数字型变量有低到高自动转换，由高到低需要强制转换 字节型，短整型，字符型，整形，长整型，单精度实型，双精度实型 变量与存储器有着直接关系，定义一个变量就是要编译器分配所需要是为内存空间，分配多少空间就是由所定义的变量类型决定的，变量名实际上代表所分配空间的内存首地址 for 和 while 区别： for为了循环而定义的变量，在for循环结束就在内存中释放 while循环使用的变量在循环结束后还可以继续使用 重载：在一个类中，允许存在一个以上的同名函数，参数个数或者参数类型不同即可，与返回值无关，只与参数列表有关 构造函数： 特点：1. 与类名相同； ​ 2.不用定义返回值类型（void也不行）； ​ 3.没有具体的返回值（return是默认的，可以有） 作用：对象进行初始化才能起作用，new对象时触发的方法，不用调用就能执行，创建对象都必须通过构造函数进行初始化。类中如果没有定义构造函数，则系统会默认一个无参构造函数，如果类中定义了则没有默认构造函数（可以定义默认构造函数） 构造函数与一般函数区别： 构造函数：对象创建时，只会调用一次 一般函数：需要调用，可以多次调用 构造函数可以直接调用一般函数，一般函数不能直接调用构造函数，需要创建对象 构造函数使用场景：在描述事物时，该事物一存在就具备的一些内容可以定义在构造函数中 构造函数重载：函数名相同，参数列表不同（参数顺序不同也是重载） 构造函数与构造代码块区别： 构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块 构造函数：是给与之对应的对象进行初始化。它具有针对性。 字符串： String和StringBuffer的主要性能区别： String是不可变的对象，因此每次对String进行改变的时候其实都等于生成了一个新的String对象，然后将指针指向新的String对象，当内存中无引用对象多了以后，JVM的GC就会开始工作，那速度是很慢的；而StringBuffer每次都是对自身对象本身进行操作 而在某些特别情况下，String对象的字符串拼接其实是被JVM解释成StringBuffer对象的拼接，这时候String的效率是比StringBuffer高的。例如： String s = “This is” + “ a” + “ pen” StringBuffer sb = new StringBuffer(“This is”).append(“ a”).append(“ pen”) 这是因为在JVM眼里，s其实就是 This is a pen，所以当字符串来自同一对象时String效率高；当字符串来自另外的String对象时，速度就没那么快了，大部分情况：StringBuffer &gt; String StringBuffer与StringBuilder区别： HashTable是线程安全的，很多方法都是synchronized方法，而HashMap不是线程安全的，但其在单线程程序中的性能比HashTable要高。StringBuffer和StringBuilder类的区别也是如此，他们的原理和操作基本相同，区别在于StringBuffer支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。 由此可见，如果我们的程序是在单线程下运行，或者是不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。 数组：有序数据的集合，先声明后创建 int[] a; 定义数组，并不为数据元素分配空间，因此不用在[]中指出数组的元素个数 a=new int[size]; 创建数组，为数组分配空间，同时进行元素的初始化 java中二维数组分配空间是第二维可以为空，第一维必须分配内存 内存内存划分： 寄存器：CPU处理 本地方法区：调用不同操作系统的内容 方法区：类加载方法 栈内存：存储的都是局部变量，该变量所属的作用域一旦结束，该变量自动释放 特点：变量生命周期短，更新快 堆内存：存储对象（凡是new出来的） 特点：1.每一个实体都有首地址 2.堆内存中的每一个变量都有默认初始化值，根据类型不同而不同，整数是0，小数是0.0，boolean是false，char是’\u0000’ 3.垃圾回收机制 图解： int [] arr = new int [3] arr[0] = 89 syso(arr[0]) arr = null 面向对象万物皆对象，类 —— 属性、方法，是对事物的描述，对象 —— 类中实在的个体，也称为实例；过程和对象在程序中的体现就是：过程其实就是函数，对象是将函数等一些内容进行了封装。面向对象特点： 将复杂的事情简单化 面向对象将以前的过程中的执行者，变成了指挥者 面向对象这种思想是符合现在人们思考习惯的一种思想 成员变量和局部变量 成员变量存在堆内存中，有默认的初始化值，随对象创建而存在，消失而消失；局部变量存在栈内存中，没有默认初始化值，随着所属区域的运行而存在，结束而释放。例： 12345678910public class B&#123; int num; public static void main(String[] args)&#123; int num = 10; B b = new B(); b.num = 4; system.out.println(num); //num = 10 成员变量随对象存在 system.out.println(b.num); //num = 4 &#125;&#125; ​ 匿名对象 定义对象的简写格式： 1new B().show(); 用法：1. 当对象对方法仅进行一次调用的时候 ​ 2.匿名对象可以作为实际参数传递 method(new B()) 使用场景：1. 当对方法只进行一次调用的时候，可以使用匿名对象 ​ 2.当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字 this关键字 1234Person(String name, int age)&#123; this(age); //对this调用必须是构造函数第一行 this.name = name;&#125; 使用场景： 当成员变量和局部变量重名，用this区分。哪个对象调用了this所在的函数，this就代表哪个对象 在定义功能时，如果该功能内部使用到了调用该功能的对象。这时就用this来表示这个对象 this可用于在构造函数中调用其他构造函数，只能定义在构造函数第一行，因为初始化动作要先执行 this 还可以用于构造函数间的调用。 调用格式：this(实际参数)； this对象后面跟上 . 调用的是成员属性和成员方法(一般方法)； this对象后面跟上 () 调用的是本类中的对应参数的构造函数。 static关键字 共享模式，用于修饰成员变量，成员方法 特点：1. 可以被对象调用，也可以直接用类名调用（出现在对象之前，先存在） ​ 2.static修饰的成员被所有对象共享（修改） ​ 3.static优先于对象存在，因为它随类的加载就已经存在 ​ 4.static修饰的数据是共享数据，对象中存储的是特有数据 弊端：1.有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。 ​ 2.静态方法只能访问静态成员，不可以访问非静态成员因为静态方法加载时，优先于对象存在，所以没有办 法访问对象中的成员。 ​ 3.静态方法中不能使用this，super关键字。因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。 成员变量和静态变量区别 成员变量（实例变量）随对象的创建而存在，随对象回收而释放；静态变量（类变量）随类的加载而存在，随类的消失而消失；两者的生命周期不同。弊端是静态变量生命周期太长 调用方式不同，建议静态变量使用类名调用 数据存储位置不同：成员变量存储在堆中，所以也叫对象的特有数据；静态变量数据存储在方法区（的静态区），共享数据 注意：1. 静态方法不能访问非静态成员（因为静态先存在，非静态还不存在），非静态方法都可以访问 ​ 2.静态方法中不可以使用this或super关键字（没对象） ​ 3.主函数是静态的（用对象调用非静态方法） 使用场景 静态变量：当分析对象中所具备的成员变量都是相同的（常量），对象不需要修改则不需要存储在对象中，定义成静态的 静态方法：函数是否用静态修饰，参考该函数是否要访问到对象的特有数据（该功能是否需要访问非静态成员变量），不需要就可以定义成静态的 静态代码块 随类的加载而执行（不需要调用），而且只执行一次，作用是给类进行初始化。若该类中的方法是静态的，则该类不需要创建对象，直接用类名调用方法，这种类需要用静态代码块初始化 1234567891011class StaticCode&#123; static int num; static&#123; //作用类似于封装，可控制属性 num = 10; num += 3; &#125; &#123; //构造代码块---与对象有关，创建几个对象执行几次，可以给所有对象初始化 system.out.println("123"); &#125;&#125; 当类中的方法都是静态的时，所以不需要创建对象，为防止其他类中创建该类的对象，可以将该类的构造方法私有化（构造方法是给对应的对象进行针对性的初始化的） 创建一个对象都在内存中做了什么事情 123456789Person p = new Person();//1.先将硬盘上指定位置的Person.class文件加载进内存//2.执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p//3.在堆内存中开辟一个实体空间，分配了一个内存首地址值new//4.在该实体空间中进行属性的空间分配，并进行了默认初始化//5.对空间中的属性进行显示初始化//6.进行实体的构造代码块初始化//7.调用该实体对应的构造函数，进行构造函数初始化//8.将首地址赋值给p ，p变量就引用了该实体(指向了该对象) ​ 类的访问权限 对于Java中的“类”（不是其内部成员，两者要区分开），其访问权限修饰词仅有public和“无”（即包访问权）两种，而没有private和protected（有 一个特例，就是“内部类”，其可以是private或protected的）。所以对于类的访问权限，你仅有两个选择：包访问权或是public。如果你 不希望其他任何人对该类拥有访问权，你可以把所有的构造器都指定为private，从而阻止任何人创建该类的对象。但是有一个例外，就是在该类的 static成员内部进行创建。如： 12345678class Soup &#123; // private Constructor! private Soup() &#123;&#125; // Allow creation via static method: public static Soup makeSoup() &#123; return new Soup(); &#125; &#125; 如果一个类的访问权限为“包访问权”，并且其内部有一个static的成员为public的话，则其他包中的类仍旧可以访问该static成员，哪怕它们并不能生成该类的对象。 类之间的三种关系 依赖关系（uses-a）、聚集关系（has-a）、集成关系（is-a） ​ 封装隐藏对象的属性及实现细节，封装成set/get方法，对属性可控，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员 封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过 外部接口，一特定的访问权限来使用类的成员 封装的原则： 把尽可能多的东西藏起来.对外提供简捷的接口 把所有的属性藏起来 封装好处：将变化隔离；便于使用；提高重用性；安全性 private 只能修饰成员，不能修饰局部 继承对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类），并且java中是单继承（两父类中有相同方法时不知道执行哪个，会产生调用的不确定性），一个子类只能有一个父类继承中的构造方法 当生成子类对象时，Java默认首先调用父类的不带参数的构造方法，然后执行该构造方法，生成父类的对象。接下来，再去调用子类的构造方法，生成子类的对象。【要想生成子类的对象，首先需要生成父类的对象，没有父类对象就没有子类对象。 方法重写 重写的要求：子类覆盖方法和父类被覆盖方法的方法返回类型，方法名称，参数列表必须相同 子类覆盖方法的访问权限必须大于等于父类的方法的访问权限 方法覆盖只能存在于子类和父类之间 子类覆盖方法不能比父类被覆盖方法抛出更多异常 方法重写与方法重载 重载发生在同一个类内部的两个或多个方法。重写发生在父类与子类之间 final关键字在继承中的使用 修饰变量，包括静态的和非静态的 表示这个变量被赋予的值是不可变的，即它是个常量 修饰对象 表示这个变量被赋予的引用是不可变的，不可改变的只是这个变量所保存的引用，并不是这个引用所指向的对象 修饰方法 表示这个方法不可以被子类重写，但是它这不影响它被子类继承 说明：具有private访问权限的方法也可以增加final修饰，但是由于子类无法继承private方法，因此也无法重写它。编译器在处理private方法时，是按照final方法来对待的，这样可以提高该方法被调用时的效率。不过子类仍然可以定义同父类中的private方法具有同样结构的方法，但是这并不会产生重写的效果，而且它们之间也不存在必然联系 修饰类 由于final类不允许被继承，编译器在处理时把它的所有方法都当作final的，因此final类比普通类拥有更高的效率。final的类的所有方法都不能被重写，但这并不表示final的类的属性（变量）值也是不可改变的，要想做到final类的属性值不可改变，必须给它增加final修饰 内部类只能访问被final修饰的局部变量 更贴切的表述final的含义的描述，那就是，如果一个变量或方法参数被final修饰，就表示它只能被赋值一次，但是JAVA虚拟机为变量设定的默认值不记作一次赋值。被final修饰的变量必须被初始化。初始化的方式有以下几种： 在定义的时候初始化。 在初始化块中初始化。 在类的构造器中初始化。 静态变量也可以在静态初始化块中初始化。 继承中子父类成员特点 成员变量：不存在覆盖，有不同的作用域 12this.num = 4; //this代表一个本类对象的引用super.num = 5; //super代表一个父类空间 成员函数：当子父类中出现同样的方法时，会运行子类的方法，称为重写（override） 重写注意事项 子类权限必须大于等于父类权限 父类方法为private时不叫重写，建议子类起不一样的名字 子父类方法要同时为静态或非静态方法才能重写 构造函数：无重写，也没继承过来，靠super() 在子类构造对象时，发现父类的构造函数也运行了 在子类构造函数第一行有一个默认的隐式语句super()，调用的是父类空参数的构造函数（默认） 如果父类中没有定义空参数构造函数，则子类构造函数必须用super明确调用父类的哪一构造函数 子类构造函数中如果使用this调用了本类的构造函数时，super()就没有了，但是子类肯定有构造函数调用父类的 通过super初始化父类内容时，子类的成员变量并未显式初始化（会默认初始化），等super()父类初始化完之后，才进行子类成员变量的显式初始化 关于继承的几点注意 父类有的，子类也有 父类没有的，子类可以增加 父类有的，子类可以改变 构造方法不能被继承 方法和属性可以被继承 子类的构造方法隐式地调用父类的不带参数的构造方法 当父类没有不带参数的构造方法时，子类需要使用super来显式地调用父类的构造方法，super指的是对父类的引用 super关键字必须是构造方法中的第一行语句 内存中父类先进代码区 子类不能继承父类中私有的内容（可以super.getmethod()访问） 多态多态（Polymorphism）：父类型的引用可以指向子类的对象，方法的重写、重载与动态连接构成多态性。 java引入多态的原因 Java只 允许单继承，派生类与基类间有IS-A的关系，这样做虽然保证了继承关系的简单明了，但是势必在功能上有很大的限制，所以，Java引入了多态性的概念以弥补这点的不足，此外，抽象类和接 口也是解决单继承规定限制的重要手段 多态前提 必须有关系：继承，实现 要有方法的重写 类的多态 在一个类中，可以定义多个同名的方法，只要确定它们的参数个数和类型不同。类的多态体现在两方面： 一是方法的重载上，包括成员方法和构造方法的重载 二是在继承过程中，方法的重写 对象多态性 主要是指子类和父类对象的相互转换关系 向上类型转换（upcast）：比如说将Cat类型转换为Animal类型，即将子类型转换为父类型。对于向上类型转换，不需要显式指定 向下类型转换（downcast）：比如将Animal类型转换为Cat类型。即将父类型转换为子类型。对于向下类型转换，必须要显式指定（必须要使用强制类型转换） 类型判断 instanceof：对象类型的判断，只能用于引用数据类型判断，可以是类，可以是接口，通常在向下转型前用于健壮性判断 多态特点 成员变量 12FU f = new zi();f.num = 3;//父类成员变量 编译和运行都参考等号的左边（引用型变量所属的类） 成员函数（非静态） 编译时：参考引用型变量所属的类中是否有调用的函数，有则编译通过，没有则失败 运行时：参考的是对象所的类中是否有调用的函数 简单总结：编译看左，运行看右 静态函数 编译和运行都看左边 多态小结 Java中除了static、final和private方法外，其他所有的方法都是运行时绑定的，当在派生类中重写基类中static、final、或 private方法时，实质上是创建了一个新的方法 在派生类中，对于基类中的private方法，最好采用不同的名字 包含抽象方法的类叫做抽象类，抽象类在派生中就是作为基类的角色，为不同的子类提供通用的接口 在基类的构造方法中小心调用基类中被重写的方法，这里涉及到对象初始化顺序 抽象抽象类（abstract class）：使用了abstract关键字所修饰的类叫做抽象类。抽象类无法实例化，也就是说，不能new出来一个抽象类的对象（实例） 抽象方法（abstract method）：使用abstract关键字所修饰的方法叫做抽象方法。抽象方法需要定义在抽象类中 如果一个类中包含了抽象方法，那么这个类一定要声明成abstract class，也就是说，该类一定是抽象类；反之，如果某个类是抽象类，那么该类既可以包含抽象方法，也可以包含具体方法。 抽象类特点 抽象类不可以被实例化，因为调用抽象方法没意义 在子类继承父类（父类是个抽象类）的情况下，那么该子类必须要实现父类中所定义的所有抽象方法；否则，该子类需要声明成一个abstract class 抽象类细节 抽象类中有构造函数，用于给子类对象进行初始化 抽象类可以不定义抽象方法 目的就是不让该类创建对象，AWT的适配器对象就是这种类，通常这种类中的方法有方法体，但是没有内容 abstract关键字不可以和private、static、final组合 抽象类一定是父类（要被使用则子类需要重写其方法） 抽象类和一般类异同点 相同点：都是用来描述事物 不同点：抽象类描述信息不全；一般类中不能定义抽象方法；抽象类不可以被实例化 接口接口（interface）中的方法都是抽象方法。java不支持多继承，但可以实现（implements）多个接口,间接的实现了多继承。接口不可以实例化，只能由实现了接口的子类并覆盖了接口的所有抽象方法后，该子类才可以实例化，否则这个子类就是抽象类 接口中的成员修饰符都是固定的 成员常量：public static final（不写则系统默认），必须被显示初始化 成员函数：public abstract 接口中的成员都是public的 接口中没有构造方法,不能被实例化 多实现 一个类可以实现多个接口，因为接口没有方法体，所以不会出现调用的不确定性，实现多实现 接口的特点 接口是对外暴露的规则 接口是程序的给你扩展 接口降低耦合性 不允许创建接口的实例(实例化)，但允许定义接口类型的引用变量，该引用变量引用实现了这个接口的类的实例 通过接口可以方便地对已经存在的系统进行自下而上的抽象，对于任意两个类,不管它们是否属于同一个父类，只有它们存在相同的功能,就能从中抽象出一个接口类型。对于已经存在的继承树,可以方便的从类中抽象出新的接口，但从类中抽象出新的抽象类却不那么容易，因此接口更有利于软件系统的维护与重构，对于两 个系统,通过接口交互比通过抽象类交互能获得更好的松耦合 接口是构建松耦合软件系统的重要法宝，由于接口用于描述系统对外提供的所有服务，因此接口中的成员变量和方法都必须是public类型的，确保外部使用者 能访问它们,接口仅仅描述系统能做什么，但不指明如何去做，所有接口中的方法都是抽象方法，接口不涉及和任何具体实例相关的细节，因此接口没有构造方法,，不能被实例化，没有实例变量 接口和抽象类的区别 相同点 都是不断向上抽取而来，提高两个系统之间的松耦合 都不能被实例化 都包含抽象方法,这些抽象方法用于描述系统能提供哪些服务,但不提供具体的实现 不同点 抽象类需要被继承，而且是单继承；接口需要被实现，可以多实现 抽象类中可以定义抽象方法和非抽象方法，子类继承后可以直接使用非抽象方法；接口只能定义抽象方法，必须由子类实现 抽象类的继承是is-a关系，在定义该体系的基本共性内容；接口的实现是like-a关系，在定义体系额外功能 使用接口和抽象类的总体原则 用接口作为系统与外界交互的窗口站在外界使用者(另一个系统)的角度，接口向使用者承诺系统能提供哪些服务，站在系统本身的角度，接口制定系统必须实现哪 些服务，接口是系统中最高层次的抽象类型。通过接口交互可以提高两个系统之间的送耦合系统A通过系统B进行交互，是指系统A访问系统B时，把引用变量声明 为系统B中的接口类型，该引用变量引用系统B中接口的实现类的实例 Java接口本身必须非常稳定，Java接口一旦制定，就不允许随遇更加，否则对外面使用者及系统本身造成影响 用抽象类来定制系统中的扩展，抽象类来完成部分实现，还要一些功能通过它的子类来实现 接口总结 在抽象类中可以为部分方法提供默认的实现，从而避免在子类中重复实现它们，这是抽象类的优势，但这一优势限制了多继承，而接口中只能包含抽象方法。由于在 抽象类中允许加入具体方法，因此扩展抽象类的功能，即向抽象类中添加具体方法，不会对它的子类造成影响，而对于接口，一旦接口被公布，就必须非常稳定，因 为随意在接口中添加抽象方法，会影响到所有的实现类，这些实现类要么实现新增的抽象方法，要么声明为抽象类 为了简化系统结构设计和动态绑定机制，Java语言禁止多重继承。而接口中只有抽象方法，没有实例变量和静态方法，只有接口的实现类才会实现 接口的抽象方法(接口中的抽象方法是通过类来实现的)，因此，一个类即使有多个接口，也不会增加Java虚拟机进行动态绑定的复杂度。因为Java虚拟机 永远不会把方法与接口绑定，而只会把方法与它的实现类绑定 内部类 使用内部类的原因 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响 接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整 123456789101112131415161718public interface Father &#123;&#125;public interface Mother &#123;&#125;public class Son implements Father, Mother &#123;&#125;public class Daughter implements Father&#123; class Mother_ implements Mother&#123; //如果Father、Mother不是接口，而是抽象类或者具体类,这个时候我们就只能使用内部类才能实现多重继承了。 &#125;&#125; ​ 内部类特性（Think in java） 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类 创建内部类对象的时刻并不依赖于外围类对象的创建 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体 内部类提供了更好的封装，除了该外围类，其他类都不能访问 访问特点 内部类可以直接访问外部类中的成员，包括私有成员；而外部类要访问内部类中的成员必须建立内部类的对象 直接访问内部类： 1234Outer.Inner in = new Outer().new Inner();in.show();//引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName//同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类 再有： 123456789101112class Outer&#123; int num = 3; class Inner&#123; int num = 4; void show()&#123; int num = 5; system.out.println(num); //5 system.out.println(this.num); //4 system.out.println(Outer.this.num); //3 &#125; &#125;&#125; 内部类能直接访问外部类中的成员的原因是内部类持有外部类的引用（Outer.this） 编译成功后产生：Outer.class和Outer$Inner.class两个class文件 成员内部类 12345678910111213141516171819202122232425262728293031public class OuterClass &#123; private String str; public void outerDisplay()&#123; System.out.println("outerClass..."); &#125; public class InnerClass&#123; public void innerDisplay()&#123; //使用外围内的属性 str = "chenssy..."; System.out.println(str); //使用外围内的方法 outerDisplay(); &#125; &#125; /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */ public InnerClass getInnerClass()&#123; return new InnerClass(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.getInnerClass(); inner.innerDisplay(); &#125;&#125;--------------------chenssy...outerClass... 成员内部类中不能存在任何static的变量和方法 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类 局部内部类 它是嵌套在方法和作用域内的，主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 定义在方法： 12345678910111213141516171819public class Parcel5 &#123; public Destionation destionation(String str)&#123; class PDestionation implements Destionation&#123; private String label; private PDestionation(String whereTo)&#123; label = whereTo; &#125; public String readLabel()&#123; return label; &#125; &#125; return new PDestionation(str); &#125; public static void main(String[] args) &#123; Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation("chenssy"); &#125;&#125; 定义在作用域： 1234567891011121314151617181920212223242526public class Parcel6 &#123; private void internalTracking(boolean b)&#123; if(b)&#123; class TrackingSlip&#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip()&#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip("chenssy"); String string = ts.getSlip(); &#125; &#125; public void track()&#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel6 parcel6 = new Parcel6(); parcel6.track(); &#125;&#125; 匿名内部类 其实就是一个匿名子类对象，例： 123456button2.addActionListener( new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println("你按了按钮二"); &#125; &#125;); 再有： 1234567891011121314151617181920212223public class OuterClass &#123; public InnerClass getInnerClass(final int num,String str2)&#123; return new InnerClass()&#123; int number = num + 3; public int getNumber()&#123; return number; &#125; &#125;; /* 注意：分号不能省 */ &#125; public static void main(String[] args) &#123; OuterClass out = new OuterClass(); InnerClass inner = out.getInnerClass(2, "chenssy"); System.out.println(inner.getNumber()); &#125;&#125;interface InnerClass &#123; int getNumber();&#125;----------------Output: 注意： 匿名内部类是没有访问修饰符的 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法 使用场景： 当函数参数是接口类型时而且接口中的方法不超过三个，可以用匿名内部类作为实际参数进行传递 静态内部类 静态内部类访问： 12Outer.Inner in = new Outer.Inner();//外部类一加载，内部类就已经在内存了，相当一外部类，所以不用创建外部类对象 如果内部类中有静态方法，内部类也必须是静态的 静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖于外围类的。 它不能使用任何外围类的非static成员变量和方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class OuterClass &#123; private String sex; public static String name = "chenssy"; /** *静态内部类 */ static class InnerClass1&#123; /* 在静态内部类中可以存在静态成员 */ public static String _name1 = "chenssy_static"; public void display()&#123; /* * 静态内部类只能访问外围类的静态成员变量和方法 * 不能访问外围类的非静态成员变量和方法 */ System.out.println("OutClass name :" + name); &#125; &#125; /** * 非静态内部类 */ class InnerClass2&#123; /* 非静态内部类中不能存在静态成员 */ public String _name2 = "chenssy_inner"; /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */ public void display()&#123; System.out.println("OuterClass name：" + name); &#125; &#125; /** * @desc 外围类方法 */ public void display()&#123; /* 外围类访问静态内部类：内部类. */ System.out.println(InnerClass1._name1); /* 静态内部类 可以直接创建实例不需要依赖于外围类 */ new InnerClass1().display(); /* 非静态内部的创建需要依赖于外围类 */ OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2(); /* 方位非静态内部类的成员需要使用非静态内部类的实例 */ System.out.println(inner2._name2); inner2.display(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); outer.display(); &#125;&#125;----------------Output:chenssy_staticOutClass name :chenssychenssy_innerOuterClass name：chenssy 对象的初始化过程 最开始是默认初始化 构造器的执行在显示初始化前 再是构造代码块在构造函数之前]]></content>
      <categories>
        <category>JAVA</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识动态规划]]></title>
    <url>%2F2017%2F07%2F19%2Falgorithm%2FDynamicPramming%2F</url>
    <content type="text"><![CDATA[初识动态规划有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。 比如，每次走1级台阶，一共走10步，这是其中一种走法。我们可以简写成 1,1,1,1,1,1,1,1,1,1。 思路 可以利用排列组合的思想，写一个多层嵌套循环遍历出所有的可能性，没遍历出一个组合，计数器加一 这是暴力枚举，时间复杂度是指数级的 要不找个楼梯走一下，正好可以减肥 你走下试试，捂脸 使用动态规划思想 动态规划简介动态规划Dynamic Programming，是一种分阶段求解决策问题的数学思想。不止用于编程领域，也应用于管理学、经济学、生物学。总结起来就是大事化小，小事化了。动态规划中的三个重要概念：[最优子结构]、[边界]、[状态转移公式]。这些后续再更新 动态规划解决思路 我们先不管前面怎么走，要想走到第10级台阶，最后一步必然是从第8级或者第9级开始 设从0到9级台阶的走法有X种，0到8级台阶的走法有Y种 10级台阶的所有走法可以根据最后一步的不同分成两部分，8级台阶的走法和9级台阶的走法 所以总的走法数量就是X+Y : F(10)=F(9)+F(8) 所以可以得出结论： F(1)=1 (n=1); F(2)=2 (n=2); F(n)=F(n-1)+F(n-2) (n&gt;=3) 所以F[9]和F[8]是F[10]的【最优子结构】，F[1]和F[2]是问题的【边界】，F[n]=F[n-1]+F[n-2]是阶段间的【状态转移方程】 方法一：递归求解 12345678910111213int getPaceCount(int n)&#123; if(n &lt; 1)&#123; return 0; &#125; if(n == 1)&#123; return 1; &#125; if(n == 2)&#123; return 2; &#125; return getPaceCount(n-1) + getPaceCount(n-2);&#125; 时间复杂度 要计算F[n]就得先计算F[n-1]和F[n-2]，以此类推，树的节点个数就是递归方法需要计算的次数。这颗树的高度是n-1，节点个数接近2的n-1次方，所以方法的时间复杂度约为O(2^N)。 方法二：备忘录算法 从上面的递归图可以看出相同的参数被重复计算了，所以优化的话我们可以用缓存，先建一个哈希表，每次把不同参数的计算结果存入哈希表，当遇到相同参数时，再从哈希表里取出就不用重复计算了。这种暂存计算的方式叫做【备忘录算法】 123456789101112131415161718int getPaceCount(int n, HashMap&lt;Integer, Integer&gt; result)&#123; if(n &lt; 1)&#123; return 0; &#125; if(n == 1)&#123; return 1; &#125; if(n == 2)&#123; return 2; &#125; if(result.contains(n))&#123; return result.get(n); &#125;else&#123; int value = getPaceCount(n-1) + getPaceCount(n-2); result.put(n,value); return value; &#125;&#125; 从F[1]到F[n]一共有n个不同输入，在哈希表中存了n-2个结果，所以这种算法的时间复杂度和空间复杂度都是O(N) 方法三：动态规划算法 上面的备忘录算法时间复杂度已经不能再小了，而且上面两个方法都是自顶向下的。 下面是自底向上的动态规划思想求解过程： 第一次迭代时，台阶数是3，走法是3，走法F[3]只依赖于F[1]和F[2]；第二次迭代时，台阶是4，走法是5，走法F[4]只依赖于F[3]和F[2]。由此可见，每次迭代过程中，只要保留之前的两个状态，就可以推导出新的状态，而不需要像备忘录算法那样保留全部的子状态。 动态规划代码实现： 1234567891011121314151617181920int getPaceCount(int n)&#123; if(n &lt; 1)&#123; return 0; &#125; if(n == 1)&#123; return 1; &#125; if(n == 2)&#123; return 2; &#125; int a = 1; int b = 2; int temp = 0; for(int i=3; i&lt;=n; i++)&#123; temp = a + b; a = b; b = temp; &#125; return temp;&#125; 程序从 i=3 开始迭代，一直到 i=n 结束。每一次迭代，都会计算出多一级台阶的走法数量。迭代过程中只需保留两个临时变量a和b，分别代表了上一次和上上次迭代的结果。 为了便于理解，我引入了temp变量。temp代表了当前迭代的结果值。 这样动态规划时间复杂度是O(N)，由于只引入了两三个变量，所以空间复杂度只有O(1)，利用简介的自底向上的递推方式，实现了时间和空间的最优化 国王和金矿问题有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ 最优子结构总结]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客]]></title>
    <url>%2F2017%2F07%2F17%2Fblogs%2Fhexo%2F</url>
    <content type="text"><![CDATA[Hexo+Github搭建个人博客​ hexo是一个简洁、高效且开源的博客框架，是用node.js开发的。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 环境 win10 64位旗舰版 node.js git github账户 安装hexo 在本地磁盘创建文件夹，例E : /hexo,并以命令行进入该目录 在命令行输入： npm install hexo-cli -g npm install hexo –save hexo -v 看到下图信息，表示hexo安装成功 初始化hexo 需要新建一空文件夹 hexo init npm install 首次体验hexo hexo g hexo s 然后看到提示： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 在浏览器中打开http://localhost:4000/ ​ 关联Hexo与Github Page 设置git的username和useremail git config –global user.name “username” git config –global user.email “useremail” 生成密钥 ssh-keygen -t rsa -C “useremail” 连续3个回车。如果不需要密码的话。 检查是否已经有SSH Key cd ~/.ssh ls 列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件，如果存在的话，证明已经存在 ssh key了。这两文件默认的存储路径是： C:\Users\Administrator.ssh ​ 将公钥添加到Github账户 测试 ssh -T git@github.com 看到下面则说明成功： Hi humingx! You’ve successfully authenticated, but GitHub does not provide shell access. ​ 配置Deployment 在站点配置文件_config.yml中，找到Deployment： deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 踩坑提醒 如果此时你写博客发布时，需要提前安装一个扩展： npm install hexo-deployer-git –save 否则将会提醒： deloyer not found:git Next主题 安装主题： cd your-hexo-site git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题： 修改站点配置文件： theme: next 验证主题： hexo s http://localhost:4000 主题设定： 修改主题配置文件： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 不选择的主题#注释即可。 语言设置： 修改主题配置文件： language: zh-Hans 菜单设置： 修改主题配置文件： menu: home: / archives: /archives about: /about categories: /categories tags: /tags commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉。 翻译文本放置在NexT 主题目录下的 languages/{language}.yml 。 头像设置： 编辑 站点配置文件， 新增字段 avatar， 值设置成头像的链接地址。 将头像放在source/image/目录下（或在source下新建uploads文件夹） avatar: /images/avatar.png 当然值也可以是URL地址。 作者设置： 修改站点配置文件： author : dodd 备份库这里采用新建一个新的分支backup来做备份。 在github上面新建分支backup 拉分支： git clone -b backup git@ git@github.com:yourname/yourname.github.io.git 将hexo文件内的内容替换新拉下来的分支内容（注意需要删除掉hexo根目录和next目录下的.git） hexo s 开服务，本地查看校验 git add –all git commit -m “commit instruction” git push origin backup (将本地文件推到远程库备份，防止多地提交文件互冲) 注意：第一次拉下来的分支，提交备份库需要git push -u origin backup hexo g(生成) hexo d(部署) 插件以及第三方服务遇到的问题 文章头标题设定： 需要在最上一行：- - -三个-进入设定头标题、日期、分类、标签等。 图片的显示问题： 使用CodeFalling/hexo-asset-image的插件来加载本地图片 修改站点配置文件post_asset_folder:true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save 完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹 使用 ![test](test/test.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。 新建文章时使用hexo命令： hexo new post “article title” 系统会自动生成一个同名文件夹可以用来放图片 hexo s报错： ERROR Local hexo not found in G:\XcantloadXERROR Try running: ‘npm install hexo –save’ 按照提示安装依然报错，原因是node有问题，重新安装node即可 参考文档 手把手教你用Hexo+Github 搭建属于自己的博客 nexT Hexo]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
